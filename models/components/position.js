/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
/** @internal */
export const AdjustedSettled$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const AdjustedSettled$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AdjustedSettled$;
(function (AdjustedSettled$) {
    /** @deprecated use `AdjustedSettled$inboundSchema` instead. */
    AdjustedSettled$.inboundSchema = AdjustedSettled$inboundSchema;
    /** @deprecated use `AdjustedSettled$outboundSchema` instead. */
    AdjustedSettled$.outboundSchema = AdjustedSettled$outboundSchema;
})(AdjustedSettled$ || (AdjustedSettled$ = {}));
export function adjustedSettledToJSON(adjustedSettled) {
    return JSON.stringify(AdjustedSettled$outboundSchema.parse(adjustedSettled));
}
export function adjustedSettledFromJSON(jsonString) {
    return safeParse(jsonString, (x) => AdjustedSettled$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'AdjustedSettled' from JSON`);
}
/** @internal */
export const AdjustedTrade$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const AdjustedTrade$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AdjustedTrade$;
(function (AdjustedTrade$) {
    /** @deprecated use `AdjustedTrade$inboundSchema` instead. */
    AdjustedTrade$.inboundSchema = AdjustedTrade$inboundSchema;
    /** @deprecated use `AdjustedTrade$outboundSchema` instead. */
    AdjustedTrade$.outboundSchema = AdjustedTrade$outboundSchema;
})(AdjustedTrade$ || (AdjustedTrade$ = {}));
export function adjustedTradeToJSON(adjustedTrade) {
    return JSON.stringify(AdjustedTrade$outboundSchema.parse(adjustedTrade));
}
export function adjustedTradeFromJSON(jsonString) {
    return safeParse(jsonString, (x) => AdjustedTrade$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'AdjustedTrade' from JSON`);
}
/** @internal */
export const DateT$inboundSchema = z
    .object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const DateT$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var DateT$;
(function (DateT$) {
    /** @deprecated use `DateT$inboundSchema` instead. */
    DateT$.inboundSchema = DateT$inboundSchema;
    /** @deprecated use `DateT$outboundSchema` instead. */
    DateT$.outboundSchema = DateT$outboundSchema;
})(DateT$ || (DateT$ = {}));
export function dateToJSON(dateT) {
    return JSON.stringify(DateT$outboundSchema.parse(dateT));
}
export function dateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => DateT$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'DateT' from JSON`);
}
/** @internal */
export const PositionFpsl$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const PositionFpsl$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var PositionFpsl$;
(function (PositionFpsl$) {
    /** @deprecated use `PositionFpsl$inboundSchema` instead. */
    PositionFpsl$.inboundSchema = PositionFpsl$inboundSchema;
    /** @deprecated use `PositionFpsl$outboundSchema` instead. */
    PositionFpsl$.outboundSchema = PositionFpsl$outboundSchema;
})(PositionFpsl$ || (PositionFpsl$ = {}));
export function positionFpslToJSON(positionFpsl) {
    return JSON.stringify(PositionFpsl$outboundSchema.parse(positionFpsl));
}
export function positionFpslFromJSON(jsonString) {
    return safeParse(jsonString, (x) => PositionFpsl$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PositionFpsl' from JSON`);
}
/** @internal */
export const Free$inboundSchema = z
    .object({
    value: z.string().optional(),
});
/** @internal */
export const Free$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Free$;
(function (Free$) {
    /** @deprecated use `Free$inboundSchema` instead. */
    Free$.inboundSchema = Free$inboundSchema;
    /** @deprecated use `Free$outboundSchema` instead. */
    Free$.outboundSchema = Free$outboundSchema;
})(Free$ || (Free$ = {}));
export function freeToJSON(free) {
    return JSON.stringify(Free$outboundSchema.parse(free));
}
export function freeFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Free$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Free' from JSON`);
}
/** @internal */
export const LastAdjustedDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const LastAdjustedDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var LastAdjustedDate$;
(function (LastAdjustedDate$) {
    /** @deprecated use `LastAdjustedDate$inboundSchema` instead. */
    LastAdjustedDate$.inboundSchema = LastAdjustedDate$inboundSchema;
    /** @deprecated use `LastAdjustedDate$outboundSchema` instead. */
    LastAdjustedDate$.outboundSchema = LastAdjustedDate$outboundSchema;
})(LastAdjustedDate$ || (LastAdjustedDate$ = {}));
export function lastAdjustedDateToJSON(lastAdjustedDate) {
    return JSON.stringify(LastAdjustedDate$outboundSchema.parse(lastAdjustedDate));
}
export function lastAdjustedDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => LastAdjustedDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'LastAdjustedDate' from JSON`);
}
/** @internal */
export const PendingDrip$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const PendingDrip$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var PendingDrip$;
(function (PendingDrip$) {
    /** @deprecated use `PendingDrip$inboundSchema` instead. */
    PendingDrip$.inboundSchema = PendingDrip$inboundSchema;
    /** @deprecated use `PendingDrip$outboundSchema` instead. */
    PendingDrip$.outboundSchema = PendingDrip$outboundSchema;
})(PendingDrip$ || (PendingDrip$ = {}));
export function pendingDripToJSON(pendingDrip) {
    return JSON.stringify(PendingDrip$outboundSchema.parse(pendingDrip));
}
export function pendingDripFromJSON(jsonString) {
    return safeParse(jsonString, (x) => PendingDrip$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PendingDrip' from JSON`);
}
/** @internal */
export const PendingOutgoingAcat$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const PendingOutgoingAcat$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var PendingOutgoingAcat$;
(function (PendingOutgoingAcat$) {
    /** @deprecated use `PendingOutgoingAcat$inboundSchema` instead. */
    PendingOutgoingAcat$.inboundSchema = PendingOutgoingAcat$inboundSchema;
    /** @deprecated use `PendingOutgoingAcat$outboundSchema` instead. */
    PendingOutgoingAcat$.outboundSchema = PendingOutgoingAcat$outboundSchema;
})(PendingOutgoingAcat$ || (PendingOutgoingAcat$ = {}));
export function pendingOutgoingAcatToJSON(pendingOutgoingAcat) {
    return JSON.stringify(PendingOutgoingAcat$outboundSchema.parse(pendingOutgoingAcat));
}
export function pendingOutgoingAcatFromJSON(jsonString) {
    return safeParse(jsonString, (x) => PendingOutgoingAcat$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PendingOutgoingAcat' from JSON`);
}
/** @internal */
export const PendingWithdrawal$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const PendingWithdrawal$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var PendingWithdrawal$;
(function (PendingWithdrawal$) {
    /** @deprecated use `PendingWithdrawal$inboundSchema` instead. */
    PendingWithdrawal$.inboundSchema = PendingWithdrawal$inboundSchema;
    /** @deprecated use `PendingWithdrawal$outboundSchema` instead. */
    PendingWithdrawal$.outboundSchema = PendingWithdrawal$outboundSchema;
})(PendingWithdrawal$ || (PendingWithdrawal$ = {}));
export function pendingWithdrawalToJSON(pendingWithdrawal) {
    return JSON.stringify(PendingWithdrawal$outboundSchema.parse(pendingWithdrawal));
}
export function pendingWithdrawalFromJSON(jsonString) {
    return safeParse(jsonString, (x) => PendingWithdrawal$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PendingWithdrawal' from JSON`);
}
/** @internal */
export const Settled$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const Settled$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Settled$;
(function (Settled$) {
    /** @deprecated use `Settled$inboundSchema` instead. */
    Settled$.inboundSchema = Settled$inboundSchema;
    /** @deprecated use `Settled$outboundSchema` instead. */
    Settled$.outboundSchema = Settled$outboundSchema;
})(Settled$ || (Settled$ = {}));
export function settledToJSON(settled) {
    return JSON.stringify(Settled$outboundSchema.parse(settled));
}
export function settledFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Settled$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Settled' from JSON`);
}
/** @internal */
export const PositionTrade$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const PositionTrade$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var PositionTrade$;
(function (PositionTrade$) {
    /** @deprecated use `PositionTrade$inboundSchema` instead. */
    PositionTrade$.inboundSchema = PositionTrade$inboundSchema;
    /** @deprecated use `PositionTrade$outboundSchema` instead. */
    PositionTrade$.outboundSchema = PositionTrade$outboundSchema;
})(PositionTrade$ || (PositionTrade$ = {}));
export function positionTradeToJSON(positionTrade) {
    return JSON.stringify(PositionTrade$outboundSchema.parse(positionTrade));
}
export function positionTradeFromJSON(jsonString) {
    return safeParse(jsonString, (x) => PositionTrade$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PositionTrade' from JSON`);
}
/** @internal */
export const Unrestricted$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const Unrestricted$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Unrestricted$;
(function (Unrestricted$) {
    /** @deprecated use `Unrestricted$inboundSchema` instead. */
    Unrestricted$.inboundSchema = Unrestricted$inboundSchema;
    /** @deprecated use `Unrestricted$outboundSchema` instead. */
    Unrestricted$.outboundSchema = Unrestricted$outboundSchema;
})(Unrestricted$ || (Unrestricted$ = {}));
export function unrestrictedToJSON(unrestricted) {
    return JSON.stringify(Unrestricted$outboundSchema.parse(unrestricted));
}
export function unrestrictedFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Unrestricted$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Unrestricted' from JSON`);
}
/** @internal */
export const Position$inboundSchema = z.object({
    account_id: z.string().optional(),
    adjusted_settled: z.nullable(z.lazy(() => AdjustedSettled$inboundSchema))
        .optional(),
    adjusted_trade: z.nullable(z.lazy(() => AdjustedTrade$inboundSchema))
        .optional(),
    asset_id: z.string().optional(),
    correspondent_id: z.string().optional(),
    date: z.nullable(z.lazy(() => DateT$inboundSchema)).optional(),
    fpsl: z.nullable(z.lazy(() => PositionFpsl$inboundSchema)).optional(),
    free: z.nullable(z.lazy(() => Free$inboundSchema)).optional(),
    last_adjusted_date: z.nullable(z.lazy(() => LastAdjustedDate$inboundSchema))
        .optional(),
    name: z.string().optional(),
    pending_drip: z.nullable(z.lazy(() => PendingDrip$inboundSchema)).optional(),
    pending_outgoing_acat: z.nullable(z.lazy(() => PendingOutgoingAcat$inboundSchema)).optional(),
    pending_withdrawal: z.nullable(z.lazy(() => PendingWithdrawal$inboundSchema))
        .optional(),
    position_version: z.string().optional(),
    settled: z.nullable(z.lazy(() => Settled$inboundSchema)).optional(),
    trade: z.nullable(z.lazy(() => PositionTrade$inboundSchema)).optional(),
    unrestricted: z.nullable(z.lazy(() => Unrestricted$inboundSchema)).optional(),
}).transform((v) => {
    return remap$(v, {
        "account_id": "accountId",
        "adjusted_settled": "adjustedSettled",
        "adjusted_trade": "adjustedTrade",
        "asset_id": "assetId",
        "correspondent_id": "correspondentId",
        "last_adjusted_date": "lastAdjustedDate",
        "pending_drip": "pendingDrip",
        "pending_outgoing_acat": "pendingOutgoingAcat",
        "pending_withdrawal": "pendingWithdrawal",
        "position_version": "positionVersion",
    });
});
/** @internal */
export const Position$outboundSchema = z.object({
    accountId: z.string().optional(),
    adjustedSettled: z.nullable(z.lazy(() => AdjustedSettled$outboundSchema))
        .optional(),
    adjustedTrade: z.nullable(z.lazy(() => AdjustedTrade$outboundSchema))
        .optional(),
    assetId: z.string().optional(),
    correspondentId: z.string().optional(),
    date: z.nullable(z.lazy(() => DateT$outboundSchema)).optional(),
    fpsl: z.nullable(z.lazy(() => PositionFpsl$outboundSchema)).optional(),
    free: z.nullable(z.lazy(() => Free$outboundSchema)).optional(),
    lastAdjustedDate: z.nullable(z.lazy(() => LastAdjustedDate$outboundSchema))
        .optional(),
    name: z.string().optional(),
    pendingDrip: z.nullable(z.lazy(() => PendingDrip$outboundSchema)).optional(),
    pendingOutgoingAcat: z.nullable(z.lazy(() => PendingOutgoingAcat$outboundSchema)).optional(),
    pendingWithdrawal: z.nullable(z.lazy(() => PendingWithdrawal$outboundSchema))
        .optional(),
    positionVersion: z.string().optional(),
    settled: z.nullable(z.lazy(() => Settled$outboundSchema)).optional(),
    trade: z.nullable(z.lazy(() => PositionTrade$outboundSchema)).optional(),
    unrestricted: z.nullable(z.lazy(() => Unrestricted$outboundSchema))
        .optional(),
}).transform((v) => {
    return remap$(v, {
        accountId: "account_id",
        adjustedSettled: "adjusted_settled",
        adjustedTrade: "adjusted_trade",
        assetId: "asset_id",
        correspondentId: "correspondent_id",
        lastAdjustedDate: "last_adjusted_date",
        pendingDrip: "pending_drip",
        pendingOutgoingAcat: "pending_outgoing_acat",
        pendingWithdrawal: "pending_withdrawal",
        positionVersion: "position_version",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Position$;
(function (Position$) {
    /** @deprecated use `Position$inboundSchema` instead. */
    Position$.inboundSchema = Position$inboundSchema;
    /** @deprecated use `Position$outboundSchema` instead. */
    Position$.outboundSchema = Position$outboundSchema;
})(Position$ || (Position$ = {}));
export function positionToJSON(position) {
    return JSON.stringify(Position$outboundSchema.parse(position));
}
export function positionFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Position$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Position' from JSON`);
}
//# sourceMappingURL=position.js.map