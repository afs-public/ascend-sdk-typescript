"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Execution$ = exports.Execution$outboundSchema = exports.Execution$inboundSchema = exports.ExecutionState$ = exports.ExecutionState$outboundSchema = exports.ExecutionState$inboundSchema = exports.ExecutionQuantity$ = exports.ExecutionQuantity$outboundSchema = exports.ExecutionQuantity$inboundSchema = exports.PriceAdjustment$ = exports.PriceAdjustment$outboundSchema = exports.PriceAdjustment$inboundSchema = exports.ExecutionPriceAdjustmentType$ = exports.ExecutionPriceAdjustmentType$outboundSchema = exports.ExecutionPriceAdjustmentType$inboundSchema = exports.PriceAdjustmentAmount$ = exports.PriceAdjustmentAmount$outboundSchema = exports.PriceAdjustmentAmount$inboundSchema = exports.ExecutionPrice$ = exports.ExecutionPrice$outboundSchema = exports.ExecutionPrice$inboundSchema = exports.ExecutionPrevailingMarketPrice$ = exports.ExecutionPrevailingMarketPrice$outboundSchema = exports.ExecutionPrevailingMarketPrice$inboundSchema = exports.GrossAmount$ = exports.GrossAmount$outboundSchema = exports.GrossAmount$inboundSchema = exports.CommissionAmount$ = exports.CommissionAmount$outboundSchema = exports.CommissionAmount$inboundSchema = exports.ExecutionAccruedInterestAmount$ = exports.ExecutionAccruedInterestAmount$outboundSchema = exports.ExecutionAccruedInterestAmount$inboundSchema = exports.ExecutionState = exports.ExecutionPriceAdjustmentType = void 0;
exports.executionAccruedInterestAmountToJSON = executionAccruedInterestAmountToJSON;
exports.executionAccruedInterestAmountFromJSON = executionAccruedInterestAmountFromJSON;
exports.commissionAmountToJSON = commissionAmountToJSON;
exports.commissionAmountFromJSON = commissionAmountFromJSON;
exports.grossAmountToJSON = grossAmountToJSON;
exports.grossAmountFromJSON = grossAmountFromJSON;
exports.executionPrevailingMarketPriceToJSON = executionPrevailingMarketPriceToJSON;
exports.executionPrevailingMarketPriceFromJSON = executionPrevailingMarketPriceFromJSON;
exports.executionPriceToJSON = executionPriceToJSON;
exports.executionPriceFromJSON = executionPriceFromJSON;
exports.priceAdjustmentAmountToJSON = priceAdjustmentAmountToJSON;
exports.priceAdjustmentAmountFromJSON = priceAdjustmentAmountFromJSON;
exports.priceAdjustmentToJSON = priceAdjustmentToJSON;
exports.priceAdjustmentFromJSON = priceAdjustmentFromJSON;
exports.executionQuantityToJSON = executionQuantityToJSON;
exports.executionQuantityFromJSON = executionQuantityFromJSON;
exports.executionToJSON = executionToJSON;
exports.executionFromJSON = executionFromJSON;
const z = __importStar(require("zod"));
const primitives_js_1 = require("../../lib/primitives.js");
const schemas_js_1 = require("../../lib/schemas.js");
const enums_js_1 = require("../../types/enums.js");
const bondyield_js_1 = require("./bondyield.js");
/**
 * The type of price adjustment being applied by the broker to the net price of the security.
 */
var ExecutionPriceAdjustmentType;
(function (ExecutionPriceAdjustmentType) {
    ExecutionPriceAdjustmentType["PriceAdjustmentTypeUnspecified"] = "PRICE_ADJUSTMENT_TYPE_UNSPECIFIED";
    ExecutionPriceAdjustmentType["Markup"] = "MARKUP";
    ExecutionPriceAdjustmentType["Markdown"] = "MARKDOWN";
    ExecutionPriceAdjustmentType["GrossCredit"] = "GROSS_CREDIT";
})(ExecutionPriceAdjustmentType || (exports.ExecutionPriceAdjustmentType = ExecutionPriceAdjustmentType = {}));
/**
 * The state that the trade is in.
 */
var ExecutionState;
(function (ExecutionState) {
    ExecutionState["StateUnspecified"] = "STATE_UNSPECIFIED";
    ExecutionState["Creating"] = "CREATING";
    ExecutionState["Rebooking"] = "REBOOKING";
    ExecutionState["Canceling"] = "CANCELING";
    ExecutionState["Booked"] = "BOOKED";
    ExecutionState["Rebooked"] = "REBOOKED";
    ExecutionState["Canceled"] = "CANCELED";
    ExecutionState["Failed"] = "FAILED";
})(ExecutionState || (exports.ExecutionState = ExecutionState = {}));
/** @internal */
exports.ExecutionAccruedInterestAmount$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
exports.ExecutionAccruedInterestAmount$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
var ExecutionAccruedInterestAmount$;
(function (ExecutionAccruedInterestAmount$) {
    /** @deprecated use `ExecutionAccruedInterestAmount$inboundSchema` instead. */
    ExecutionAccruedInterestAmount$.inboundSchema = exports.ExecutionAccruedInterestAmount$inboundSchema;
    /** @deprecated use `ExecutionAccruedInterestAmount$outboundSchema` instead. */
    ExecutionAccruedInterestAmount$.outboundSchema = exports.ExecutionAccruedInterestAmount$outboundSchema;
})(ExecutionAccruedInterestAmount$ || (exports.ExecutionAccruedInterestAmount$ = ExecutionAccruedInterestAmount$ = {}));
function executionAccruedInterestAmountToJSON(executionAccruedInterestAmount) {
    return JSON.stringify(exports.ExecutionAccruedInterestAmount$outboundSchema.parse(executionAccruedInterestAmount));
}
function executionAccruedInterestAmountFromJSON(jsonString) {
    return (0, schemas_js_1.safeParse)(jsonString, (x) => exports.ExecutionAccruedInterestAmount$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ExecutionAccruedInterestAmount' from JSON`);
}
/** @internal */
exports.CommissionAmount$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
exports.CommissionAmount$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
var CommissionAmount$;
(function (CommissionAmount$) {
    /** @deprecated use `CommissionAmount$inboundSchema` instead. */
    CommissionAmount$.inboundSchema = exports.CommissionAmount$inboundSchema;
    /** @deprecated use `CommissionAmount$outboundSchema` instead. */
    CommissionAmount$.outboundSchema = exports.CommissionAmount$outboundSchema;
})(CommissionAmount$ || (exports.CommissionAmount$ = CommissionAmount$ = {}));
function commissionAmountToJSON(commissionAmount) {
    return JSON.stringify(exports.CommissionAmount$outboundSchema.parse(commissionAmount));
}
function commissionAmountFromJSON(jsonString) {
    return (0, schemas_js_1.safeParse)(jsonString, (x) => exports.CommissionAmount$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'CommissionAmount' from JSON`);
}
/** @internal */
exports.GrossAmount$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
exports.GrossAmount$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
var GrossAmount$;
(function (GrossAmount$) {
    /** @deprecated use `GrossAmount$inboundSchema` instead. */
    GrossAmount$.inboundSchema = exports.GrossAmount$inboundSchema;
    /** @deprecated use `GrossAmount$outboundSchema` instead. */
    GrossAmount$.outboundSchema = exports.GrossAmount$outboundSchema;
})(GrossAmount$ || (exports.GrossAmount$ = GrossAmount$ = {}));
function grossAmountToJSON(grossAmount) {
    return JSON.stringify(exports.GrossAmount$outboundSchema.parse(grossAmount));
}
function grossAmountFromJSON(jsonString) {
    return (0, schemas_js_1.safeParse)(jsonString, (x) => exports.GrossAmount$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'GrossAmount' from JSON`);
}
/** @internal */
exports.ExecutionPrevailingMarketPrice$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
exports.ExecutionPrevailingMarketPrice$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
var ExecutionPrevailingMarketPrice$;
(function (ExecutionPrevailingMarketPrice$) {
    /** @deprecated use `ExecutionPrevailingMarketPrice$inboundSchema` instead. */
    ExecutionPrevailingMarketPrice$.inboundSchema = exports.ExecutionPrevailingMarketPrice$inboundSchema;
    /** @deprecated use `ExecutionPrevailingMarketPrice$outboundSchema` instead. */
    ExecutionPrevailingMarketPrice$.outboundSchema = exports.ExecutionPrevailingMarketPrice$outboundSchema;
})(ExecutionPrevailingMarketPrice$ || (exports.ExecutionPrevailingMarketPrice$ = ExecutionPrevailingMarketPrice$ = {}));
function executionPrevailingMarketPriceToJSON(executionPrevailingMarketPrice) {
    return JSON.stringify(exports.ExecutionPrevailingMarketPrice$outboundSchema.parse(executionPrevailingMarketPrice));
}
function executionPrevailingMarketPriceFromJSON(jsonString) {
    return (0, schemas_js_1.safeParse)(jsonString, (x) => exports.ExecutionPrevailingMarketPrice$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ExecutionPrevailingMarketPrice' from JSON`);
}
/** @internal */
exports.ExecutionPrice$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
exports.ExecutionPrice$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
var ExecutionPrice$;
(function (ExecutionPrice$) {
    /** @deprecated use `ExecutionPrice$inboundSchema` instead. */
    ExecutionPrice$.inboundSchema = exports.ExecutionPrice$inboundSchema;
    /** @deprecated use `ExecutionPrice$outboundSchema` instead. */
    ExecutionPrice$.outboundSchema = exports.ExecutionPrice$outboundSchema;
})(ExecutionPrice$ || (exports.ExecutionPrice$ = ExecutionPrice$ = {}));
function executionPriceToJSON(executionPrice) {
    return JSON.stringify(exports.ExecutionPrice$outboundSchema.parse(executionPrice));
}
function executionPriceFromJSON(jsonString) {
    return (0, schemas_js_1.safeParse)(jsonString, (x) => exports.ExecutionPrice$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ExecutionPrice' from JSON`);
}
/** @internal */
exports.PriceAdjustmentAmount$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
exports.PriceAdjustmentAmount$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
var PriceAdjustmentAmount$;
(function (PriceAdjustmentAmount$) {
    /** @deprecated use `PriceAdjustmentAmount$inboundSchema` instead. */
    PriceAdjustmentAmount$.inboundSchema = exports.PriceAdjustmentAmount$inboundSchema;
    /** @deprecated use `PriceAdjustmentAmount$outboundSchema` instead. */
    PriceAdjustmentAmount$.outboundSchema = exports.PriceAdjustmentAmount$outboundSchema;
})(PriceAdjustmentAmount$ || (exports.PriceAdjustmentAmount$ = PriceAdjustmentAmount$ = {}));
function priceAdjustmentAmountToJSON(priceAdjustmentAmount) {
    return JSON.stringify(exports.PriceAdjustmentAmount$outboundSchema.parse(priceAdjustmentAmount));
}
function priceAdjustmentAmountFromJSON(jsonString) {
    return (0, schemas_js_1.safeParse)(jsonString, (x) => exports.PriceAdjustmentAmount$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PriceAdjustmentAmount' from JSON`);
}
/** @internal */
exports.ExecutionPriceAdjustmentType$inboundSchema = z
    .union([
    z.nativeEnum(ExecutionPriceAdjustmentType),
    z.string().transform(enums_js_1.catchUnrecognizedEnum),
]);
/** @internal */
exports.ExecutionPriceAdjustmentType$outboundSchema = z.union([
    z.nativeEnum(ExecutionPriceAdjustmentType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
var ExecutionPriceAdjustmentType$;
(function (ExecutionPriceAdjustmentType$) {
    /** @deprecated use `ExecutionPriceAdjustmentType$inboundSchema` instead. */
    ExecutionPriceAdjustmentType$.inboundSchema = exports.ExecutionPriceAdjustmentType$inboundSchema;
    /** @deprecated use `ExecutionPriceAdjustmentType$outboundSchema` instead. */
    ExecutionPriceAdjustmentType$.outboundSchema = exports.ExecutionPriceAdjustmentType$outboundSchema;
})(ExecutionPriceAdjustmentType$ || (exports.ExecutionPriceAdjustmentType$ = ExecutionPriceAdjustmentType$ = {}));
/** @internal */
exports.PriceAdjustment$inboundSchema = z.object({
    price_adjustment_amount: z.nullable(z.lazy(() => exports.PriceAdjustmentAmount$inboundSchema)).optional(),
    price_adjustment_type: exports.ExecutionPriceAdjustmentType$inboundSchema.optional(),
}).transform((v) => {
    return (0, primitives_js_1.remap)(v, {
        "price_adjustment_amount": "priceAdjustmentAmount",
        "price_adjustment_type": "priceAdjustmentType",
    });
});
/** @internal */
exports.PriceAdjustment$outboundSchema = z.object({
    priceAdjustmentAmount: z.nullable(z.lazy(() => exports.PriceAdjustmentAmount$outboundSchema)).optional(),
    priceAdjustmentType: exports.ExecutionPriceAdjustmentType$outboundSchema.optional(),
}).transform((v) => {
    return (0, primitives_js_1.remap)(v, {
        priceAdjustmentAmount: "price_adjustment_amount",
        priceAdjustmentType: "price_adjustment_type",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
var PriceAdjustment$;
(function (PriceAdjustment$) {
    /** @deprecated use `PriceAdjustment$inboundSchema` instead. */
    PriceAdjustment$.inboundSchema = exports.PriceAdjustment$inboundSchema;
    /** @deprecated use `PriceAdjustment$outboundSchema` instead. */
    PriceAdjustment$.outboundSchema = exports.PriceAdjustment$outboundSchema;
})(PriceAdjustment$ || (exports.PriceAdjustment$ = PriceAdjustment$ = {}));
function priceAdjustmentToJSON(priceAdjustment) {
    return JSON.stringify(exports.PriceAdjustment$outboundSchema.parse(priceAdjustment));
}
function priceAdjustmentFromJSON(jsonString) {
    return (0, schemas_js_1.safeParse)(jsonString, (x) => exports.PriceAdjustment$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PriceAdjustment' from JSON`);
}
/** @internal */
exports.ExecutionQuantity$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
exports.ExecutionQuantity$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
var ExecutionQuantity$;
(function (ExecutionQuantity$) {
    /** @deprecated use `ExecutionQuantity$inboundSchema` instead. */
    ExecutionQuantity$.inboundSchema = exports.ExecutionQuantity$inboundSchema;
    /** @deprecated use `ExecutionQuantity$outboundSchema` instead. */
    ExecutionQuantity$.outboundSchema = exports.ExecutionQuantity$outboundSchema;
})(ExecutionQuantity$ || (exports.ExecutionQuantity$ = ExecutionQuantity$ = {}));
function executionQuantityToJSON(executionQuantity) {
    return JSON.stringify(exports.ExecutionQuantity$outboundSchema.parse(executionQuantity));
}
function executionQuantityFromJSON(jsonString) {
    return (0, schemas_js_1.safeParse)(jsonString, (x) => exports.ExecutionQuantity$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ExecutionQuantity' from JSON`);
}
/** @internal */
exports.ExecutionState$inboundSchema = z
    .union([
    z.nativeEnum(ExecutionState),
    z.string().transform(enums_js_1.catchUnrecognizedEnum),
]);
/** @internal */
exports.ExecutionState$outboundSchema = z.union([
    z.nativeEnum(ExecutionState),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
var ExecutionState$;
(function (ExecutionState$) {
    /** @deprecated use `ExecutionState$inboundSchema` instead. */
    ExecutionState$.inboundSchema = exports.ExecutionState$inboundSchema;
    /** @deprecated use `ExecutionState$outboundSchema` instead. */
    ExecutionState$.outboundSchema = exports.ExecutionState$outboundSchema;
})(ExecutionState$ || (exports.ExecutionState$ = ExecutionState$ = {}));
/** @internal */
exports.Execution$inboundSchema = z.object({
    accrued_interest_amount: z.nullable(z.lazy(() => exports.ExecutionAccruedInterestAmount$inboundSchema)).optional(),
    activity_id: z.string().optional(),
    bond_yield: z.array(bondyield_js_1.BondYield$inboundSchema).optional(),
    commission_amount: z.nullable(z.lazy(() => exports.CommissionAmount$inboundSchema))
        .optional(),
    execution_id: z.string().optional(),
    execution_time: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    external_id: z.string().optional(),
    gross_amount: z.nullable(z.lazy(() => exports.GrossAmount$inboundSchema)).optional(),
    memo: z.string().optional(),
    name: z.string().optional(),
    prevailing_market_price: z.nullable(z.lazy(() => exports.ExecutionPrevailingMarketPrice$inboundSchema)).optional(),
    price: z.nullable(z.lazy(() => exports.ExecutionPrice$inboundSchema)).optional(),
    price_adjustment: z.nullable(z.lazy(() => exports.PriceAdjustment$inboundSchema))
        .optional(),
    quantity: z.nullable(z.lazy(() => exports.ExecutionQuantity$inboundSchema))
        .optional(),
    state: exports.ExecutionState$inboundSchema.optional(),
    street_execution_id: z.string().optional(),
    trade_id: z.string().optional(),
}).transform((v) => {
    return (0, primitives_js_1.remap)(v, {
        "accrued_interest_amount": "accruedInterestAmount",
        "activity_id": "activityId",
        "bond_yield": "bondYield",
        "commission_amount": "commissionAmount",
        "execution_id": "executionId",
        "execution_time": "executionTime",
        "external_id": "externalId",
        "gross_amount": "grossAmount",
        "prevailing_market_price": "prevailingMarketPrice",
        "price_adjustment": "priceAdjustment",
        "street_execution_id": "streetExecutionId",
        "trade_id": "tradeId",
    });
});
/** @internal */
exports.Execution$outboundSchema = z.object({
    accruedInterestAmount: z.nullable(z.lazy(() => exports.ExecutionAccruedInterestAmount$outboundSchema)).optional(),
    activityId: z.string().optional(),
    bondYield: z.array(bondyield_js_1.BondYield$outboundSchema).optional(),
    commissionAmount: z.nullable(z.lazy(() => exports.CommissionAmount$outboundSchema))
        .optional(),
    executionId: z.string().optional(),
    executionTime: z.nullable(z.date().transform(v => v.toISOString()))
        .optional(),
    externalId: z.string().optional(),
    grossAmount: z.nullable(z.lazy(() => exports.GrossAmount$outboundSchema)).optional(),
    memo: z.string().optional(),
    name: z.string().optional(),
    prevailingMarketPrice: z.nullable(z.lazy(() => exports.ExecutionPrevailingMarketPrice$outboundSchema)).optional(),
    price: z.nullable(z.lazy(() => exports.ExecutionPrice$outboundSchema)).optional(),
    priceAdjustment: z.nullable(z.lazy(() => exports.PriceAdjustment$outboundSchema))
        .optional(),
    quantity: z.nullable(z.lazy(() => exports.ExecutionQuantity$outboundSchema))
        .optional(),
    state: exports.ExecutionState$outboundSchema.optional(),
    streetExecutionId: z.string().optional(),
    tradeId: z.string().optional(),
}).transform((v) => {
    return (0, primitives_js_1.remap)(v, {
        accruedInterestAmount: "accrued_interest_amount",
        activityId: "activity_id",
        bondYield: "bond_yield",
        commissionAmount: "commission_amount",
        executionId: "execution_id",
        executionTime: "execution_time",
        externalId: "external_id",
        grossAmount: "gross_amount",
        prevailingMarketPrice: "prevailing_market_price",
        priceAdjustment: "price_adjustment",
        streetExecutionId: "street_execution_id",
        tradeId: "trade_id",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
var Execution$;
(function (Execution$) {
    /** @deprecated use `Execution$inboundSchema` instead. */
    Execution$.inboundSchema = exports.Execution$inboundSchema;
    /** @deprecated use `Execution$outboundSchema` instead. */
    Execution$.outboundSchema = exports.Execution$outboundSchema;
})(Execution$ || (exports.Execution$ = Execution$ = {}));
function executionToJSON(execution) {
    return JSON.stringify(exports.Execution$outboundSchema.parse(execution));
}
function executionFromJSON(jsonString) {
    return (0, schemas_js_1.safeParse)(jsonString, (x) => exports.Execution$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Execution' from JSON`);
}
//# sourceMappingURL=execution.js.map