/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { catchUnrecognizedEnum, } from "../../types/enums.js";
import { BondYield$inboundSchema, BondYield$outboundSchema, } from "./bondyield.js";
/**
 * The type of price adjustment being applied by the broker to the net price of the security.
 */
export var ExecutionPriceAdjustmentType;
(function (ExecutionPriceAdjustmentType) {
    ExecutionPriceAdjustmentType["PriceAdjustmentTypeUnspecified"] = "PRICE_ADJUSTMENT_TYPE_UNSPECIFIED";
    ExecutionPriceAdjustmentType["Markup"] = "MARKUP";
    ExecutionPriceAdjustmentType["Markdown"] = "MARKDOWN";
    ExecutionPriceAdjustmentType["GrossCredit"] = "GROSS_CREDIT";
})(ExecutionPriceAdjustmentType || (ExecutionPriceAdjustmentType = {}));
/**
 * The state that the trade is in.
 */
export var ExecutionState;
(function (ExecutionState) {
    ExecutionState["StateUnspecified"] = "STATE_UNSPECIFIED";
    ExecutionState["Creating"] = "CREATING";
    ExecutionState["Rebooking"] = "REBOOKING";
    ExecutionState["Canceling"] = "CANCELING";
    ExecutionState["Booked"] = "BOOKED";
    ExecutionState["Rebooked"] = "REBOOKED";
    ExecutionState["Canceled"] = "CANCELED";
    ExecutionState["Failed"] = "FAILED";
})(ExecutionState || (ExecutionState = {}));
/** @internal */
export const ExecutionAccruedInterestAmount$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const ExecutionAccruedInterestAmount$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ExecutionAccruedInterestAmount$;
(function (ExecutionAccruedInterestAmount$) {
    /** @deprecated use `ExecutionAccruedInterestAmount$inboundSchema` instead. */
    ExecutionAccruedInterestAmount$.inboundSchema = ExecutionAccruedInterestAmount$inboundSchema;
    /** @deprecated use `ExecutionAccruedInterestAmount$outboundSchema` instead. */
    ExecutionAccruedInterestAmount$.outboundSchema = ExecutionAccruedInterestAmount$outboundSchema;
})(ExecutionAccruedInterestAmount$ || (ExecutionAccruedInterestAmount$ = {}));
export function executionAccruedInterestAmountToJSON(executionAccruedInterestAmount) {
    return JSON.stringify(ExecutionAccruedInterestAmount$outboundSchema.parse(executionAccruedInterestAmount));
}
export function executionAccruedInterestAmountFromJSON(jsonString) {
    return safeParse(jsonString, (x) => ExecutionAccruedInterestAmount$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ExecutionAccruedInterestAmount' from JSON`);
}
/** @internal */
export const CommissionAmount$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const CommissionAmount$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var CommissionAmount$;
(function (CommissionAmount$) {
    /** @deprecated use `CommissionAmount$inboundSchema` instead. */
    CommissionAmount$.inboundSchema = CommissionAmount$inboundSchema;
    /** @deprecated use `CommissionAmount$outboundSchema` instead. */
    CommissionAmount$.outboundSchema = CommissionAmount$outboundSchema;
})(CommissionAmount$ || (CommissionAmount$ = {}));
export function commissionAmountToJSON(commissionAmount) {
    return JSON.stringify(CommissionAmount$outboundSchema.parse(commissionAmount));
}
export function commissionAmountFromJSON(jsonString) {
    return safeParse(jsonString, (x) => CommissionAmount$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'CommissionAmount' from JSON`);
}
/** @internal */
export const GrossAmount$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const GrossAmount$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var GrossAmount$;
(function (GrossAmount$) {
    /** @deprecated use `GrossAmount$inboundSchema` instead. */
    GrossAmount$.inboundSchema = GrossAmount$inboundSchema;
    /** @deprecated use `GrossAmount$outboundSchema` instead. */
    GrossAmount$.outboundSchema = GrossAmount$outboundSchema;
})(GrossAmount$ || (GrossAmount$ = {}));
export function grossAmountToJSON(grossAmount) {
    return JSON.stringify(GrossAmount$outboundSchema.parse(grossAmount));
}
export function grossAmountFromJSON(jsonString) {
    return safeParse(jsonString, (x) => GrossAmount$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'GrossAmount' from JSON`);
}
/** @internal */
export const ExecutionPrevailingMarketPrice$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const ExecutionPrevailingMarketPrice$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ExecutionPrevailingMarketPrice$;
(function (ExecutionPrevailingMarketPrice$) {
    /** @deprecated use `ExecutionPrevailingMarketPrice$inboundSchema` instead. */
    ExecutionPrevailingMarketPrice$.inboundSchema = ExecutionPrevailingMarketPrice$inboundSchema;
    /** @deprecated use `ExecutionPrevailingMarketPrice$outboundSchema` instead. */
    ExecutionPrevailingMarketPrice$.outboundSchema = ExecutionPrevailingMarketPrice$outboundSchema;
})(ExecutionPrevailingMarketPrice$ || (ExecutionPrevailingMarketPrice$ = {}));
export function executionPrevailingMarketPriceToJSON(executionPrevailingMarketPrice) {
    return JSON.stringify(ExecutionPrevailingMarketPrice$outboundSchema.parse(executionPrevailingMarketPrice));
}
export function executionPrevailingMarketPriceFromJSON(jsonString) {
    return safeParse(jsonString, (x) => ExecutionPrevailingMarketPrice$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ExecutionPrevailingMarketPrice' from JSON`);
}
/** @internal */
export const ExecutionPrice$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const ExecutionPrice$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ExecutionPrice$;
(function (ExecutionPrice$) {
    /** @deprecated use `ExecutionPrice$inboundSchema` instead. */
    ExecutionPrice$.inboundSchema = ExecutionPrice$inboundSchema;
    /** @deprecated use `ExecutionPrice$outboundSchema` instead. */
    ExecutionPrice$.outboundSchema = ExecutionPrice$outboundSchema;
})(ExecutionPrice$ || (ExecutionPrice$ = {}));
export function executionPriceToJSON(executionPrice) {
    return JSON.stringify(ExecutionPrice$outboundSchema.parse(executionPrice));
}
export function executionPriceFromJSON(jsonString) {
    return safeParse(jsonString, (x) => ExecutionPrice$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ExecutionPrice' from JSON`);
}
/** @internal */
export const PriceAdjustmentAmount$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const PriceAdjustmentAmount$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var PriceAdjustmentAmount$;
(function (PriceAdjustmentAmount$) {
    /** @deprecated use `PriceAdjustmentAmount$inboundSchema` instead. */
    PriceAdjustmentAmount$.inboundSchema = PriceAdjustmentAmount$inboundSchema;
    /** @deprecated use `PriceAdjustmentAmount$outboundSchema` instead. */
    PriceAdjustmentAmount$.outboundSchema = PriceAdjustmentAmount$outboundSchema;
})(PriceAdjustmentAmount$ || (PriceAdjustmentAmount$ = {}));
export function priceAdjustmentAmountToJSON(priceAdjustmentAmount) {
    return JSON.stringify(PriceAdjustmentAmount$outboundSchema.parse(priceAdjustmentAmount));
}
export function priceAdjustmentAmountFromJSON(jsonString) {
    return safeParse(jsonString, (x) => PriceAdjustmentAmount$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PriceAdjustmentAmount' from JSON`);
}
/** @internal */
export const ExecutionPriceAdjustmentType$inboundSchema = z
    .union([
    z.nativeEnum(ExecutionPriceAdjustmentType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const ExecutionPriceAdjustmentType$outboundSchema = z.union([
    z.nativeEnum(ExecutionPriceAdjustmentType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ExecutionPriceAdjustmentType$;
(function (ExecutionPriceAdjustmentType$) {
    /** @deprecated use `ExecutionPriceAdjustmentType$inboundSchema` instead. */
    ExecutionPriceAdjustmentType$.inboundSchema = ExecutionPriceAdjustmentType$inboundSchema;
    /** @deprecated use `ExecutionPriceAdjustmentType$outboundSchema` instead. */
    ExecutionPriceAdjustmentType$.outboundSchema = ExecutionPriceAdjustmentType$outboundSchema;
})(ExecutionPriceAdjustmentType$ || (ExecutionPriceAdjustmentType$ = {}));
/** @internal */
export const PriceAdjustment$inboundSchema = z.object({
    price_adjustment_amount: z.nullable(z.lazy(() => PriceAdjustmentAmount$inboundSchema)).optional(),
    price_adjustment_type: ExecutionPriceAdjustmentType$inboundSchema.optional(),
}).transform((v) => {
    return remap$(v, {
        "price_adjustment_amount": "priceAdjustmentAmount",
        "price_adjustment_type": "priceAdjustmentType",
    });
});
/** @internal */
export const PriceAdjustment$outboundSchema = z.object({
    priceAdjustmentAmount: z.nullable(z.lazy(() => PriceAdjustmentAmount$outboundSchema)).optional(),
    priceAdjustmentType: ExecutionPriceAdjustmentType$outboundSchema.optional(),
}).transform((v) => {
    return remap$(v, {
        priceAdjustmentAmount: "price_adjustment_amount",
        priceAdjustmentType: "price_adjustment_type",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var PriceAdjustment$;
(function (PriceAdjustment$) {
    /** @deprecated use `PriceAdjustment$inboundSchema` instead. */
    PriceAdjustment$.inboundSchema = PriceAdjustment$inboundSchema;
    /** @deprecated use `PriceAdjustment$outboundSchema` instead. */
    PriceAdjustment$.outboundSchema = PriceAdjustment$outboundSchema;
})(PriceAdjustment$ || (PriceAdjustment$ = {}));
export function priceAdjustmentToJSON(priceAdjustment) {
    return JSON.stringify(PriceAdjustment$outboundSchema.parse(priceAdjustment));
}
export function priceAdjustmentFromJSON(jsonString) {
    return safeParse(jsonString, (x) => PriceAdjustment$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PriceAdjustment' from JSON`);
}
/** @internal */
export const ExecutionQuantity$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const ExecutionQuantity$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ExecutionQuantity$;
(function (ExecutionQuantity$) {
    /** @deprecated use `ExecutionQuantity$inboundSchema` instead. */
    ExecutionQuantity$.inboundSchema = ExecutionQuantity$inboundSchema;
    /** @deprecated use `ExecutionQuantity$outboundSchema` instead. */
    ExecutionQuantity$.outboundSchema = ExecutionQuantity$outboundSchema;
})(ExecutionQuantity$ || (ExecutionQuantity$ = {}));
export function executionQuantityToJSON(executionQuantity) {
    return JSON.stringify(ExecutionQuantity$outboundSchema.parse(executionQuantity));
}
export function executionQuantityFromJSON(jsonString) {
    return safeParse(jsonString, (x) => ExecutionQuantity$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ExecutionQuantity' from JSON`);
}
/** @internal */
export const ExecutionState$inboundSchema = z
    .union([
    z.nativeEnum(ExecutionState),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const ExecutionState$outboundSchema = z.union([
    z.nativeEnum(ExecutionState),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ExecutionState$;
(function (ExecutionState$) {
    /** @deprecated use `ExecutionState$inboundSchema` instead. */
    ExecutionState$.inboundSchema = ExecutionState$inboundSchema;
    /** @deprecated use `ExecutionState$outboundSchema` instead. */
    ExecutionState$.outboundSchema = ExecutionState$outboundSchema;
})(ExecutionState$ || (ExecutionState$ = {}));
/** @internal */
export const Execution$inboundSchema = z.object({
    accrued_interest_amount: z.nullable(z.lazy(() => ExecutionAccruedInterestAmount$inboundSchema)).optional(),
    activity_id: z.string().optional(),
    bond_yield: z.array(BondYield$inboundSchema).optional(),
    commission_amount: z.nullable(z.lazy(() => CommissionAmount$inboundSchema))
        .optional(),
    execution_id: z.string().optional(),
    execution_time: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    external_id: z.string().optional(),
    gross_amount: z.nullable(z.lazy(() => GrossAmount$inboundSchema)).optional(),
    memo: z.string().optional(),
    name: z.string().optional(),
    prevailing_market_price: z.nullable(z.lazy(() => ExecutionPrevailingMarketPrice$inboundSchema)).optional(),
    price: z.nullable(z.lazy(() => ExecutionPrice$inboundSchema)).optional(),
    price_adjustment: z.nullable(z.lazy(() => PriceAdjustment$inboundSchema))
        .optional(),
    quantity: z.nullable(z.lazy(() => ExecutionQuantity$inboundSchema))
        .optional(),
    state: ExecutionState$inboundSchema.optional(),
    street_execution_id: z.string().optional(),
    trade_id: z.string().optional(),
}).transform((v) => {
    return remap$(v, {
        "accrued_interest_amount": "accruedInterestAmount",
        "activity_id": "activityId",
        "bond_yield": "bondYield",
        "commission_amount": "commissionAmount",
        "execution_id": "executionId",
        "execution_time": "executionTime",
        "external_id": "externalId",
        "gross_amount": "grossAmount",
        "prevailing_market_price": "prevailingMarketPrice",
        "price_adjustment": "priceAdjustment",
        "street_execution_id": "streetExecutionId",
        "trade_id": "tradeId",
    });
});
/** @internal */
export const Execution$outboundSchema = z.object({
    accruedInterestAmount: z.nullable(z.lazy(() => ExecutionAccruedInterestAmount$outboundSchema)).optional(),
    activityId: z.string().optional(),
    bondYield: z.array(BondYield$outboundSchema).optional(),
    commissionAmount: z.nullable(z.lazy(() => CommissionAmount$outboundSchema))
        .optional(),
    executionId: z.string().optional(),
    executionTime: z.nullable(z.date().transform(v => v.toISOString()))
        .optional(),
    externalId: z.string().optional(),
    grossAmount: z.nullable(z.lazy(() => GrossAmount$outboundSchema)).optional(),
    memo: z.string().optional(),
    name: z.string().optional(),
    prevailingMarketPrice: z.nullable(z.lazy(() => ExecutionPrevailingMarketPrice$outboundSchema)).optional(),
    price: z.nullable(z.lazy(() => ExecutionPrice$outboundSchema)).optional(),
    priceAdjustment: z.nullable(z.lazy(() => PriceAdjustment$outboundSchema))
        .optional(),
    quantity: z.nullable(z.lazy(() => ExecutionQuantity$outboundSchema))
        .optional(),
    state: ExecutionState$outboundSchema.optional(),
    streetExecutionId: z.string().optional(),
    tradeId: z.string().optional(),
}).transform((v) => {
    return remap$(v, {
        accruedInterestAmount: "accrued_interest_amount",
        activityId: "activity_id",
        bondYield: "bond_yield",
        commissionAmount: "commission_amount",
        executionId: "execution_id",
        executionTime: "execution_time",
        externalId: "external_id",
        grossAmount: "gross_amount",
        prevailingMarketPrice: "prevailing_market_price",
        priceAdjustment: "price_adjustment",
        streetExecutionId: "street_execution_id",
        tradeId: "trade_id",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Execution$;
(function (Execution$) {
    /** @deprecated use `Execution$inboundSchema` instead. */
    Execution$.inboundSchema = Execution$inboundSchema;
    /** @deprecated use `Execution$outboundSchema` instead. */
    Execution$.outboundSchema = Execution$outboundSchema;
})(Execution$ || (Execution$ = {}));
export function executionToJSON(execution) {
    return JSON.stringify(Execution$outboundSchema.parse(execution));
}
export function executionFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Execution$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Execution' from JSON`);
}
//# sourceMappingURL=execution.js.map