/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { catchUnrecognizedEnum, } from "../../types/enums.js";
import { TradingExecutedPrice$inboundSchema, TradingExecutedPrice$outboundSchema, } from "./tradingexecutedprice.js";
import { TradingExecutions$inboundSchema, TradingExecutions$outboundSchema, } from "./tradingexecutions.js";
import { TradingFee$inboundSchema, TradingFee$outboundSchema, } from "./tradingfee.js";
/**
 * The type of the asset in this order, which must be one of the following:
 *
 * @remarks
 *  EQUITY, MUTUAL_FUND, and FIXED_INCOME.
 */
export var OrderAssetType;
(function (OrderAssetType) {
    OrderAssetType["Equity"] = "EQUITY";
    OrderAssetType["FixedIncome"] = "FIXED_INCOME";
    OrderAssetType["MutualFund"] = "MUTUAL_FUND";
})(OrderAssetType || (OrderAssetType = {}));
/**
 * Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
 */
export var OrderBrokerCapacity;
(function (OrderBrokerCapacity) {
    OrderBrokerCapacity["BrokerCapacityUnspecified"] = "BROKER_CAPACITY_UNSPECIFIED";
    OrderBrokerCapacity["Agency"] = "AGENCY";
    OrderBrokerCapacity["Principal"] = "PRINCIPAL";
})(OrderBrokerCapacity || (OrderBrokerCapacity = {}));
/**
 * Output only field that is required for Equity Orders for any client who is having Apex do CAT reporting on their behalf. This field denotes the initiator of the cancel request. This field will be present when provided on the CancelOrderRequest
 */
export var CancelInitiator;
(function (CancelInitiator) {
    CancelInitiator["InitiatorUnspecified"] = "INITIATOR_UNSPECIFIED";
    CancelInitiator["Firm"] = "FIRM";
    CancelInitiator["Client"] = "CLIENT";
})(CancelInitiator || (CancelInitiator = {}));
/**
 * Used to denote when a cancel request has been rejected.
 */
export var CancelRejectedReason;
(function (CancelRejectedReason) {
    CancelRejectedReason["CancelRejectReasonUnspecified"] = "CANCEL_REJECT_REASON_UNSPECIFIED";
    CancelRejectedReason["TooLateToCancel"] = "TOO_LATE_TO_CANCEL";
    CancelRejectedReason["CancellationUnknownOrder"] = "CANCELLATION_UNKNOWN_ORDER";
    CancelRejectedReason["BrokerExchangeOption"] = "BROKER_EXCHANGE_OPTION";
    CancelRejectedReason["OrderAlreadyInPendingCancelOrPendingReplaceStatus"] = "ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS";
    CancelRejectedReason["Duplicate"] = "DUPLICATE";
    CancelRejectedReason["CancellationSystemError"] = "CANCELLATION_SYSTEM_ERROR";
    CancelRejectedReason["OrderAlreadyCanceled"] = "ORDER_ALREADY_CANCELED";
    CancelRejectedReason["CancellationMisconfiguredClient"] = "CANCELLATION_MISCONFIGURED_CLIENT";
})(CancelRejectedReason || (CancelRejectedReason = {}));
/**
 * The type of commission value being specified. Only the type of "AMOUNT" is supported.
 */
export var OrderCommissionType;
(function (OrderCommissionType) {
    OrderCommissionType["CommissionTypeUnspecified"] = "COMMISSION_TYPE_UNSPECIFIED";
    OrderCommissionType["Amount"] = "AMOUNT";
})(OrderCommissionType || (OrderCommissionType = {}));
/**
 * The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
 */
export var OrderIdentifierType;
(function (OrderIdentifierType) {
    OrderIdentifierType["Symbol"] = "SYMBOL";
    OrderIdentifierType["Cusip"] = "CUSIP";
    OrderIdentifierType["Isin"] = "ISIN";
})(OrderIdentifierType || (OrderIdentifierType = {}));
/**
 * The type of this price, which must be PRICE_PER_UNIT for equity orders, or PERCENTAGE_OF_PAR for fixed income orders.
 */
export var OrderLimitPriceType;
(function (OrderLimitPriceType) {
    OrderLimitPriceType["LimitPriceTypeUnspecified"] = "LIMIT_PRICE_TYPE_UNSPECIFIED";
    OrderLimitPriceType["PricePerUnit"] = "PRICE_PER_UNIT";
    OrderLimitPriceType["PercentageOfPar"] = "PERCENTAGE_OF_PAR";
})(OrderLimitPriceType || (OrderLimitPriceType = {}));
/**
 * When an order has the REJECTED status, this will be populated with a system code describing the rejection.
 */
export var OrderRejectedReason;
(function (OrderRejectedReason) {
    OrderRejectedReason["OrderRejectReasonUnspecified"] = "ORDER_REJECT_REASON_UNSPECIFIED";
    OrderRejectedReason["BrokerOption"] = "BROKER_OPTION";
    OrderRejectedReason["UnknownSecurity"] = "UNKNOWN_SECURITY";
    OrderRejectedReason["ExchangeClosed"] = "EXCHANGE_CLOSED";
    OrderRejectedReason["OrderExceedsLimit"] = "ORDER_EXCEEDS_LIMIT";
    OrderRejectedReason["TooLateToEnter"] = "TOO_LATE_TO_ENTER";
    OrderRejectedReason["UnknownOrder"] = "UNKNOWN_ORDER";
    OrderRejectedReason["DuplicateOrder"] = "DUPLICATE_ORDER";
    OrderRejectedReason["StaleOrder"] = "STALE_ORDER";
    OrderRejectedReason["BelowNotionalMinimum"] = "BELOW_NOTIONAL_MINIMUM";
    OrderRejectedReason["OrderDateUnavailable"] = "ORDER_DATE_UNAVAILABLE";
    OrderRejectedReason["AggressiveLimitPrice"] = "AGGRESSIVE_LIMIT_PRICE";
    OrderRejectedReason["AccountNotEntitled"] = "ACCOUNT_NOT_ENTITLED";
    OrderRejectedReason["SystemError"] = "SYSTEM_ERROR";
    OrderRejectedReason["BlockingCorporateAction"] = "BLOCKING_CORPORATE_ACTION";
    OrderRejectedReason["UnavailablePriceQuote"] = "UNAVAILABLE_PRICE_QUOTE";
    OrderRejectedReason["ExecutionMisconfiguredClient"] = "EXECUTION_MISCONFIGURED_CLIENT";
    OrderRejectedReason["NotionalQuantityNotAllowedForSecurity"] = "NOTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY";
    OrderRejectedReason["FractionalQuantityNotAllowedForSecurity"] = "FRACTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY";
    OrderRejectedReason["OnlyFractionalSellOrWholeOrdersAllowedForSecurity"] = "ONLY_FRACTIONAL_SELL_OR_WHOLE_ORDERS_ALLOWED_FOR_SECURITY";
    OrderRejectedReason["SymbolNotTradeable"] = "SYMBOL_NOT_TRADEABLE";
    OrderRejectedReason["AboveNotionalMaximum"] = "ABOVE_NOTIONAL_MAXIMUM";
    OrderRejectedReason["AboveShareMaximum"] = "ABOVE_SHARE_MAXIMUM";
    OrderRejectedReason["FailedBuyingPower"] = "FAILED_BUYING_POWER";
    OrderRejectedReason["InsufficientPosition"] = "INSUFFICIENT_POSITION";
    OrderRejectedReason["MaxSellQuantityRequired"] = "MAX_SELL_QUANTITY_REQUIRED";
    OrderRejectedReason["MaxSellQuantityProhibited"] = "MAX_SELL_QUANTITY_PROHIBITED";
    OrderRejectedReason["StopPriceExceedsMarketPrice"] = "STOP_PRICE_EXCEEDS_MARKET_PRICE";
    OrderRejectedReason["TradesDisabledForAssetType"] = "TRADES_DISABLED_FOR_ASSET_TYPE";
    OrderRejectedReason["CommissionNotAllowedForNonBrokerDealer"] = "COMMISSION_NOT_ALLOWED_FOR_NON_BROKER_DEALER";
    OrderRejectedReason["AssetNotSetUpToTrade"] = "ASSET_NOT_SET_UP_TO_TRADE";
    OrderRejectedReason["InvalidOrderQuantity"] = "INVALID_ORDER_QUANTITY";
    OrderRejectedReason["ClientReceivedTimeRequired"] = "CLIENT_RECEIVED_TIME_REQUIRED";
    OrderRejectedReason["ClientNotPermittedToUseTradingSession"] = "CLIENT_NOT_PERMITTED_TO_USE_TRADING_SESSION";
    OrderRejectedReason["RoundUpAmountTooSmall"] = "ROUND_UP_AMOUNT_TOO_SMALL";
    OrderRejectedReason["AssetNotSetUpForRoundUps"] = "ASSET_NOT_SET_UP_FOR_ROUND_UPS";
    OrderRejectedReason["BelowRoundUpMinimum"] = "BELOW_ROUND_UP_MINIMUM";
    OrderRejectedReason["StopPriceBelowMarketPrice"] = "STOP_PRICE_BELOW_MARKET_PRICE";
})(OrderRejectedReason || (OrderRejectedReason = {}));
/**
 * The processing status of the order
 */
export var OrderStatus;
(function (OrderStatus) {
    OrderStatus["OrderStatusUnspecified"] = "ORDER_STATUS_UNSPECIFIED";
    OrderStatus["PendingNew"] = "PENDING_NEW";
    OrderStatus["New"] = "NEW";
    OrderStatus["PendingQueued"] = "PENDING_QUEUED";
    OrderStatus["Queued"] = "QUEUED";
    OrderStatus["PartiallyFilled"] = "PARTIALLY_FILLED";
    OrderStatus["Filled"] = "FILLED";
    OrderStatus["PendingCancel"] = "PENDING_CANCEL";
    OrderStatus["Canceled"] = "CANCELED";
    OrderStatus["Rejected"] = "REJECTED";
})(OrderStatus || (OrderStatus = {}));
/**
 * The execution type of this order. For Equities: MARKET, LIMIT, STOP and MARKET_IF_TOUCHED are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
 */
export var OrderOrderType;
(function (OrderOrderType) {
    OrderOrderType["Limit"] = "LIMIT";
    OrderOrderType["Market"] = "MARKET";
    OrderOrderType["Stop"] = "STOP";
    OrderOrderType["MarketIfTouched"] = "MARKET_IF_TOUCHED";
})(OrderOrderType || (OrderOrderType = {}));
/**
 * The side of this order.
 */
export var OrderSide;
(function (OrderSide) {
    OrderSide["SideUnspecified"] = "SIDE_UNSPECIFIED";
    OrderSide["Buy"] = "BUY";
    OrderSide["Sell"] = "SELL";
})(OrderSide || (OrderSide = {}));
export var OrderSpecialReportingInstructions;
(function (OrderSpecialReportingInstructions) {
    OrderSpecialReportingInstructions["SpecialReportingInstructionsUnspecified"] = "SPECIAL_REPORTING_INSTRUCTIONS_UNSPECIFIED";
    OrderSpecialReportingInstructions["CustomerDirected"] = "CUSTOMER_DIRECTED";
    OrderSpecialReportingInstructions["WithDividend"] = "WITH_DIVIDEND";
    OrderSpecialReportingInstructions["WithRights"] = "WITH_RIGHTS";
    OrderSpecialReportingInstructions["DiscretionExercised"] = "DISCRETION_EXERCISED";
    OrderSpecialReportingInstructions["DiscretionNotExercised"] = "DISCRETION_NOT_EXERCISED";
    OrderSpecialReportingInstructions["BrokerDealerOrder"] = "BROKER_DEALER_ORDER";
    OrderSpecialReportingInstructions["FullyRegistered"] = "FULLY_REGISTERED";
    OrderSpecialReportingInstructions["OddlotDiffOnRequest"] = "ODDLOT_DIFF_ON_REQUEST";
    OrderSpecialReportingInstructions["ProspectusEnclosed"] = "PROSPECTUS_ENCLOSED";
    OrderSpecialReportingInstructions["ProspectusSeparateMail"] = "PROSPECTUS_SEPARATE_MAIL";
    OrderSpecialReportingInstructions["Solicited"] = "SOLICITED";
    OrderSpecialReportingInstructions["Unsolicited"] = "UNSOLICITED";
    OrderSpecialReportingInstructions["XDividend"] = "X_DIVIDEND";
    OrderSpecialReportingInstructions["ActingAsPrincipal"] = "ACTING_AS_PRINCIPAL";
    OrderSpecialReportingInstructions["AveragePrice"] = "AVERAGE_PRICE";
    OrderSpecialReportingInstructions["BrokerLiquidation"] = "BROKER_LIQUIDATION";
    OrderSpecialReportingInstructions["InternetOrder"] = "INTERNET_ORDER";
    OrderSpecialReportingInstructions["MarginSellout"] = "MARGIN_SELLOUT";
    OrderSpecialReportingInstructions["NegativeNetProceed"] = "NEGATIVE_NET_PROCEED";
    OrderSpecialReportingInstructions["RisklessPrincipal"] = "RISKLESS_PRINCIPAL";
    OrderSpecialReportingInstructions["ThirdMarket"] = "THIRD_MARKET";
    OrderSpecialReportingInstructions["SuppressTraceReporting"] = "SUPPRESS_TRACE_REPORTING";
    OrderSpecialReportingInstructions["WhenDistributed"] = "WHEN_DISTRIBUTED";
    OrderSpecialReportingInstructions["RoundUp"] = "ROUND_UP";
})(OrderSpecialReportingInstructions || (OrderSpecialReportingInstructions = {}));
/**
 * The type of this price, which must PRICE_PER_UNIT for equity orders. (Fixed income and mutual fund assets do not support stop orders.)
 */
export var OrderStopPriceType;
(function (OrderStopPriceType) {
    OrderStopPriceType["StopPriceTypeUnspecified"] = "STOP_PRICE_TYPE_UNSPECIFIED";
    OrderStopPriceType["PricePerUnit"] = "PRICE_PER_UNIT";
})(OrderStopPriceType || (OrderStopPriceType = {}));
/**
 * Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
 */
export var OrderTimeInForce;
(function (OrderTimeInForce) {
    OrderTimeInForce["Day"] = "DAY";
    OrderTimeInForce["GoodTillDate"] = "GOOD_TILL_DATE";
})(OrderTimeInForce || (OrderTimeInForce = {}));
/**
 * Which TradingSession to trade in, defaults to 'CORE'. Only available for Equity orders.
 */
export var OrderTradingSession;
(function (OrderTradingSession) {
    OrderTradingSession["TradingSessionUnspecified"] = "TRADING_SESSION_UNSPECIFIED";
    OrderTradingSession["Core"] = "CORE";
    OrderTradingSession["Pre"] = "PRE";
    OrderTradingSession["Post"] = "POST";
    OrderTradingSession["Overnight"] = "OVERNIGHT";
    OrderTradingSession["Apex24"] = "APEX24";
    OrderTradingSession["Gtx"] = "GTX";
})(OrderTradingSession || (OrderTradingSession = {}));
/** @internal */
export const OrderAssetType$inboundSchema = z
    .union([
    z.nativeEnum(OrderAssetType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderAssetType$outboundSchema = z.union([
    z.nativeEnum(OrderAssetType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderAssetType$;
(function (OrderAssetType$) {
    /** @deprecated use `OrderAssetType$inboundSchema` instead. */
    OrderAssetType$.inboundSchema = OrderAssetType$inboundSchema;
    /** @deprecated use `OrderAssetType$outboundSchema` instead. */
    OrderAssetType$.outboundSchema = OrderAssetType$outboundSchema;
})(OrderAssetType$ || (OrderAssetType$ = {}));
/** @internal */
export const OrderBrokerCapacity$inboundSchema = z
    .union([
    z.nativeEnum(OrderBrokerCapacity),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderBrokerCapacity$outboundSchema = z.union([
    z.nativeEnum(OrderBrokerCapacity),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderBrokerCapacity$;
(function (OrderBrokerCapacity$) {
    /** @deprecated use `OrderBrokerCapacity$inboundSchema` instead. */
    OrderBrokerCapacity$.inboundSchema = OrderBrokerCapacity$inboundSchema;
    /** @deprecated use `OrderBrokerCapacity$outboundSchema` instead. */
    OrderBrokerCapacity$.outboundSchema = OrderBrokerCapacity$outboundSchema;
})(OrderBrokerCapacity$ || (OrderBrokerCapacity$ = {}));
/** @internal */
export const CancelInitiator$inboundSchema = z
    .union([
    z.nativeEnum(CancelInitiator),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const CancelInitiator$outboundSchema = z.union([
    z.nativeEnum(CancelInitiator),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var CancelInitiator$;
(function (CancelInitiator$) {
    /** @deprecated use `CancelInitiator$inboundSchema` instead. */
    CancelInitiator$.inboundSchema = CancelInitiator$inboundSchema;
    /** @deprecated use `CancelInitiator$outboundSchema` instead. */
    CancelInitiator$.outboundSchema = CancelInitiator$outboundSchema;
})(CancelInitiator$ || (CancelInitiator$ = {}));
/** @internal */
export const CancelRejectedReason$inboundSchema = z
    .union([
    z.nativeEnum(CancelRejectedReason),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const CancelRejectedReason$outboundSchema = z.union([
    z.nativeEnum(CancelRejectedReason),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var CancelRejectedReason$;
(function (CancelRejectedReason$) {
    /** @deprecated use `CancelRejectedReason$inboundSchema` instead. */
    CancelRejectedReason$.inboundSchema = CancelRejectedReason$inboundSchema;
    /** @deprecated use `CancelRejectedReason$outboundSchema` instead. */
    CancelRejectedReason$.outboundSchema = CancelRejectedReason$outboundSchema;
})(CancelRejectedReason$ || (CancelRejectedReason$ = {}));
/** @internal */
export const OrderCommissionType$inboundSchema = z
    .union([
    z.nativeEnum(OrderCommissionType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderCommissionType$outboundSchema = z.union([
    z.nativeEnum(OrderCommissionType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderCommissionType$;
(function (OrderCommissionType$) {
    /** @deprecated use `OrderCommissionType$inboundSchema` instead. */
    OrderCommissionType$.inboundSchema = OrderCommissionType$inboundSchema;
    /** @deprecated use `OrderCommissionType$outboundSchema` instead. */
    OrderCommissionType$.outboundSchema = OrderCommissionType$outboundSchema;
})(OrderCommissionType$ || (OrderCommissionType$ = {}));
/** @internal */
export const Value$inboundSchema = z
    .object({
    value: z.string().optional(),
});
/** @internal */
export const Value$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Value$;
(function (Value$) {
    /** @deprecated use `Value$inboundSchema` instead. */
    Value$.inboundSchema = Value$inboundSchema;
    /** @deprecated use `Value$outboundSchema` instead. */
    Value$.outboundSchema = Value$outboundSchema;
})(Value$ || (Value$ = {}));
export function valueToJSON(value) {
    return JSON.stringify(Value$outboundSchema.parse(value));
}
export function valueFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Value$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Value' from JSON`);
}
/** @internal */
export const OrderCommission$inboundSchema = z.object({
    type: OrderCommissionType$inboundSchema.optional(),
    value: z.nullable(z.lazy(() => Value$inboundSchema)).optional(),
});
/** @internal */
export const OrderCommission$outboundSchema = z.object({
    type: OrderCommissionType$outboundSchema.optional(),
    value: z.nullable(z.lazy(() => Value$outboundSchema)).optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderCommission$;
(function (OrderCommission$) {
    /** @deprecated use `OrderCommission$inboundSchema` instead. */
    OrderCommission$.inboundSchema = OrderCommission$inboundSchema;
    /** @deprecated use `OrderCommission$outboundSchema` instead. */
    OrderCommission$.outboundSchema = OrderCommission$outboundSchema;
})(OrderCommission$ || (OrderCommission$ = {}));
export function orderCommissionToJSON(orderCommission) {
    return JSON.stringify(OrderCommission$outboundSchema.parse(orderCommission));
}
export function orderCommissionFromJSON(jsonString) {
    return safeParse(jsonString, (x) => OrderCommission$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'OrderCommission' from JSON`);
}
/** @internal */
export const CumulativeNotionalValue$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const CumulativeNotionalValue$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var CumulativeNotionalValue$;
(function (CumulativeNotionalValue$) {
    /** @deprecated use `CumulativeNotionalValue$inboundSchema` instead. */
    CumulativeNotionalValue$.inboundSchema = CumulativeNotionalValue$inboundSchema;
    /** @deprecated use `CumulativeNotionalValue$outboundSchema` instead. */
    CumulativeNotionalValue$.outboundSchema = CumulativeNotionalValue$outboundSchema;
})(CumulativeNotionalValue$ || (CumulativeNotionalValue$ = {}));
export function cumulativeNotionalValueToJSON(cumulativeNotionalValue) {
    return JSON.stringify(CumulativeNotionalValue$outboundSchema.parse(cumulativeNotionalValue));
}
export function cumulativeNotionalValueFromJSON(jsonString) {
    return safeParse(jsonString, (x) => CumulativeNotionalValue$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'CumulativeNotionalValue' from JSON`);
}
/** @internal */
export const ExtraReportingData$inboundSchema = z.object({
    cancel_confirmed_time: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
}).transform((v) => {
    return remap$(v, {
        "cancel_confirmed_time": "cancelConfirmedTime",
    });
});
/** @internal */
export const ExtraReportingData$outboundSchema = z.object({
    cancelConfirmedTime: z.nullable(z.date().transform(v => v.toISOString()))
        .optional(),
}).transform((v) => {
    return remap$(v, {
        cancelConfirmedTime: "cancel_confirmed_time",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ExtraReportingData$;
(function (ExtraReportingData$) {
    /** @deprecated use `ExtraReportingData$inboundSchema` instead. */
    ExtraReportingData$.inboundSchema = ExtraReportingData$inboundSchema;
    /** @deprecated use `ExtraReportingData$outboundSchema` instead. */
    ExtraReportingData$.outboundSchema = ExtraReportingData$outboundSchema;
})(ExtraReportingData$ || (ExtraReportingData$ = {}));
export function extraReportingDataToJSON(extraReportingData) {
    return JSON.stringify(ExtraReportingData$outboundSchema.parse(extraReportingData));
}
export function extraReportingDataFromJSON(jsonString) {
    return safeParse(jsonString, (x) => ExtraReportingData$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ExtraReportingData' from JSON`);
}
/** @internal */
export const FilledQuantity$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const FilledQuantity$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var FilledQuantity$;
(function (FilledQuantity$) {
    /** @deprecated use `FilledQuantity$inboundSchema` instead. */
    FilledQuantity$.inboundSchema = FilledQuantity$inboundSchema;
    /** @deprecated use `FilledQuantity$outboundSchema` instead. */
    FilledQuantity$.outboundSchema = FilledQuantity$outboundSchema;
})(FilledQuantity$ || (FilledQuantity$ = {}));
export function filledQuantityToJSON(filledQuantity) {
    return JSON.stringify(FilledQuantity$outboundSchema.parse(filledQuantity));
}
export function filledQuantityFromJSON(jsonString) {
    return safeParse(jsonString, (x) => FilledQuantity$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'FilledQuantity' from JSON`);
}
/** @internal */
export const OrderIdentifierType$inboundSchema = z
    .union([
    z.nativeEnum(OrderIdentifierType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderIdentifierType$outboundSchema = z.union([
    z.nativeEnum(OrderIdentifierType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderIdentifierType$;
(function (OrderIdentifierType$) {
    /** @deprecated use `OrderIdentifierType$inboundSchema` instead. */
    OrderIdentifierType$.inboundSchema = OrderIdentifierType$inboundSchema;
    /** @deprecated use `OrderIdentifierType$outboundSchema` instead. */
    OrderIdentifierType$.outboundSchema = OrderIdentifierType$outboundSchema;
})(OrderIdentifierType$ || (OrderIdentifierType$ = {}));
/** @internal */
export const OrderAmount$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const OrderAmount$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderAmount$;
(function (OrderAmount$) {
    /** @deprecated use `OrderAmount$inboundSchema` instead. */
    OrderAmount$.inboundSchema = OrderAmount$inboundSchema;
    /** @deprecated use `OrderAmount$outboundSchema` instead. */
    OrderAmount$.outboundSchema = OrderAmount$outboundSchema;
})(OrderAmount$ || (OrderAmount$ = {}));
export function orderAmountToJSON(orderAmount) {
    return JSON.stringify(OrderAmount$outboundSchema.parse(orderAmount));
}
export function orderAmountFromJSON(jsonString) {
    return safeParse(jsonString, (x) => OrderAmount$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'OrderAmount' from JSON`);
}
/** @internal */
export const PeriodStartDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const PeriodStartDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var PeriodStartDate$;
(function (PeriodStartDate$) {
    /** @deprecated use `PeriodStartDate$inboundSchema` instead. */
    PeriodStartDate$.inboundSchema = PeriodStartDate$inboundSchema;
    /** @deprecated use `PeriodStartDate$outboundSchema` instead. */
    PeriodStartDate$.outboundSchema = PeriodStartDate$outboundSchema;
})(PeriodStartDate$ || (PeriodStartDate$ = {}));
export function periodStartDateToJSON(periodStartDate) {
    return JSON.stringify(PeriodStartDate$outboundSchema.parse(periodStartDate));
}
export function periodStartDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => PeriodStartDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PeriodStartDate' from JSON`);
}
/** @internal */
export const LetterOfIntent$inboundSchema = z.object({
    amount: z.nullable(z.lazy(() => OrderAmount$inboundSchema)).optional(),
    period_start_date: z.nullable(z.lazy(() => PeriodStartDate$inboundSchema))
        .optional(),
}).transform((v) => {
    return remap$(v, {
        "period_start_date": "periodStartDate",
    });
});
/** @internal */
export const LetterOfIntent$outboundSchema = z.object({
    amount: z.nullable(z.lazy(() => OrderAmount$outboundSchema)).optional(),
    periodStartDate: z.nullable(z.lazy(() => PeriodStartDate$outboundSchema))
        .optional(),
}).transform((v) => {
    return remap$(v, {
        periodStartDate: "period_start_date",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var LetterOfIntent$;
(function (LetterOfIntent$) {
    /** @deprecated use `LetterOfIntent$inboundSchema` instead. */
    LetterOfIntent$.inboundSchema = LetterOfIntent$inboundSchema;
    /** @deprecated use `LetterOfIntent$outboundSchema` instead. */
    LetterOfIntent$.outboundSchema = LetterOfIntent$outboundSchema;
})(LetterOfIntent$ || (LetterOfIntent$ = {}));
export function letterOfIntentToJSON(letterOfIntent) {
    return JSON.stringify(LetterOfIntent$outboundSchema.parse(letterOfIntent));
}
export function letterOfIntentFromJSON(jsonString) {
    return safeParse(jsonString, (x) => LetterOfIntent$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'LetterOfIntent' from JSON`);
}
/** @internal */
export const OrderPrice$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const OrderPrice$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderPrice$;
(function (OrderPrice$) {
    /** @deprecated use `OrderPrice$inboundSchema` instead. */
    OrderPrice$.inboundSchema = OrderPrice$inboundSchema;
    /** @deprecated use `OrderPrice$outboundSchema` instead. */
    OrderPrice$.outboundSchema = OrderPrice$outboundSchema;
})(OrderPrice$ || (OrderPrice$ = {}));
export function orderPriceToJSON(orderPrice) {
    return JSON.stringify(OrderPrice$outboundSchema.parse(orderPrice));
}
export function orderPriceFromJSON(jsonString) {
    return safeParse(jsonString, (x) => OrderPrice$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'OrderPrice' from JSON`);
}
/** @internal */
export const OrderLimitPriceType$inboundSchema = z
    .union([
    z.nativeEnum(OrderLimitPriceType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderLimitPriceType$outboundSchema = z.union([
    z.nativeEnum(OrderLimitPriceType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderLimitPriceType$;
(function (OrderLimitPriceType$) {
    /** @deprecated use `OrderLimitPriceType$inboundSchema` instead. */
    OrderLimitPriceType$.inboundSchema = OrderLimitPriceType$inboundSchema;
    /** @deprecated use `OrderLimitPriceType$outboundSchema` instead. */
    OrderLimitPriceType$.outboundSchema = OrderLimitPriceType$outboundSchema;
})(OrderLimitPriceType$ || (OrderLimitPriceType$ = {}));
/** @internal */
export const LimitPrice$inboundSchema = z.object({
    price: z.nullable(z.lazy(() => OrderPrice$inboundSchema)).optional(),
    type: OrderLimitPriceType$inboundSchema.optional(),
});
/** @internal */
export const LimitPrice$outboundSchema = z.object({
    price: z.nullable(z.lazy(() => OrderPrice$outboundSchema)).optional(),
    type: OrderLimitPriceType$outboundSchema.optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var LimitPrice$;
(function (LimitPrice$) {
    /** @deprecated use `LimitPrice$inboundSchema` instead. */
    LimitPrice$.inboundSchema = LimitPrice$inboundSchema;
    /** @deprecated use `LimitPrice$outboundSchema` instead. */
    LimitPrice$.outboundSchema = LimitPrice$outboundSchema;
})(LimitPrice$ || (LimitPrice$ = {}));
export function limitPriceToJSON(limitPrice) {
    return JSON.stringify(LimitPrice$outboundSchema.parse(limitPrice));
}
export function limitPriceFromJSON(jsonString) {
    return safeParse(jsonString, (x) => LimitPrice$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'LimitPrice' from JSON`);
}
/** @internal */
export const MaxSellQuantity$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const MaxSellQuantity$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var MaxSellQuantity$;
(function (MaxSellQuantity$) {
    /** @deprecated use `MaxSellQuantity$inboundSchema` instead. */
    MaxSellQuantity$.inboundSchema = MaxSellQuantity$inboundSchema;
    /** @deprecated use `MaxSellQuantity$outboundSchema` instead. */
    MaxSellQuantity$.outboundSchema = MaxSellQuantity$outboundSchema;
})(MaxSellQuantity$ || (MaxSellQuantity$ = {}));
export function maxSellQuantityToJSON(maxSellQuantity) {
    return JSON.stringify(MaxSellQuantity$outboundSchema.parse(maxSellQuantity));
}
export function maxSellQuantityFromJSON(jsonString) {
    return safeParse(jsonString, (x) => MaxSellQuantity$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'MaxSellQuantity' from JSON`);
}
/** @internal */
export const NotionalValue$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const NotionalValue$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var NotionalValue$;
(function (NotionalValue$) {
    /** @deprecated use `NotionalValue$inboundSchema` instead. */
    NotionalValue$.inboundSchema = NotionalValue$inboundSchema;
    /** @deprecated use `NotionalValue$outboundSchema` instead. */
    NotionalValue$.outboundSchema = NotionalValue$outboundSchema;
})(NotionalValue$ || (NotionalValue$ = {}));
export function notionalValueToJSON(notionalValue) {
    return JSON.stringify(NotionalValue$outboundSchema.parse(notionalValue));
}
export function notionalValueFromJSON(jsonString) {
    return safeParse(jsonString, (x) => NotionalValue$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'NotionalValue' from JSON`);
}
/** @internal */
export const OrderDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const OrderDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderDate$;
(function (OrderDate$) {
    /** @deprecated use `OrderDate$inboundSchema` instead. */
    OrderDate$.inboundSchema = OrderDate$inboundSchema;
    /** @deprecated use `OrderDate$outboundSchema` instead. */
    OrderDate$.outboundSchema = OrderDate$outboundSchema;
})(OrderDate$ || (OrderDate$ = {}));
export function orderDateToJSON(orderDate) {
    return JSON.stringify(OrderDate$outboundSchema.parse(orderDate));
}
export function orderDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => OrderDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'OrderDate' from JSON`);
}
/** @internal */
export const OrderRejectedReason$inboundSchema = z
    .union([
    z.nativeEnum(OrderRejectedReason),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderRejectedReason$outboundSchema = z.union([
    z.nativeEnum(OrderRejectedReason),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderRejectedReason$;
(function (OrderRejectedReason$) {
    /** @deprecated use `OrderRejectedReason$inboundSchema` instead. */
    OrderRejectedReason$.inboundSchema = OrderRejectedReason$inboundSchema;
    /** @deprecated use `OrderRejectedReason$outboundSchema` instead. */
    OrderRejectedReason$.outboundSchema = OrderRejectedReason$outboundSchema;
})(OrderRejectedReason$ || (OrderRejectedReason$ = {}));
/** @internal */
export const OrderStatus$inboundSchema = z
    .union([
    z.nativeEnum(OrderStatus),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderStatus$outboundSchema = z.union([
    z.nativeEnum(OrderStatus),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderStatus$;
(function (OrderStatus$) {
    /** @deprecated use `OrderStatus$inboundSchema` instead. */
    OrderStatus$.inboundSchema = OrderStatus$inboundSchema;
    /** @deprecated use `OrderStatus$outboundSchema` instead. */
    OrderStatus$.outboundSchema = OrderStatus$outboundSchema;
})(OrderStatus$ || (OrderStatus$ = {}));
/** @internal */
export const OrderOrderType$inboundSchema = z
    .union([
    z.nativeEnum(OrderOrderType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderOrderType$outboundSchema = z.union([
    z.nativeEnum(OrderOrderType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderOrderType$;
(function (OrderOrderType$) {
    /** @deprecated use `OrderOrderType$inboundSchema` instead. */
    OrderOrderType$.inboundSchema = OrderOrderType$inboundSchema;
    /** @deprecated use `OrderOrderType$outboundSchema` instead. */
    OrderOrderType$.outboundSchema = OrderOrderType$outboundSchema;
})(OrderOrderType$ || (OrderOrderType$ = {}));
/** @internal */
export const OrderPrevailingMarketPrice$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const OrderPrevailingMarketPrice$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderPrevailingMarketPrice$;
(function (OrderPrevailingMarketPrice$) {
    /** @deprecated use `OrderPrevailingMarketPrice$inboundSchema` instead. */
    OrderPrevailingMarketPrice$.inboundSchema = OrderPrevailingMarketPrice$inboundSchema;
    /** @deprecated use `OrderPrevailingMarketPrice$outboundSchema` instead. */
    OrderPrevailingMarketPrice$.outboundSchema = OrderPrevailingMarketPrice$outboundSchema;
})(OrderPrevailingMarketPrice$ || (OrderPrevailingMarketPrice$ = {}));
export function orderPrevailingMarketPriceToJSON(orderPrevailingMarketPrice) {
    return JSON.stringify(OrderPrevailingMarketPrice$outboundSchema.parse(orderPrevailingMarketPrice));
}
export function orderPrevailingMarketPriceFromJSON(jsonString) {
    return safeParse(jsonString, (x) => OrderPrevailingMarketPrice$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'OrderPrevailingMarketPrice' from JSON`);
}
/** @internal */
export const OrderQuantity$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const OrderQuantity$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderQuantity$;
(function (OrderQuantity$) {
    /** @deprecated use `OrderQuantity$inboundSchema` instead. */
    OrderQuantity$.inboundSchema = OrderQuantity$inboundSchema;
    /** @deprecated use `OrderQuantity$outboundSchema` instead. */
    OrderQuantity$.outboundSchema = OrderQuantity$outboundSchema;
})(OrderQuantity$ || (OrderQuantity$ = {}));
export function orderQuantityToJSON(orderQuantity) {
    return JSON.stringify(OrderQuantity$outboundSchema.parse(orderQuantity));
}
export function orderQuantityFromJSON(jsonString) {
    return safeParse(jsonString, (x) => OrderQuantity$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'OrderQuantity' from JSON`);
}
/** @internal */
export const OrderRightsOfAccumulationAmount$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const OrderRightsOfAccumulationAmount$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderRightsOfAccumulationAmount$;
(function (OrderRightsOfAccumulationAmount$) {
    /** @deprecated use `OrderRightsOfAccumulationAmount$inboundSchema` instead. */
    OrderRightsOfAccumulationAmount$.inboundSchema = OrderRightsOfAccumulationAmount$inboundSchema;
    /** @deprecated use `OrderRightsOfAccumulationAmount$outboundSchema` instead. */
    OrderRightsOfAccumulationAmount$.outboundSchema = OrderRightsOfAccumulationAmount$outboundSchema;
})(OrderRightsOfAccumulationAmount$ || (OrderRightsOfAccumulationAmount$ = {}));
export function orderRightsOfAccumulationAmountToJSON(orderRightsOfAccumulationAmount) {
    return JSON.stringify(OrderRightsOfAccumulationAmount$outboundSchema.parse(orderRightsOfAccumulationAmount));
}
export function orderRightsOfAccumulationAmountFromJSON(jsonString) {
    return safeParse(jsonString, (x) => OrderRightsOfAccumulationAmount$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'OrderRightsOfAccumulationAmount' from JSON`);
}
/** @internal */
export const RightsOfAccumulation$inboundSchema = z.object({
    amount: z.nullable(z.lazy(() => OrderRightsOfAccumulationAmount$inboundSchema)).optional(),
});
/** @internal */
export const RightsOfAccumulation$outboundSchema = z.object({
    amount: z.nullable(z.lazy(() => OrderRightsOfAccumulationAmount$outboundSchema)).optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var RightsOfAccumulation$;
(function (RightsOfAccumulation$) {
    /** @deprecated use `RightsOfAccumulation$inboundSchema` instead. */
    RightsOfAccumulation$.inboundSchema = RightsOfAccumulation$inboundSchema;
    /** @deprecated use `RightsOfAccumulation$outboundSchema` instead. */
    RightsOfAccumulation$.outboundSchema = RightsOfAccumulation$outboundSchema;
})(RightsOfAccumulation$ || (RightsOfAccumulation$ = {}));
export function rightsOfAccumulationToJSON(rightsOfAccumulation) {
    return JSON.stringify(RightsOfAccumulation$outboundSchema.parse(rightsOfAccumulation));
}
export function rightsOfAccumulationFromJSON(jsonString) {
    return safeParse(jsonString, (x) => RightsOfAccumulation$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'RightsOfAccumulation' from JSON`);
}
/** @internal */
export const OrderSide$inboundSchema = z
    .union([
    z.nativeEnum(OrderSide),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderSide$outboundSchema = z.union([
    z.nativeEnum(OrderSide),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderSide$;
(function (OrderSide$) {
    /** @deprecated use `OrderSide$inboundSchema` instead. */
    OrderSide$.inboundSchema = OrderSide$inboundSchema;
    /** @deprecated use `OrderSide$outboundSchema` instead. */
    OrderSide$.outboundSchema = OrderSide$outboundSchema;
})(OrderSide$ || (OrderSide$ = {}));
/** @internal */
export const OrderSpecialReportingInstructions$inboundSchema = z
    .union([
    z.nativeEnum(OrderSpecialReportingInstructions),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderSpecialReportingInstructions$outboundSchema = z.union([
    z.nativeEnum(OrderSpecialReportingInstructions),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderSpecialReportingInstructions$;
(function (OrderSpecialReportingInstructions$) {
    /** @deprecated use `OrderSpecialReportingInstructions$inboundSchema` instead. */
    OrderSpecialReportingInstructions$.inboundSchema = OrderSpecialReportingInstructions$inboundSchema;
    /** @deprecated use `OrderSpecialReportingInstructions$outboundSchema` instead. */
    OrderSpecialReportingInstructions$.outboundSchema = OrderSpecialReportingInstructions$outboundSchema;
})(OrderSpecialReportingInstructions$ || (OrderSpecialReportingInstructions$ = {}));
/** @internal */
export const OrderStopPricePrice$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const OrderStopPricePrice$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderStopPricePrice$;
(function (OrderStopPricePrice$) {
    /** @deprecated use `OrderStopPricePrice$inboundSchema` instead. */
    OrderStopPricePrice$.inboundSchema = OrderStopPricePrice$inboundSchema;
    /** @deprecated use `OrderStopPricePrice$outboundSchema` instead. */
    OrderStopPricePrice$.outboundSchema = OrderStopPricePrice$outboundSchema;
})(OrderStopPricePrice$ || (OrderStopPricePrice$ = {}));
export function orderStopPricePriceToJSON(orderStopPricePrice) {
    return JSON.stringify(OrderStopPricePrice$outboundSchema.parse(orderStopPricePrice));
}
export function orderStopPricePriceFromJSON(jsonString) {
    return safeParse(jsonString, (x) => OrderStopPricePrice$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'OrderStopPricePrice' from JSON`);
}
/** @internal */
export const OrderStopPriceType$inboundSchema = z
    .union([
    z.nativeEnum(OrderStopPriceType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderStopPriceType$outboundSchema = z.union([
    z.nativeEnum(OrderStopPriceType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderStopPriceType$;
(function (OrderStopPriceType$) {
    /** @deprecated use `OrderStopPriceType$inboundSchema` instead. */
    OrderStopPriceType$.inboundSchema = OrderStopPriceType$inboundSchema;
    /** @deprecated use `OrderStopPriceType$outboundSchema` instead. */
    OrderStopPriceType$.outboundSchema = OrderStopPriceType$outboundSchema;
})(OrderStopPriceType$ || (OrderStopPriceType$ = {}));
/** @internal */
export const StopPrice$inboundSchema = z.object({
    price: z.nullable(z.lazy(() => OrderStopPricePrice$inboundSchema)).optional(),
    type: OrderStopPriceType$inboundSchema.optional(),
});
/** @internal */
export const StopPrice$outboundSchema = z.object({
    price: z.nullable(z.lazy(() => OrderStopPricePrice$outboundSchema))
        .optional(),
    type: OrderStopPriceType$outboundSchema.optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var StopPrice$;
(function (StopPrice$) {
    /** @deprecated use `StopPrice$inboundSchema` instead. */
    StopPrice$.inboundSchema = StopPrice$inboundSchema;
    /** @deprecated use `StopPrice$outboundSchema` instead. */
    StopPrice$.outboundSchema = StopPrice$outboundSchema;
})(StopPrice$ || (StopPrice$ = {}));
export function stopPriceToJSON(stopPrice) {
    return JSON.stringify(StopPrice$outboundSchema.parse(stopPrice));
}
export function stopPriceFromJSON(jsonString) {
    return safeParse(jsonString, (x) => StopPrice$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'StopPrice' from JSON`);
}
/** @internal */
export const OrderTimeInForce$inboundSchema = z
    .union([
    z.nativeEnum(OrderTimeInForce),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderTimeInForce$outboundSchema = z.union([
    z.nativeEnum(OrderTimeInForce),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderTimeInForce$;
(function (OrderTimeInForce$) {
    /** @deprecated use `OrderTimeInForce$inboundSchema` instead. */
    OrderTimeInForce$.inboundSchema = OrderTimeInForce$inboundSchema;
    /** @deprecated use `OrderTimeInForce$outboundSchema` instead. */
    OrderTimeInForce$.outboundSchema = OrderTimeInForce$outboundSchema;
})(OrderTimeInForce$ || (OrderTimeInForce$ = {}));
/** @internal */
export const TimeInForceExpirationDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const TimeInForceExpirationDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var TimeInForceExpirationDate$;
(function (TimeInForceExpirationDate$) {
    /** @deprecated use `TimeInForceExpirationDate$inboundSchema` instead. */
    TimeInForceExpirationDate$.inboundSchema = TimeInForceExpirationDate$inboundSchema;
    /** @deprecated use `TimeInForceExpirationDate$outboundSchema` instead. */
    TimeInForceExpirationDate$.outboundSchema = TimeInForceExpirationDate$outboundSchema;
})(TimeInForceExpirationDate$ || (TimeInForceExpirationDate$ = {}));
export function timeInForceExpirationDateToJSON(timeInForceExpirationDate) {
    return JSON.stringify(TimeInForceExpirationDate$outboundSchema.parse(timeInForceExpirationDate));
}
export function timeInForceExpirationDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => TimeInForceExpirationDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'TimeInForceExpirationDate' from JSON`);
}
/** @internal */
export const OrderTradingSession$inboundSchema = z
    .union([
    z.nativeEnum(OrderTradingSession),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OrderTradingSession$outboundSchema = z.union([
    z.nativeEnum(OrderTradingSession),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OrderTradingSession$;
(function (OrderTradingSession$) {
    /** @deprecated use `OrderTradingSession$inboundSchema` instead. */
    OrderTradingSession$.inboundSchema = OrderTradingSession$inboundSchema;
    /** @deprecated use `OrderTradingSession$outboundSchema` instead. */
    OrderTradingSession$.outboundSchema = OrderTradingSession$outboundSchema;
})(OrderTradingSession$ || (OrderTradingSession$ = {}));
/** @internal */
export const Order$inboundSchema = z
    .object({
    account_id: z.string().optional(),
    asset_id: z.string().optional(),
    asset_type: OrderAssetType$inboundSchema.optional(),
    average_prices: z.array(TradingExecutedPrice$inboundSchema).optional(),
    broker_capacity: OrderBrokerCapacity$inboundSchema.optional(),
    cancel_initiator: CancelInitiator$inboundSchema.optional(),
    cancel_reason: z.string().optional(),
    cancel_rejected_reason: CancelRejectedReason$inboundSchema.optional(),
    client_cancel_received_time: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    client_cancel_sent_time: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    client_order_id: z.string().optional(),
    client_received_time: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    client_sent_time: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    commission: z.nullable(z.lazy(() => OrderCommission$inboundSchema))
        .optional(),
    create_time: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    cumulative_notional_value: z.nullable(z.lazy(() => CumulativeNotionalValue$inboundSchema)).optional(),
    currency_code: z.string().optional(),
    executions: z.array(TradingExecutions$inboundSchema).optional(),
    extra_reporting_data: z.nullable(z.lazy(() => ExtraReportingData$inboundSchema)).optional(),
    fees: z.array(TradingFee$inboundSchema).optional(),
    filled_quantity: z.nullable(z.lazy(() => FilledQuantity$inboundSchema))
        .optional(),
    identifier: z.string().optional(),
    identifier_issuing_region_code: z.string().optional(),
    identifier_type: OrderIdentifierType$inboundSchema.optional(),
    last_update_time: z.nullable(z.string().datetime({ offset: true }).transform(v => new Date(v))).optional(),
    letter_of_intent: z.nullable(z.lazy(() => LetterOfIntent$inboundSchema))
        .optional(),
    limit_price: z.nullable(z.lazy(() => LimitPrice$inboundSchema)).optional(),
    max_sell_quantity: z.nullable(z.lazy(() => MaxSellQuantity$inboundSchema))
        .optional(),
    name: z.string().optional(),
    notional_value: z.nullable(z.lazy(() => NotionalValue$inboundSchema))
        .optional(),
    open: z.boolean().optional(),
    order_date: z.nullable(z.lazy(() => OrderDate$inboundSchema)).optional(),
    order_id: z.string().optional(),
    order_rejected_reason: OrderRejectedReason$inboundSchema.optional(),
    order_status: OrderStatus$inboundSchema.optional(),
    order_type: OrderOrderType$inboundSchema.optional(),
    prevailing_market_price: z.nullable(z.lazy(() => OrderPrevailingMarketPrice$inboundSchema)).optional(),
    quantity: z.nullable(z.lazy(() => OrderQuantity$inboundSchema)).optional(),
    rights_of_accumulation: z.nullable(z.lazy(() => RightsOfAccumulation$inboundSchema)).optional(),
    side: OrderSide$inboundSchema.optional(),
    special_reporting_instructions: z.array(OrderSpecialReportingInstructions$inboundSchema).optional(),
    stop_price: z.nullable(z.lazy(() => StopPrice$inboundSchema)).optional(),
    time_in_force: OrderTimeInForce$inboundSchema.optional(),
    time_in_force_expiration_date: z.nullable(z.lazy(() => TimeInForceExpirationDate$inboundSchema)).optional(),
    trading_session: OrderTradingSession$inboundSchema.optional(),
}).transform((v) => {
    return remap$(v, {
        "account_id": "accountId",
        "asset_id": "assetId",
        "asset_type": "assetType",
        "average_prices": "averagePrices",
        "broker_capacity": "brokerCapacity",
        "cancel_initiator": "cancelInitiator",
        "cancel_reason": "cancelReason",
        "cancel_rejected_reason": "cancelRejectedReason",
        "client_cancel_received_time": "clientCancelReceivedTime",
        "client_cancel_sent_time": "clientCancelSentTime",
        "client_order_id": "clientOrderId",
        "client_received_time": "clientReceivedTime",
        "client_sent_time": "clientSentTime",
        "create_time": "createTime",
        "cumulative_notional_value": "cumulativeNotionalValue",
        "currency_code": "currencyCode",
        "extra_reporting_data": "extraReportingData",
        "filled_quantity": "filledQuantity",
        "identifier_issuing_region_code": "identifierIssuingRegionCode",
        "identifier_type": "identifierType",
        "last_update_time": "lastUpdateTime",
        "letter_of_intent": "letterOfIntent",
        "limit_price": "limitPrice",
        "max_sell_quantity": "maxSellQuantity",
        "notional_value": "notionalValue",
        "order_date": "orderDate",
        "order_id": "orderId",
        "order_rejected_reason": "orderRejectedReason",
        "order_status": "orderStatus",
        "order_type": "orderType",
        "prevailing_market_price": "prevailingMarketPrice",
        "rights_of_accumulation": "rightsOfAccumulation",
        "special_reporting_instructions": "specialReportingInstructions",
        "stop_price": "stopPrice",
        "time_in_force": "timeInForce",
        "time_in_force_expiration_date": "timeInForceExpirationDate",
        "trading_session": "tradingSession",
    });
});
/** @internal */
export const Order$outboundSchema = z.object({
    accountId: z.string().optional(),
    assetId: z.string().optional(),
    assetType: OrderAssetType$outboundSchema.optional(),
    averagePrices: z.array(TradingExecutedPrice$outboundSchema).optional(),
    brokerCapacity: OrderBrokerCapacity$outboundSchema.optional(),
    cancelInitiator: CancelInitiator$outboundSchema.optional(),
    cancelReason: z.string().optional(),
    cancelRejectedReason: CancelRejectedReason$outboundSchema.optional(),
    clientCancelReceivedTime: z.nullable(z.date().transform(v => v.toISOString()))
        .optional(),
    clientCancelSentTime: z.nullable(z.date().transform(v => v.toISOString()))
        .optional(),
    clientOrderId: z.string().optional(),
    clientReceivedTime: z.nullable(z.date().transform(v => v.toISOString()))
        .optional(),
    clientSentTime: z.nullable(z.date().transform(v => v.toISOString()))
        .optional(),
    commission: z.nullable(z.lazy(() => OrderCommission$outboundSchema))
        .optional(),
    createTime: z.nullable(z.date().transform(v => v.toISOString())).optional(),
    cumulativeNotionalValue: z.nullable(z.lazy(() => CumulativeNotionalValue$outboundSchema)).optional(),
    currencyCode: z.string().optional(),
    executions: z.array(TradingExecutions$outboundSchema).optional(),
    extraReportingData: z.nullable(z.lazy(() => ExtraReportingData$outboundSchema)).optional(),
    fees: z.array(TradingFee$outboundSchema).optional(),
    filledQuantity: z.nullable(z.lazy(() => FilledQuantity$outboundSchema))
        .optional(),
    identifier: z.string().optional(),
    identifierIssuingRegionCode: z.string().optional(),
    identifierType: OrderIdentifierType$outboundSchema.optional(),
    lastUpdateTime: z.nullable(z.date().transform(v => v.toISOString()))
        .optional(),
    letterOfIntent: z.nullable(z.lazy(() => LetterOfIntent$outboundSchema))
        .optional(),
    limitPrice: z.nullable(z.lazy(() => LimitPrice$outboundSchema)).optional(),
    maxSellQuantity: z.nullable(z.lazy(() => MaxSellQuantity$outboundSchema))
        .optional(),
    name: z.string().optional(),
    notionalValue: z.nullable(z.lazy(() => NotionalValue$outboundSchema))
        .optional(),
    open: z.boolean().optional(),
    orderDate: z.nullable(z.lazy(() => OrderDate$outboundSchema)).optional(),
    orderId: z.string().optional(),
    orderRejectedReason: OrderRejectedReason$outboundSchema.optional(),
    orderStatus: OrderStatus$outboundSchema.optional(),
    orderType: OrderOrderType$outboundSchema.optional(),
    prevailingMarketPrice: z.nullable(z.lazy(() => OrderPrevailingMarketPrice$outboundSchema)).optional(),
    quantity: z.nullable(z.lazy(() => OrderQuantity$outboundSchema)).optional(),
    rightsOfAccumulation: z.nullable(z.lazy(() => RightsOfAccumulation$outboundSchema)).optional(),
    side: OrderSide$outboundSchema.optional(),
    specialReportingInstructions: z.array(OrderSpecialReportingInstructions$outboundSchema).optional(),
    stopPrice: z.nullable(z.lazy(() => StopPrice$outboundSchema)).optional(),
    timeInForce: OrderTimeInForce$outboundSchema.optional(),
    timeInForceExpirationDate: z.nullable(z.lazy(() => TimeInForceExpirationDate$outboundSchema)).optional(),
    tradingSession: OrderTradingSession$outboundSchema.optional(),
}).transform((v) => {
    return remap$(v, {
        accountId: "account_id",
        assetId: "asset_id",
        assetType: "asset_type",
        averagePrices: "average_prices",
        brokerCapacity: "broker_capacity",
        cancelInitiator: "cancel_initiator",
        cancelReason: "cancel_reason",
        cancelRejectedReason: "cancel_rejected_reason",
        clientCancelReceivedTime: "client_cancel_received_time",
        clientCancelSentTime: "client_cancel_sent_time",
        clientOrderId: "client_order_id",
        clientReceivedTime: "client_received_time",
        clientSentTime: "client_sent_time",
        createTime: "create_time",
        cumulativeNotionalValue: "cumulative_notional_value",
        currencyCode: "currency_code",
        extraReportingData: "extra_reporting_data",
        filledQuantity: "filled_quantity",
        identifierIssuingRegionCode: "identifier_issuing_region_code",
        identifierType: "identifier_type",
        lastUpdateTime: "last_update_time",
        letterOfIntent: "letter_of_intent",
        limitPrice: "limit_price",
        maxSellQuantity: "max_sell_quantity",
        notionalValue: "notional_value",
        orderDate: "order_date",
        orderId: "order_id",
        orderRejectedReason: "order_rejected_reason",
        orderStatus: "order_status",
        orderType: "order_type",
        prevailingMarketPrice: "prevailing_market_price",
        rightsOfAccumulation: "rights_of_accumulation",
        specialReportingInstructions: "special_reporting_instructions",
        stopPrice: "stop_price",
        timeInForce: "time_in_force",
        timeInForceExpirationDate: "time_in_force_expiration_date",
        tradingSession: "trading_session",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Order$;
(function (Order$) {
    /** @deprecated use `Order$inboundSchema` instead. */
    Order$.inboundSchema = Order$inboundSchema;
    /** @deprecated use `Order$outboundSchema` instead. */
    Order$.outboundSchema = Order$outboundSchema;
})(Order$ || (Order$ = {}));
export function orderToJSON(order) {
    return JSON.stringify(Order$outboundSchema.parse(order));
}
export function orderFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Order$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Order' from JSON`);
}
//# sourceMappingURL=order.js.map