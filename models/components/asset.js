/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { catchUnrecognizedEnum, } from "../../types/enums.js";
import { OptionDeliverable$inboundSchema, OptionDeliverable$outboundSchema, } from "./optiondeliverable.js";
/**
 * Indicates the type of currency
 */
export var CurrencyType;
(function (CurrencyType) {
    CurrencyType["CurrencyTypeUnspecified"] = "CURRENCY_TYPE_UNSPECIFIED";
    CurrencyType["Currency"] = "CURRENCY";
    CurrencyType["CurrencyEquivalent"] = "CURRENCY_EQUIVALENT";
})(CurrencyType || (CurrencyType = {}));
/**
 * the code indicating the type of associated security.
 */
export var AssetEquityType;
(function (AssetEquityType) {
    AssetEquityType["EquityTypeUnspecified"] = "EQUITY_TYPE_UNSPECIFIED";
    AssetEquityType["CommonStock"] = "COMMON_STOCK";
    AssetEquityType["PreferredStock"] = "PREFERRED_STOCK";
    AssetEquityType["PreferredAdr"] = "PREFERRED_ADR";
    AssetEquityType["SpecialStock"] = "SPECIAL_STOCK";
    AssetEquityType["Index"] = "INDEX";
    AssetEquityType["Warrant"] = "WARRANT";
    AssetEquityType["Adr"] = "ADR";
    AssetEquityType["Rights"] = "RIGHTS";
    AssetEquityType["SharesOfBeneficialInterest"] = "SHARES_OF_BENEFICIAL_INTEREST";
    AssetEquityType["Certificates"] = "CERTIFICATES";
    AssetEquityType["Units"] = "UNITS";
    AssetEquityType["DebtIssue"] = "DEBT_ISSUE";
    AssetEquityType["EquityTypeOption"] = "EQUITY_TYPE_OPTION";
    AssetEquityType["Etf"] = "ETF";
})(AssetEquityType || (AssetEquityType = {}));
/**
 * The type of call
 */
export var CallType;
(function (CallType) {
    CallType["CallTypeUnspecified"] = "CALL_TYPE_UNSPECIFIED";
    CallType["Ordinary"] = "ORDINARY";
    CallType["Special"] = "SPECIAL";
    CallType["MakeWhole"] = "MAKE_WHOLE";
    CallType["Regulatory"] = "REGULATORY";
})(CallType || (CallType = {}));
/**
 * Frequency of payments
 */
export var CouponFrequency;
(function (CouponFrequency) {
    CouponFrequency["CouponFrequencyUnspecified"] = "COUPON_FREQUENCY_UNSPECIFIED";
    CouponFrequency["SemiAnnual"] = "SEMI_ANNUAL";
    CouponFrequency["Monthly"] = "MONTHLY";
    CouponFrequency["AtMaturity"] = "AT_MATURITY";
    CouponFrequency["Zero"] = "ZERO";
    CouponFrequency["Quarterly"] = "QUARTERLY";
    CouponFrequency["Annual"] = "ANNUAL";
})(CouponFrequency || (CouponFrequency = {}));
/**
 * Type of coupon rate
 */
export var CouponType;
(function (CouponType) {
    CouponType["CouponTypeUnspecified"] = "COUPON_TYPE_UNSPECIFIED";
    CouponType["CouponTypeFixed"] = "COUPON_TYPE_FIXED";
    CouponType["CouponTypeZero"] = "COUPON_TYPE_ZERO";
})(CouponType || (CouponType = {}));
/**
 * The status of the fixed income
 */
export var FixedIncomeStatus;
(function (FixedIncomeStatus) {
    FixedIncomeStatus["FixedIncomeStatusUnspecified"] = "FIXED_INCOME_STATUS_UNSPECIFIED";
    FixedIncomeStatus["Outstanding"] = "OUTSTANDING";
    FixedIncomeStatus["Matured"] = "MATURED";
    FixedIncomeStatus["Called"] = "CALLED";
    FixedIncomeStatus["Unknown"] = "UNKNOWN";
    FixedIncomeStatus["Defaulted"] = "DEFAULTED";
    FixedIncomeStatus["Converted"] = "CONVERTED";
    FixedIncomeStatus["Tendered"] = "TENDERED";
    FixedIncomeStatus["PreIssuance"] = "PRE_ISSUANCE";
    FixedIncomeStatus["Liquidated"] = "LIQUIDATED";
    FixedIncomeStatus["Repurchased"] = "REPURCHASED";
    FixedIncomeStatus["Repaid"] = "REPAID";
    FixedIncomeStatus["Restructured"] = "RESTRUCTURED";
    FixedIncomeStatus["Put"] = "PUT";
    FixedIncomeStatus["Funged"] = "FUNGED";
})(FixedIncomeStatus || (FixedIncomeStatus = {}));
/**
 * The type of treasury
 */
export var FixedIncomeSubtype;
(function (FixedIncomeSubtype) {
    FixedIncomeSubtype["FixedIncomeSubtypeUnspecified"] = "FIXED_INCOME_SUBTYPE_UNSPECIFIED";
    FixedIncomeSubtype["Bond"] = "BOND";
    FixedIncomeSubtype["Strips"] = "STRIPS";
    FixedIncomeSubtype["Bill"] = "BILL";
    FixedIncomeSubtype["Note"] = "NOTE";
    FixedIncomeSubtype["Tips"] = "TIPS";
})(FixedIncomeSubtype || (FixedIncomeSubtype = {}));
/**
 * Type of fixed income security
 */
export var FixedIncomeType;
(function (FixedIncomeType) {
    FixedIncomeType["FixedIncomeTypeUnspecified"] = "FIXED_INCOME_TYPE_UNSPECIFIED";
    FixedIncomeType["Municipal"] = "MUNICIPAL";
    FixedIncomeType["Corporate"] = "CORPORATE";
    FixedIncomeType["Cd"] = "CD";
    FixedIncomeType["Agency"] = "AGENCY";
    FixedIncomeType["Treasury"] = "TREASURY";
    FixedIncomeType["Government"] = "GOVERNMENT";
    FixedIncomeType["ForeignGovernment"] = "FOREIGN_GOVERNMENT";
})(FixedIncomeType || (FixedIncomeType = {}));
/**
 * Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
 */
export var SpRating;
(function (SpRating) {
    SpRating["SpRatingUnspecified"] = "SP_RATING_UNSPECIFIED";
    SpRating["Aaa"] = "AAA";
    SpRating["AaPlus"] = "AA_PLUS";
    SpRating["Aa"] = "AA";
    SpRating["AaMinus"] = "AA_MINUS";
    SpRating["APlus"] = "A_PLUS";
    SpRating["A"] = "A";
    SpRating["AMinus"] = "A_MINUS";
    SpRating["BbbPlus"] = "BBB_PLUS";
    SpRating["Bbb"] = "BBB";
    SpRating["BbbMinus"] = "BBB_MINUS";
    SpRating["BbPlus"] = "BB_PLUS";
    SpRating["Bb"] = "BB";
    SpRating["BbMinus"] = "BB_MINUS";
    SpRating["BPlus"] = "B_PLUS";
    SpRating["B"] = "B";
    SpRating["BMinus"] = "B_MINUS";
    SpRating["CccPlus"] = "CCC_PLUS";
    SpRating["Ccc"] = "CCC";
    SpRating["CccMinus"] = "CCC_MINUS";
    SpRating["Cc"] = "CC";
    SpRating["C"] = "C";
    SpRating["D"] = "D";
    SpRating["Nr"] = "NR";
    SpRating["Sp1Plus"] = "SP_1_PLUS";
    SpRating["Sp1"] = "SP_1";
    SpRating["Sp1Minus"] = "SP_1_MINUS";
    SpRating["A1Plus"] = "A_1_PLUS";
    SpRating["A1"] = "A_1";
    SpRating["A1Minus"] = "A_1_MINUS";
})(SpRating || (SpRating = {}));
/**
 * Identifies type of mutual fund
 */
export var MutualFundType;
(function (MutualFundType) {
    MutualFundType["MutualFundTypeUnspecified"] = "MUTUAL_FUND_TYPE_UNSPECIFIED";
    MutualFundType["Bond"] = "BOND";
    MutualFundType["MoneyMarketFund"] = "MONEY_MARKET_FUND";
    MutualFundType["Equity"] = "EQUITY";
})(MutualFundType || (MutualFundType = {}));
/**
 * Indicates whether the option is a Call or a Put. A Put entitles the holder to sell shares at the specified strike_price, while a Call entitles the holder to buy shares at the specified strike_price.
 */
export var CallPut;
(function (CallPut) {
    CallPut["CallPutUnspecified"] = "CALL_PUT_UNSPECIFIED";
    CallPut["Call"] = "CALL";
    CallPut["Put"] = "PUT";
})(CallPut || (CallPut = {}));
/**
 * Indicates how and when an option can be exercised, either American (exercise any time before expiration) or European (exercise only at expiration).
 */
export var ExerciseStyle;
(function (ExerciseStyle) {
    ExerciseStyle["ExerciseStyleUnspecified"] = "EXERCISE_STYLE_UNSPECIFIED";
    ExerciseStyle["American"] = "AMERICAN";
    ExerciseStyle["European"] = "EUROPEAN";
})(ExerciseStyle || (ExerciseStyle = {}));
/**
 * Classification is the category of option that the option falls into These are based on how the contract was written. Only STANDARD is supported at this time.
 */
export var Classification;
(function (Classification) {
    Classification["ClassificationUnspecified"] = "CLASSIFICATION_UNSPECIFIED";
    Classification["Standard"] = "STANDARD";
    Classification["Flex"] = "FLEX";
})(Classification || (Classification = {}));
/**
 * The penny pilot indicator of the option
 */
export var PennyPilotIndicator;
(function (PennyPilotIndicator) {
    PennyPilotIndicator["PennyPilotIndicatorUnspecified"] = "PENNY_PILOT_INDICATOR_UNSPECIFIED";
    PennyPilotIndicator["PennyPilot"] = "PENNY_PILOT";
    PennyPilotIndicator["NonPennyPilot"] = "NON_PENNY_PILOT";
})(PennyPilotIndicator || (PennyPilotIndicator = {}));
/**
 * Indicates whether the option is designated to settle at the market's opening price on the expiration date.
 */
export var SettlementStyle;
(function (SettlementStyle) {
    SettlementStyle["SettlementStyleUnspecified"] = "SETTLEMENT_STYLE_UNSPECIFIED";
    SettlementStyle["SettleOnOpen"] = "SETTLE_ON_OPEN";
    SettlementStyle["SettleOnClose"] = "SETTLE_ON_CLOSE";
})(SettlementStyle || (SettlementStyle = {}));
/**
 * Type of deliverable asset the option is set to deliver upon expiry.
 */
export var OptionType;
(function (OptionType) {
    OptionType["OptionTypeUnspecified"] = "OPTION_TYPE_UNSPECIFIED";
    OptionType["Equity"] = "EQUITY";
    OptionType["Index"] = "INDEX";
})(OptionType || (OptionType = {}));
/**
 * Specifies how an option is settled at expiration, either Physical (delivery of the underlying asset) or Cash (payment of the cash difference).
 */
export var SettlementMethod;
(function (SettlementMethod) {
    SettlementMethod["SettlementMethodUnspecified"] = "SETTLEMENT_METHOD_UNSPECIFIED";
    SettlementMethod["Cash"] = "CASH";
    SettlementMethod["Physical"] = "PHYSICAL";
})(SettlementMethod || (SettlementMethod = {}));
/**
 * Indicates whether an option follows Standard settlement terms or has Non-Standard terms, often due to adjustments like corporate actions.
 */
export var SettlementType;
(function (SettlementType) {
    SettlementType["SettlementTypeUnspecified"] = "SETTLEMENT_TYPE_UNSPECIFIED";
    SettlementType["Standard"] = "STANDARD";
    SettlementType["NonStandard"] = "NON_STANDARD";
})(SettlementType || (SettlementType = {}));
/**
 * The type or category of the asset
 */
export var AssetType1;
(function (AssetType1) {
    AssetType1["TypeUnspecified"] = "TYPE_UNSPECIFIED";
    AssetType1["Equity"] = "EQUITY";
    AssetType1["Option"] = "OPTION";
    AssetType1["Currency"] = "CURRENCY";
    AssetType1["Digital"] = "DIGITAL";
    AssetType1["FdicSynthetic"] = "FDIC_SYNTHETIC";
    AssetType1["FixedIncome"] = "FIXED_INCOME";
    AssetType1["MutualFund"] = "MUTUAL_FUND";
    AssetType1["Index"] = "INDEX";
})(AssetType1 || (AssetType1 = {}));
/** @internal */
export const CurrencyType$inboundSchema = z
    .union([
    z.nativeEnum(CurrencyType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const CurrencyType$outboundSchema = z.union([
    z.nativeEnum(CurrencyType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var CurrencyType$;
(function (CurrencyType$) {
    /** @deprecated use `CurrencyType$inboundSchema` instead. */
    CurrencyType$.inboundSchema = CurrencyType$inboundSchema;
    /** @deprecated use `CurrencyType$outboundSchema` instead. */
    CurrencyType$.outboundSchema = CurrencyType$outboundSchema;
})(CurrencyType$ || (CurrencyType$ = {}));
/** @internal */
export const Currency$inboundSchema = z.object({
    currency_type: CurrencyType$inboundSchema.optional(),
    payment_currency: z.string().optional(),
}).transform((v) => {
    return remap$(v, {
        "currency_type": "currencyType",
        "payment_currency": "paymentCurrency",
    });
});
/** @internal */
export const Currency$outboundSchema = z.object({
    currencyType: CurrencyType$outboundSchema.optional(),
    paymentCurrency: z.string().optional(),
}).transform((v) => {
    return remap$(v, {
        currencyType: "currency_type",
        paymentCurrency: "payment_currency",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Currency$;
(function (Currency$) {
    /** @deprecated use `Currency$inboundSchema` instead. */
    Currency$.inboundSchema = Currency$inboundSchema;
    /** @deprecated use `Currency$outboundSchema` instead. */
    Currency$.outboundSchema = Currency$outboundSchema;
})(Currency$ || (Currency$ = {}));
export function currencyToJSON(currency) {
    return JSON.stringify(Currency$outboundSchema.parse(currency));
}
export function currencyFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Currency$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Currency' from JSON`);
}
/** @internal */
export const AssetEquityType$inboundSchema = z
    .union([
    z.nativeEnum(AssetEquityType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const AssetEquityType$outboundSchema = z.union([
    z.nativeEnum(AssetEquityType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AssetEquityType$;
(function (AssetEquityType$) {
    /** @deprecated use `AssetEquityType$inboundSchema` instead. */
    AssetEquityType$.inboundSchema = AssetEquityType$inboundSchema;
    /** @deprecated use `AssetEquityType$outboundSchema` instead. */
    AssetEquityType$.outboundSchema = AssetEquityType$outboundSchema;
})(AssetEquityType$ || (AssetEquityType$ = {}));
/** @internal */
export const Equity$inboundSchema = z
    .object({
    fractionable: z.boolean().optional(),
    liquidate: z.boolean().optional(),
    type: AssetEquityType$inboundSchema.optional(),
});
/** @internal */
export const Equity$outboundSchema = z.object({
    fractionable: z.boolean().optional(),
    liquidate: z.boolean().optional(),
    type: AssetEquityType$outboundSchema.optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Equity$;
(function (Equity$) {
    /** @deprecated use `Equity$inboundSchema` instead. */
    Equity$.inboundSchema = Equity$inboundSchema;
    /** @deprecated use `Equity$outboundSchema` instead. */
    Equity$.outboundSchema = Equity$outboundSchema;
})(Equity$ || (Equity$ = {}));
export function equityToJSON(equity) {
    return JSON.stringify(Equity$outboundSchema.parse(equity));
}
export function equityFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Equity$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Equity' from JSON`);
}
/** @internal */
export const CallType$inboundSchema = z
    .union([
    z.nativeEnum(CallType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const CallType$outboundSchema = z.union([
    z.nativeEnum(CallType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var CallType$;
(function (CallType$) {
    /** @deprecated use `CallType$inboundSchema` instead. */
    CallType$.inboundSchema = CallType$inboundSchema;
    /** @deprecated use `CallType$outboundSchema` instead. */
    CallType$.outboundSchema = CallType$outboundSchema;
})(CallType$ || (CallType$ = {}));
/** @internal */
export const CouponFrequency$inboundSchema = z
    .union([
    z.nativeEnum(CouponFrequency),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const CouponFrequency$outboundSchema = z.union([
    z.nativeEnum(CouponFrequency),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var CouponFrequency$;
(function (CouponFrequency$) {
    /** @deprecated use `CouponFrequency$inboundSchema` instead. */
    CouponFrequency$.inboundSchema = CouponFrequency$inboundSchema;
    /** @deprecated use `CouponFrequency$outboundSchema` instead. */
    CouponFrequency$.outboundSchema = CouponFrequency$outboundSchema;
})(CouponFrequency$ || (CouponFrequency$ = {}));
/** @internal */
export const CouponRate$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const CouponRate$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var CouponRate$;
(function (CouponRate$) {
    /** @deprecated use `CouponRate$inboundSchema` instead. */
    CouponRate$.inboundSchema = CouponRate$inboundSchema;
    /** @deprecated use `CouponRate$outboundSchema` instead. */
    CouponRate$.outboundSchema = CouponRate$outboundSchema;
})(CouponRate$ || (CouponRate$ = {}));
export function couponRateToJSON(couponRate) {
    return JSON.stringify(CouponRate$outboundSchema.parse(couponRate));
}
export function couponRateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => CouponRate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'CouponRate' from JSON`);
}
/** @internal */
export const CouponType$inboundSchema = z
    .union([
    z.nativeEnum(CouponType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const CouponType$outboundSchema = z.union([
    z.nativeEnum(CouponType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var CouponType$;
(function (CouponType$) {
    /** @deprecated use `CouponType$inboundSchema` instead. */
    CouponType$.inboundSchema = CouponType$inboundSchema;
    /** @deprecated use `CouponType$outboundSchema` instead. */
    CouponType$.outboundSchema = CouponType$outboundSchema;
})(CouponType$ || (CouponType$ = {}));
/** @internal */
export const Duration$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const Duration$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Duration$;
(function (Duration$) {
    /** @deprecated use `Duration$inboundSchema` instead. */
    Duration$.inboundSchema = Duration$inboundSchema;
    /** @deprecated use `Duration$outboundSchema` instead. */
    Duration$.outboundSchema = Duration$outboundSchema;
})(Duration$ || (Duration$ = {}));
export function durationToJSON(duration) {
    return JSON.stringify(Duration$outboundSchema.parse(duration));
}
export function durationFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Duration$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Duration' from JSON`);
}
/** @internal */
export const FirstCouponDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const FirstCouponDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var FirstCouponDate$;
(function (FirstCouponDate$) {
    /** @deprecated use `FirstCouponDate$inboundSchema` instead. */
    FirstCouponDate$.inboundSchema = FirstCouponDate$inboundSchema;
    /** @deprecated use `FirstCouponDate$outboundSchema` instead. */
    FirstCouponDate$.outboundSchema = FirstCouponDate$outboundSchema;
})(FirstCouponDate$ || (FirstCouponDate$ = {}));
export function firstCouponDateToJSON(firstCouponDate) {
    return JSON.stringify(FirstCouponDate$outboundSchema.parse(firstCouponDate));
}
export function firstCouponDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => FirstCouponDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'FirstCouponDate' from JSON`);
}
/** @internal */
export const FixedIncomeStatus$inboundSchema = z
    .union([
    z.nativeEnum(FixedIncomeStatus),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const FixedIncomeStatus$outboundSchema = z.union([
    z.nativeEnum(FixedIncomeStatus),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var FixedIncomeStatus$;
(function (FixedIncomeStatus$) {
    /** @deprecated use `FixedIncomeStatus$inboundSchema` instead. */
    FixedIncomeStatus$.inboundSchema = FixedIncomeStatus$inboundSchema;
    /** @deprecated use `FixedIncomeStatus$outboundSchema` instead. */
    FixedIncomeStatus$.outboundSchema = FixedIncomeStatus$outboundSchema;
})(FixedIncomeStatus$ || (FixedIncomeStatus$ = {}));
/** @internal */
export const FixedIncomeSubtype$inboundSchema = z
    .union([
    z.nativeEnum(FixedIncomeSubtype),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const FixedIncomeSubtype$outboundSchema = z.union([
    z.nativeEnum(FixedIncomeSubtype),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var FixedIncomeSubtype$;
(function (FixedIncomeSubtype$) {
    /** @deprecated use `FixedIncomeSubtype$inboundSchema` instead. */
    FixedIncomeSubtype$.inboundSchema = FixedIncomeSubtype$inboundSchema;
    /** @deprecated use `FixedIncomeSubtype$outboundSchema` instead. */
    FixedIncomeSubtype$.outboundSchema = FixedIncomeSubtype$outboundSchema;
})(FixedIncomeSubtype$ || (FixedIncomeSubtype$ = {}));
/** @internal */
export const FixedIncomeType$inboundSchema = z
    .union([
    z.nativeEnum(FixedIncomeType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const FixedIncomeType$outboundSchema = z.union([
    z.nativeEnum(FixedIncomeType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var FixedIncomeType$;
(function (FixedIncomeType$) {
    /** @deprecated use `FixedIncomeType$inboundSchema` instead. */
    FixedIncomeType$.inboundSchema = FixedIncomeType$inboundSchema;
    /** @deprecated use `FixedIncomeType$outboundSchema` instead. */
    FixedIncomeType$.outboundSchema = FixedIncomeType$outboundSchema;
})(FixedIncomeType$ || (FixedIncomeType$ = {}));
/** @internal */
export const AssetIssueDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const AssetIssueDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AssetIssueDate$;
(function (AssetIssueDate$) {
    /** @deprecated use `AssetIssueDate$inboundSchema` instead. */
    AssetIssueDate$.inboundSchema = AssetIssueDate$inboundSchema;
    /** @deprecated use `AssetIssueDate$outboundSchema` instead. */
    AssetIssueDate$.outboundSchema = AssetIssueDate$outboundSchema;
})(AssetIssueDate$ || (AssetIssueDate$ = {}));
export function assetIssueDateToJSON(assetIssueDate) {
    return JSON.stringify(AssetIssueDate$outboundSchema.parse(assetIssueDate));
}
export function assetIssueDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => AssetIssueDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'AssetIssueDate' from JSON`);
}
/** @internal */
export const IssueSize$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const IssueSize$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var IssueSize$;
(function (IssueSize$) {
    /** @deprecated use `IssueSize$inboundSchema` instead. */
    IssueSize$.inboundSchema = IssueSize$inboundSchema;
    /** @deprecated use `IssueSize$outboundSchema` instead. */
    IssueSize$.outboundSchema = IssueSize$outboundSchema;
})(IssueSize$ || (IssueSize$ = {}));
export function issueSizeToJSON(issueSize) {
    return JSON.stringify(IssueSize$outboundSchema.parse(issueSize));
}
export function issueSizeFromJSON(jsonString) {
    return safeParse(jsonString, (x) => IssueSize$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'IssueSize' from JSON`);
}
/** @internal */
export const LastCouponDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const LastCouponDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var LastCouponDate$;
(function (LastCouponDate$) {
    /** @deprecated use `LastCouponDate$inboundSchema` instead. */
    LastCouponDate$.inboundSchema = LastCouponDate$inboundSchema;
    /** @deprecated use `LastCouponDate$outboundSchema` instead. */
    LastCouponDate$.outboundSchema = LastCouponDate$outboundSchema;
})(LastCouponDate$ || (LastCouponDate$ = {}));
export function lastCouponDateToJSON(lastCouponDate) {
    return JSON.stringify(LastCouponDate$outboundSchema.parse(lastCouponDate));
}
export function lastCouponDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => LastCouponDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'LastCouponDate' from JSON`);
}
/** @internal */
export const MaturityDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const MaturityDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var MaturityDate$;
(function (MaturityDate$) {
    /** @deprecated use `MaturityDate$inboundSchema` instead. */
    MaturityDate$.inboundSchema = MaturityDate$inboundSchema;
    /** @deprecated use `MaturityDate$outboundSchema` instead. */
    MaturityDate$.outboundSchema = MaturityDate$outboundSchema;
})(MaturityDate$ || (MaturityDate$ = {}));
export function maturityDateToJSON(maturityDate) {
    return JSON.stringify(MaturityDate$outboundSchema.parse(maturityDate));
}
export function maturityDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => MaturityDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'MaturityDate' from JSON`);
}
/** @internal */
export const NextCallDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const NextCallDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var NextCallDate$;
(function (NextCallDate$) {
    /** @deprecated use `NextCallDate$inboundSchema` instead. */
    NextCallDate$.inboundSchema = NextCallDate$inboundSchema;
    /** @deprecated use `NextCallDate$outboundSchema` instead. */
    NextCallDate$.outboundSchema = NextCallDate$outboundSchema;
})(NextCallDate$ || (NextCallDate$ = {}));
export function nextCallDateToJSON(nextCallDate) {
    return JSON.stringify(NextCallDate$outboundSchema.parse(nextCallDate));
}
export function nextCallDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => NextCallDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'NextCallDate' from JSON`);
}
/** @internal */
export const NextCouponDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const NextCouponDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var NextCouponDate$;
(function (NextCouponDate$) {
    /** @deprecated use `NextCouponDate$inboundSchema` instead. */
    NextCouponDate$.inboundSchema = NextCouponDate$inboundSchema;
    /** @deprecated use `NextCouponDate$outboundSchema` instead. */
    NextCouponDate$.outboundSchema = NextCouponDate$outboundSchema;
})(NextCouponDate$ || (NextCouponDate$ = {}));
export function nextCouponDateToJSON(nextCouponDate) {
    return JSON.stringify(NextCouponDate$outboundSchema.parse(nextCouponDate));
}
export function nextCouponDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => NextCouponDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'NextCouponDate' from JSON`);
}
/** @internal */
export const ParValue$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const ParValue$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ParValue$;
(function (ParValue$) {
    /** @deprecated use `ParValue$inboundSchema` instead. */
    ParValue$.inboundSchema = ParValue$inboundSchema;
    /** @deprecated use `ParValue$outboundSchema` instead. */
    ParValue$.outboundSchema = ParValue$outboundSchema;
})(ParValue$ || (ParValue$ = {}));
export function parValueToJSON(parValue) {
    return JSON.stringify(ParValue$outboundSchema.parse(parValue));
}
export function parValueFromJSON(jsonString) {
    return safeParse(jsonString, (x) => ParValue$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ParValue' from JSON`);
}
/** @internal */
export const PriceAtIssuance$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const PriceAtIssuance$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var PriceAtIssuance$;
(function (PriceAtIssuance$) {
    /** @deprecated use `PriceAtIssuance$inboundSchema` instead. */
    PriceAtIssuance$.inboundSchema = PriceAtIssuance$inboundSchema;
    /** @deprecated use `PriceAtIssuance$outboundSchema` instead. */
    PriceAtIssuance$.outboundSchema = PriceAtIssuance$outboundSchema;
})(PriceAtIssuance$ || (PriceAtIssuance$ = {}));
export function priceAtIssuanceToJSON(priceAtIssuance) {
    return JSON.stringify(PriceAtIssuance$outboundSchema.parse(priceAtIssuance));
}
export function priceAtIssuanceFromJSON(jsonString) {
    return safeParse(jsonString, (x) => PriceAtIssuance$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PriceAtIssuance' from JSON`);
}
/** @internal */
export const SpRating$inboundSchema = z
    .union([
    z.nativeEnum(SpRating),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const SpRating$outboundSchema = z.union([
    z.nativeEnum(SpRating),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var SpRating$;
(function (SpRating$) {
    /** @deprecated use `SpRating$inboundSchema` instead. */
    SpRating$.inboundSchema = SpRating$inboundSchema;
    /** @deprecated use `SpRating$outboundSchema` instead. */
    SpRating$.outboundSchema = SpRating$outboundSchema;
})(SpRating$ || (SpRating$ = {}));
/** @internal */
export const SpRatingDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const SpRatingDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var SpRatingDate$;
(function (SpRatingDate$) {
    /** @deprecated use `SpRatingDate$inboundSchema` instead. */
    SpRatingDate$.inboundSchema = SpRatingDate$inboundSchema;
    /** @deprecated use `SpRatingDate$outboundSchema` instead. */
    SpRatingDate$.outboundSchema = SpRatingDate$outboundSchema;
})(SpRatingDate$ || (SpRatingDate$ = {}));
export function spRatingDateToJSON(spRatingDate) {
    return JSON.stringify(SpRatingDate$outboundSchema.parse(spRatingDate));
}
export function spRatingDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => SpRatingDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'SpRatingDate' from JSON`);
}
/** @internal */
export const FixedIncome$inboundSchema = z.object({
    call_type: CallType$inboundSchema.optional(),
    callable: z.boolean().optional(),
    convertible: z.boolean().optional(),
    coupon_frequency: CouponFrequency$inboundSchema.optional(),
    coupon_rate: z.nullable(z.lazy(() => CouponRate$inboundSchema)).optional(),
    coupon_type: CouponType$inboundSchema.optional(),
    duration: z.nullable(z.lazy(() => Duration$inboundSchema)).optional(),
    first_coupon_date: z.nullable(z.lazy(() => FirstCouponDate$inboundSchema))
        .optional(),
    fixed_income_status: FixedIncomeStatus$inboundSchema.optional(),
    fixed_income_subtype: FixedIncomeSubtype$inboundSchema.optional(),
    fixed_income_type: FixedIncomeType$inboundSchema.optional(),
    insured: z.boolean().optional(),
    issue_date: z.nullable(z.lazy(() => AssetIssueDate$inboundSchema)).optional(),
    issue_size: z.nullable(z.lazy(() => IssueSize$inboundSchema)).optional(),
    issuer: z.string().optional(),
    last_coupon_date: z.nullable(z.lazy(() => LastCouponDate$inboundSchema))
        .optional(),
    maturity_date: z.nullable(z.lazy(() => MaturityDate$inboundSchema))
        .optional(),
    next_call_date: z.nullable(z.lazy(() => NextCallDate$inboundSchema))
        .optional(),
    next_coupon_date: z.nullable(z.lazy(() => NextCouponDate$inboundSchema))
        .optional(),
    par_value: z.nullable(z.lazy(() => ParValue$inboundSchema)).optional(),
    perpetual: z.boolean().optional(),
    price_at_issuance: z.nullable(z.lazy(() => PriceAtIssuance$inboundSchema))
        .optional(),
    sp_rating: SpRating$inboundSchema.optional(),
    sp_rating_date: z.nullable(z.lazy(() => SpRatingDate$inboundSchema))
        .optional(),
    underlying_symbol: z.string().optional(),
}).transform((v) => {
    return remap$(v, {
        "call_type": "callType",
        "coupon_frequency": "couponFrequency",
        "coupon_rate": "couponRate",
        "coupon_type": "couponType",
        "first_coupon_date": "firstCouponDate",
        "fixed_income_status": "fixedIncomeStatus",
        "fixed_income_subtype": "fixedIncomeSubtype",
        "fixed_income_type": "fixedIncomeType",
        "issue_date": "issueDate",
        "issue_size": "issueSize",
        "last_coupon_date": "lastCouponDate",
        "maturity_date": "maturityDate",
        "next_call_date": "nextCallDate",
        "next_coupon_date": "nextCouponDate",
        "par_value": "parValue",
        "price_at_issuance": "priceAtIssuance",
        "sp_rating": "spRating",
        "sp_rating_date": "spRatingDate",
        "underlying_symbol": "underlyingSymbol",
    });
});
/** @internal */
export const FixedIncome$outboundSchema = z.object({
    callType: CallType$outboundSchema.optional(),
    callable: z.boolean().optional(),
    convertible: z.boolean().optional(),
    couponFrequency: CouponFrequency$outboundSchema.optional(),
    couponRate: z.nullable(z.lazy(() => CouponRate$outboundSchema)).optional(),
    couponType: CouponType$outboundSchema.optional(),
    duration: z.nullable(z.lazy(() => Duration$outboundSchema)).optional(),
    firstCouponDate: z.nullable(z.lazy(() => FirstCouponDate$outboundSchema))
        .optional(),
    fixedIncomeStatus: FixedIncomeStatus$outboundSchema.optional(),
    fixedIncomeSubtype: FixedIncomeSubtype$outboundSchema.optional(),
    fixedIncomeType: FixedIncomeType$outboundSchema.optional(),
    insured: z.boolean().optional(),
    issueDate: z.nullable(z.lazy(() => AssetIssueDate$outboundSchema)).optional(),
    issueSize: z.nullable(z.lazy(() => IssueSize$outboundSchema)).optional(),
    issuer: z.string().optional(),
    lastCouponDate: z.nullable(z.lazy(() => LastCouponDate$outboundSchema))
        .optional(),
    maturityDate: z.nullable(z.lazy(() => MaturityDate$outboundSchema))
        .optional(),
    nextCallDate: z.nullable(z.lazy(() => NextCallDate$outboundSchema))
        .optional(),
    nextCouponDate: z.nullable(z.lazy(() => NextCouponDate$outboundSchema))
        .optional(),
    parValue: z.nullable(z.lazy(() => ParValue$outboundSchema)).optional(),
    perpetual: z.boolean().optional(),
    priceAtIssuance: z.nullable(z.lazy(() => PriceAtIssuance$outboundSchema))
        .optional(),
    spRating: SpRating$outboundSchema.optional(),
    spRatingDate: z.nullable(z.lazy(() => SpRatingDate$outboundSchema))
        .optional(),
    underlyingSymbol: z.string().optional(),
}).transform((v) => {
    return remap$(v, {
        callType: "call_type",
        couponFrequency: "coupon_frequency",
        couponRate: "coupon_rate",
        couponType: "coupon_type",
        firstCouponDate: "first_coupon_date",
        fixedIncomeStatus: "fixed_income_status",
        fixedIncomeSubtype: "fixed_income_subtype",
        fixedIncomeType: "fixed_income_type",
        issueDate: "issue_date",
        issueSize: "issue_size",
        lastCouponDate: "last_coupon_date",
        maturityDate: "maturity_date",
        nextCallDate: "next_call_date",
        nextCouponDate: "next_coupon_date",
        parValue: "par_value",
        priceAtIssuance: "price_at_issuance",
        spRating: "sp_rating",
        spRatingDate: "sp_rating_date",
        underlyingSymbol: "underlying_symbol",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var FixedIncome$;
(function (FixedIncome$) {
    /** @deprecated use `FixedIncome$inboundSchema` instead. */
    FixedIncome$.inboundSchema = FixedIncome$inboundSchema;
    /** @deprecated use `FixedIncome$outboundSchema` instead. */
    FixedIncome$.outboundSchema = FixedIncome$outboundSchema;
})(FixedIncome$ || (FixedIncome$ = {}));
export function fixedIncomeToJSON(fixedIncome) {
    return JSON.stringify(FixedIncome$outboundSchema.parse(fixedIncome));
}
export function fixedIncomeFromJSON(jsonString) {
    return safeParse(jsonString, (x) => FixedIncome$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'FixedIncome' from JSON`);
}
/** @internal */
export const Index$inboundSchema = z
    .object({});
/** @internal */
export const Index$outboundSchema = z.object({});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Index$;
(function (Index$) {
    /** @deprecated use `Index$inboundSchema` instead. */
    Index$.inboundSchema = Index$inboundSchema;
    /** @deprecated use `Index$outboundSchema` instead. */
    Index$.outboundSchema = Index$outboundSchema;
})(Index$ || (Index$ = {}));
export function indexToJSON(index) {
    return JSON.stringify(Index$outboundSchema.parse(index));
}
export function indexFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Index$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Index' from JSON`);
}
/** @internal */
export const LargeOrderNotificationAmount$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const LargeOrderNotificationAmount$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var LargeOrderNotificationAmount$;
(function (LargeOrderNotificationAmount$) {
    /** @deprecated use `LargeOrderNotificationAmount$inboundSchema` instead. */
    LargeOrderNotificationAmount$.inboundSchema = LargeOrderNotificationAmount$inboundSchema;
    /** @deprecated use `LargeOrderNotificationAmount$outboundSchema` instead. */
    LargeOrderNotificationAmount$.outboundSchema = LargeOrderNotificationAmount$outboundSchema;
})(LargeOrderNotificationAmount$ || (LargeOrderNotificationAmount$ = {}));
export function largeOrderNotificationAmountToJSON(largeOrderNotificationAmount) {
    return JSON.stringify(LargeOrderNotificationAmount$outboundSchema.parse(largeOrderNotificationAmount));
}
export function largeOrderNotificationAmountFromJSON(jsonString) {
    return safeParse(jsonString, (x) => LargeOrderNotificationAmount$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'LargeOrderNotificationAmount' from JSON`);
}
/** @internal */
export const MutualFundType$inboundSchema = z
    .union([
    z.nativeEnum(MutualFundType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const MutualFundType$outboundSchema = z.union([
    z.nativeEnum(MutualFundType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var MutualFundType$;
(function (MutualFundType$) {
    /** @deprecated use `MutualFundType$inboundSchema` instead. */
    MutualFundType$.inboundSchema = MutualFundType$inboundSchema;
    /** @deprecated use `MutualFundType$outboundSchema` instead. */
    MutualFundType$.outboundSchema = MutualFundType$outboundSchema;
})(MutualFundType$ || (MutualFundType$ = {}));
/** @internal */
export const MutualFund$inboundSchema = z.object({
    fund_family: z.string().optional(),
    large_order_notification_amount: z.nullable(z.lazy(() => LargeOrderNotificationAmount$inboundSchema)).optional(),
    mutual_fund_type: MutualFundType$inboundSchema.optional(),
    share_class: z.string().optional(),
}).transform((v) => {
    return remap$(v, {
        "fund_family": "fundFamily",
        "large_order_notification_amount": "largeOrderNotificationAmount",
        "mutual_fund_type": "mutualFundType",
        "share_class": "shareClass",
    });
});
/** @internal */
export const MutualFund$outboundSchema = z.object({
    fundFamily: z.string().optional(),
    largeOrderNotificationAmount: z.nullable(z.lazy(() => LargeOrderNotificationAmount$outboundSchema)).optional(),
    mutualFundType: MutualFundType$outboundSchema.optional(),
    shareClass: z.string().optional(),
}).transform((v) => {
    return remap$(v, {
        fundFamily: "fund_family",
        largeOrderNotificationAmount: "large_order_notification_amount",
        mutualFundType: "mutual_fund_type",
        shareClass: "share_class",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var MutualFund$;
(function (MutualFund$) {
    /** @deprecated use `MutualFund$inboundSchema` instead. */
    MutualFund$.inboundSchema = MutualFund$inboundSchema;
    /** @deprecated use `MutualFund$outboundSchema` instead. */
    MutualFund$.outboundSchema = MutualFund$outboundSchema;
})(MutualFund$ || (MutualFund$ = {}));
export function mutualFundToJSON(mutualFund) {
    return JSON.stringify(MutualFund$outboundSchema.parse(mutualFund));
}
export function mutualFundFromJSON(jsonString) {
    return safeParse(jsonString, (x) => MutualFund$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'MutualFund' from JSON`);
}
/** @internal */
export const CallPut$inboundSchema = z
    .union([
    z.nativeEnum(CallPut),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const CallPut$outboundSchema = z.union([
    z.nativeEnum(CallPut),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var CallPut$;
(function (CallPut$) {
    /** @deprecated use `CallPut$inboundSchema` instead. */
    CallPut$.inboundSchema = CallPut$inboundSchema;
    /** @deprecated use `CallPut$outboundSchema` instead. */
    CallPut$.outboundSchema = CallPut$outboundSchema;
})(CallPut$ || (CallPut$ = {}));
/** @internal */
export const ExerciseStyle$inboundSchema = z
    .union([
    z.nativeEnum(ExerciseStyle),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const ExerciseStyle$outboundSchema = z.union([
    z.nativeEnum(ExerciseStyle),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ExerciseStyle$;
(function (ExerciseStyle$) {
    /** @deprecated use `ExerciseStyle$inboundSchema` instead. */
    ExerciseStyle$.inboundSchema = ExerciseStyle$inboundSchema;
    /** @deprecated use `ExerciseStyle$outboundSchema` instead. */
    ExerciseStyle$.outboundSchema = ExerciseStyle$outboundSchema;
})(ExerciseStyle$ || (ExerciseStyle$ = {}));
/** @internal */
export const AssetExpirationDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const AssetExpirationDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AssetExpirationDate$;
(function (AssetExpirationDate$) {
    /** @deprecated use `AssetExpirationDate$inboundSchema` instead. */
    AssetExpirationDate$.inboundSchema = AssetExpirationDate$inboundSchema;
    /** @deprecated use `AssetExpirationDate$outboundSchema` instead. */
    AssetExpirationDate$.outboundSchema = AssetExpirationDate$outboundSchema;
})(AssetExpirationDate$ || (AssetExpirationDate$ = {}));
export function assetExpirationDateToJSON(assetExpirationDate) {
    return JSON.stringify(AssetExpirationDate$outboundSchema.parse(assetExpirationDate));
}
export function assetExpirationDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => AssetExpirationDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'AssetExpirationDate' from JSON`);
}
/** @internal */
export const Classification$inboundSchema = z
    .union([
    z.nativeEnum(Classification),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const Classification$outboundSchema = z.union([
    z.nativeEnum(Classification),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Classification$;
(function (Classification$) {
    /** @deprecated use `Classification$inboundSchema` instead. */
    Classification$.inboundSchema = Classification$inboundSchema;
    /** @deprecated use `Classification$outboundSchema` instead. */
    Classification$.outboundSchema = Classification$outboundSchema;
})(Classification$ || (Classification$ = {}));
/** @internal */
export const PennyPilotIndicator$inboundSchema = z
    .union([
    z.nativeEnum(PennyPilotIndicator),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const PennyPilotIndicator$outboundSchema = z.union([
    z.nativeEnum(PennyPilotIndicator),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var PennyPilotIndicator$;
(function (PennyPilotIndicator$) {
    /** @deprecated use `PennyPilotIndicator$inboundSchema` instead. */
    PennyPilotIndicator$.inboundSchema = PennyPilotIndicator$inboundSchema;
    /** @deprecated use `PennyPilotIndicator$outboundSchema` instead. */
    PennyPilotIndicator$.outboundSchema = PennyPilotIndicator$outboundSchema;
})(PennyPilotIndicator$ || (PennyPilotIndicator$ = {}));
/** @internal */
export const PositionLimit$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const PositionLimit$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var PositionLimit$;
(function (PositionLimit$) {
    /** @deprecated use `PositionLimit$inboundSchema` instead. */
    PositionLimit$.inboundSchema = PositionLimit$inboundSchema;
    /** @deprecated use `PositionLimit$outboundSchema` instead. */
    PositionLimit$.outboundSchema = PositionLimit$outboundSchema;
})(PositionLimit$ || (PositionLimit$ = {}));
export function positionLimitToJSON(positionLimit) {
    return JSON.stringify(PositionLimit$outboundSchema.parse(positionLimit));
}
export function positionLimitFromJSON(jsonString) {
    return safeParse(jsonString, (x) => PositionLimit$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'PositionLimit' from JSON`);
}
/** @internal */
export const SettlementStyle$inboundSchema = z
    .union([
    z.nativeEnum(SettlementStyle),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const SettlementStyle$outboundSchema = z.union([
    z.nativeEnum(SettlementStyle),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var SettlementStyle$;
(function (SettlementStyle$) {
    /** @deprecated use `SettlementStyle$inboundSchema` instead. */
    SettlementStyle$.inboundSchema = SettlementStyle$inboundSchema;
    /** @deprecated use `SettlementStyle$outboundSchema` instead. */
    SettlementStyle$.outboundSchema = SettlementStyle$outboundSchema;
})(SettlementStyle$ || (SettlementStyle$ = {}));
/** @internal */
export const StrikeMultiplier$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const StrikeMultiplier$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var StrikeMultiplier$;
(function (StrikeMultiplier$) {
    /** @deprecated use `StrikeMultiplier$inboundSchema` instead. */
    StrikeMultiplier$.inboundSchema = StrikeMultiplier$inboundSchema;
    /** @deprecated use `StrikeMultiplier$outboundSchema` instead. */
    StrikeMultiplier$.outboundSchema = StrikeMultiplier$outboundSchema;
})(StrikeMultiplier$ || (StrikeMultiplier$ = {}));
export function strikeMultiplierToJSON(strikeMultiplier) {
    return JSON.stringify(StrikeMultiplier$outboundSchema.parse(strikeMultiplier));
}
export function strikeMultiplierFromJSON(jsonString) {
    return safeParse(jsonString, (x) => StrikeMultiplier$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'StrikeMultiplier' from JSON`);
}
/** @internal */
export const StrikePriceMultiplier$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const StrikePriceMultiplier$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var StrikePriceMultiplier$;
(function (StrikePriceMultiplier$) {
    /** @deprecated use `StrikePriceMultiplier$inboundSchema` instead. */
    StrikePriceMultiplier$.inboundSchema = StrikePriceMultiplier$inboundSchema;
    /** @deprecated use `StrikePriceMultiplier$outboundSchema` instead. */
    StrikePriceMultiplier$.outboundSchema = StrikePriceMultiplier$outboundSchema;
})(StrikePriceMultiplier$ || (StrikePriceMultiplier$ = {}));
export function strikePriceMultiplierToJSON(strikePriceMultiplier) {
    return JSON.stringify(StrikePriceMultiplier$outboundSchema.parse(strikePriceMultiplier));
}
export function strikePriceMultiplierFromJSON(jsonString) {
    return safeParse(jsonString, (x) => StrikePriceMultiplier$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'StrikePriceMultiplier' from JSON`);
}
/** @internal */
export const TradeValueMultiplier$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const TradeValueMultiplier$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var TradeValueMultiplier$;
(function (TradeValueMultiplier$) {
    /** @deprecated use `TradeValueMultiplier$inboundSchema` instead. */
    TradeValueMultiplier$.inboundSchema = TradeValueMultiplier$inboundSchema;
    /** @deprecated use `TradeValueMultiplier$outboundSchema` instead. */
    TradeValueMultiplier$.outboundSchema = TradeValueMultiplier$outboundSchema;
})(TradeValueMultiplier$ || (TradeValueMultiplier$ = {}));
export function tradeValueMultiplierToJSON(tradeValueMultiplier) {
    return JSON.stringify(TradeValueMultiplier$outboundSchema.parse(tradeValueMultiplier));
}
export function tradeValueMultiplierFromJSON(jsonString) {
    return safeParse(jsonString, (x) => TradeValueMultiplier$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'TradeValueMultiplier' from JSON`);
}
/** @internal */
export const OptionRoot$inboundSchema = z.object({
    classification: Classification$inboundSchema.optional(),
    deliverables: z.array(OptionDeliverable$inboundSchema).optional(),
    penny_pilot_indicator: PennyPilotIndicator$inboundSchema.optional(),
    position_limit: z.nullable(z.lazy(() => PositionLimit$inboundSchema))
        .optional(),
    root_symbol: z.string().optional(),
    settlement_style: SettlementStyle$inboundSchema.optional(),
    strike_multiplier: z.nullable(z.lazy(() => StrikeMultiplier$inboundSchema))
        .optional(),
    strike_price_multiplier: z.nullable(z.lazy(() => StrikePriceMultiplier$inboundSchema)).optional(),
    trade_value_multiplier: z.nullable(z.lazy(() => TradeValueMultiplier$inboundSchema)).optional(),
}).transform((v) => {
    return remap$(v, {
        "penny_pilot_indicator": "pennyPilotIndicator",
        "position_limit": "positionLimit",
        "root_symbol": "rootSymbol",
        "settlement_style": "settlementStyle",
        "strike_multiplier": "strikeMultiplier",
        "strike_price_multiplier": "strikePriceMultiplier",
        "trade_value_multiplier": "tradeValueMultiplier",
    });
});
/** @internal */
export const OptionRoot$outboundSchema = z.object({
    classification: Classification$outboundSchema.optional(),
    deliverables: z.array(OptionDeliverable$outboundSchema).optional(),
    pennyPilotIndicator: PennyPilotIndicator$outboundSchema.optional(),
    positionLimit: z.nullable(z.lazy(() => PositionLimit$outboundSchema))
        .optional(),
    rootSymbol: z.string().optional(),
    settlementStyle: SettlementStyle$outboundSchema.optional(),
    strikeMultiplier: z.nullable(z.lazy(() => StrikeMultiplier$outboundSchema))
        .optional(),
    strikePriceMultiplier: z.nullable(z.lazy(() => StrikePriceMultiplier$outboundSchema)).optional(),
    tradeValueMultiplier: z.nullable(z.lazy(() => TradeValueMultiplier$outboundSchema)).optional(),
}).transform((v) => {
    return remap$(v, {
        pennyPilotIndicator: "penny_pilot_indicator",
        positionLimit: "position_limit",
        rootSymbol: "root_symbol",
        settlementStyle: "settlement_style",
        strikeMultiplier: "strike_multiplier",
        strikePriceMultiplier: "strike_price_multiplier",
        tradeValueMultiplier: "trade_value_multiplier",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OptionRoot$;
(function (OptionRoot$) {
    /** @deprecated use `OptionRoot$inboundSchema` instead. */
    OptionRoot$.inboundSchema = OptionRoot$inboundSchema;
    /** @deprecated use `OptionRoot$outboundSchema` instead. */
    OptionRoot$.outboundSchema = OptionRoot$outboundSchema;
})(OptionRoot$ || (OptionRoot$ = {}));
export function optionRootToJSON(optionRoot) {
    return JSON.stringify(OptionRoot$outboundSchema.parse(optionRoot));
}
export function optionRootFromJSON(jsonString) {
    return safeParse(jsonString, (x) => OptionRoot$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'OptionRoot' from JSON`);
}
/** @internal */
export const OptionType$inboundSchema = z
    .union([
    z.nativeEnum(OptionType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const OptionType$outboundSchema = z.union([
    z.nativeEnum(OptionType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var OptionType$;
(function (OptionType$) {
    /** @deprecated use `OptionType$inboundSchema` instead. */
    OptionType$.inboundSchema = OptionType$inboundSchema;
    /** @deprecated use `OptionType$outboundSchema` instead. */
    OptionType$.outboundSchema = OptionType$outboundSchema;
})(OptionType$ || (OptionType$ = {}));
/** @internal */
export const SeriesDate$inboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/** @internal */
export const SeriesDate$outboundSchema = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var SeriesDate$;
(function (SeriesDate$) {
    /** @deprecated use `SeriesDate$inboundSchema` instead. */
    SeriesDate$.inboundSchema = SeriesDate$inboundSchema;
    /** @deprecated use `SeriesDate$outboundSchema` instead. */
    SeriesDate$.outboundSchema = SeriesDate$outboundSchema;
})(SeriesDate$ || (SeriesDate$ = {}));
export function seriesDateToJSON(seriesDate) {
    return JSON.stringify(SeriesDate$outboundSchema.parse(seriesDate));
}
export function seriesDateFromJSON(jsonString) {
    return safeParse(jsonString, (x) => SeriesDate$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'SeriesDate' from JSON`);
}
/** @internal */
export const SettlementMethod$inboundSchema = z
    .union([
    z.nativeEnum(SettlementMethod),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const SettlementMethod$outboundSchema = z.union([
    z.nativeEnum(SettlementMethod),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var SettlementMethod$;
(function (SettlementMethod$) {
    /** @deprecated use `SettlementMethod$inboundSchema` instead. */
    SettlementMethod$.inboundSchema = SettlementMethod$inboundSchema;
    /** @deprecated use `SettlementMethod$outboundSchema` instead. */
    SettlementMethod$.outboundSchema = SettlementMethod$outboundSchema;
})(SettlementMethod$ || (SettlementMethod$ = {}));
/** @internal */
export const SettlementType$inboundSchema = z
    .union([
    z.nativeEnum(SettlementType),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const SettlementType$outboundSchema = z.union([
    z.nativeEnum(SettlementType),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var SettlementType$;
(function (SettlementType$) {
    /** @deprecated use `SettlementType$inboundSchema` instead. */
    SettlementType$.inboundSchema = SettlementType$inboundSchema;
    /** @deprecated use `SettlementType$outboundSchema` instead. */
    SettlementType$.outboundSchema = SettlementType$outboundSchema;
})(SettlementType$ || (SettlementType$ = {}));
/** @internal */
export const StrikePrice$inboundSchema = z.object({
    value: z.string().optional(),
});
/** @internal */
export const StrikePrice$outboundSchema = z.object({
    value: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var StrikePrice$;
(function (StrikePrice$) {
    /** @deprecated use `StrikePrice$inboundSchema` instead. */
    StrikePrice$.inboundSchema = StrikePrice$inboundSchema;
    /** @deprecated use `StrikePrice$outboundSchema` instead. */
    StrikePrice$.outboundSchema = StrikePrice$outboundSchema;
})(StrikePrice$ || (StrikePrice$ = {}));
export function strikePriceToJSON(strikePrice) {
    return JSON.stringify(StrikePrice$outboundSchema.parse(strikePrice));
}
export function strikePriceFromJSON(jsonString) {
    return safeParse(jsonString, (x) => StrikePrice$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'StrikePrice' from JSON`);
}
/** @internal */
export const Option$inboundSchema = z
    .object({
    call_put: CallPut$inboundSchema.optional(),
    exercise_style: ExerciseStyle$inboundSchema.optional(),
    expiration_date: z.nullable(z.lazy(() => AssetExpirationDate$inboundSchema))
        .optional(),
    option_root: z.nullable(z.lazy(() => OptionRoot$inboundSchema)).optional(),
    option_type: OptionType$inboundSchema.optional(),
    root_symbol: z.string().optional(),
    series_date: z.nullable(z.lazy(() => SeriesDate$inboundSchema)).optional(),
    settlement_method: SettlementMethod$inboundSchema.optional(),
    settlement_type: SettlementType$inboundSchema.optional(),
    strike_price: z.nullable(z.lazy(() => StrikePrice$inboundSchema))
        .optional(),
}).transform((v) => {
    return remap$(v, {
        "call_put": "callPut",
        "exercise_style": "exerciseStyle",
        "expiration_date": "expirationDate",
        "option_root": "optionRoot",
        "option_type": "optionType",
        "root_symbol": "rootSymbol",
        "series_date": "seriesDate",
        "settlement_method": "settlementMethod",
        "settlement_type": "settlementType",
        "strike_price": "strikePrice",
    });
});
/** @internal */
export const Option$outboundSchema = z.object({
    callPut: CallPut$outboundSchema.optional(),
    exerciseStyle: ExerciseStyle$outboundSchema.optional(),
    expirationDate: z.nullable(z.lazy(() => AssetExpirationDate$outboundSchema))
        .optional(),
    optionRoot: z.nullable(z.lazy(() => OptionRoot$outboundSchema)).optional(),
    optionType: OptionType$outboundSchema.optional(),
    rootSymbol: z.string().optional(),
    seriesDate: z.nullable(z.lazy(() => SeriesDate$outboundSchema)).optional(),
    settlementMethod: SettlementMethod$outboundSchema.optional(),
    settlementType: SettlementType$outboundSchema.optional(),
    strikePrice: z.nullable(z.lazy(() => StrikePrice$outboundSchema)).optional(),
}).transform((v) => {
    return remap$(v, {
        callPut: "call_put",
        exerciseStyle: "exercise_style",
        expirationDate: "expiration_date",
        optionRoot: "option_root",
        optionType: "option_type",
        rootSymbol: "root_symbol",
        seriesDate: "series_date",
        settlementMethod: "settlement_method",
        settlementType: "settlement_type",
        strikePrice: "strike_price",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Option$;
(function (Option$) {
    /** @deprecated use `Option$inboundSchema` instead. */
    Option$.inboundSchema = Option$inboundSchema;
    /** @deprecated use `Option$outboundSchema` instead. */
    Option$.outboundSchema = Option$outboundSchema;
})(Option$ || (Option$ = {}));
export function optionToJSON(option) {
    return JSON.stringify(Option$outboundSchema.parse(option));
}
export function optionFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Option$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Option' from JSON`);
}
/** @internal */
export const AssetType1$inboundSchema = z
    .union([
    z.nativeEnum(AssetType1),
    z.string().transform(catchUnrecognizedEnum),
]);
/** @internal */
export const AssetType1$outboundSchema = z.union([
    z.nativeEnum(AssetType1),
    z.string().and(z.custom()),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AssetType1$;
(function (AssetType1$) {
    /** @deprecated use `AssetType1$inboundSchema` instead. */
    AssetType1$.inboundSchema = AssetType1$inboundSchema;
    /** @deprecated use `AssetType1$outboundSchema` instead. */
    AssetType1$.outboundSchema = AssetType1$outboundSchema;
})(AssetType1$ || (AssetType1$ = {}));
/** @internal */
export const Asset$inboundSchema = z
    .object({
    asset_id: z.string().optional(),
    currency: z.nullable(z.lazy(() => Currency$inboundSchema)).optional(),
    cusip: z.string().optional(),
    description: z.string().optional(),
    equity: z.nullable(z.lazy(() => Equity$inboundSchema)).optional(),
    fixed_income: z.nullable(z.lazy(() => FixedIncome$inboundSchema))
        .optional(),
    index: z.nullable(z.lazy(() => Index$inboundSchema)).optional(),
    isin: z.string().optional(),
    issuing_region_code: z.string().optional(),
    mutual_fund: z.nullable(z.lazy(() => MutualFund$inboundSchema)).optional(),
    name: z.string().optional(),
    option: z.nullable(z.lazy(() => Option$inboundSchema)).optional(),
    originating_region_code: z.string().optional(),
    symbol: z.string().optional(),
    type: AssetType1$inboundSchema.optional(),
    usable: z.boolean().optional(),
}).transform((v) => {
    return remap$(v, {
        "asset_id": "assetId",
        "fixed_income": "fixedIncome",
        "issuing_region_code": "issuingRegionCode",
        "mutual_fund": "mutualFund",
        "originating_region_code": "originatingRegionCode",
    });
});
/** @internal */
export const Asset$outboundSchema = z.object({
    assetId: z.string().optional(),
    currency: z.nullable(z.lazy(() => Currency$outboundSchema)).optional(),
    cusip: z.string().optional(),
    description: z.string().optional(),
    equity: z.nullable(z.lazy(() => Equity$outboundSchema)).optional(),
    fixedIncome: z.nullable(z.lazy(() => FixedIncome$outboundSchema)).optional(),
    index: z.nullable(z.lazy(() => Index$outboundSchema)).optional(),
    isin: z.string().optional(),
    issuingRegionCode: z.string().optional(),
    mutualFund: z.nullable(z.lazy(() => MutualFund$outboundSchema)).optional(),
    name: z.string().optional(),
    option: z.nullable(z.lazy(() => Option$outboundSchema)).optional(),
    originatingRegionCode: z.string().optional(),
    symbol: z.string().optional(),
    type: AssetType1$outboundSchema.optional(),
    usable: z.boolean().optional(),
}).transform((v) => {
    return remap$(v, {
        assetId: "asset_id",
        fixedIncome: "fixed_income",
        issuingRegionCode: "issuing_region_code",
        mutualFund: "mutual_fund",
        originatingRegionCode: "originating_region_code",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Asset$;
(function (Asset$) {
    /** @deprecated use `Asset$inboundSchema` instead. */
    Asset$.inboundSchema = Asset$inboundSchema;
    /** @deprecated use `Asset$outboundSchema` instead. */
    Asset$.outboundSchema = Asset$outboundSchema;
})(Asset$ || (Asset$ = {}));
export function assetToJSON(asset) {
    return JSON.stringify(Asset$outboundSchema.parse(asset));
}
export function assetFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Asset$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Asset' from JSON`);
}
//# sourceMappingURL=asset.js.map