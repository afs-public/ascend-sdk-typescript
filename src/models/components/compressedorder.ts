/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import {
  ExecutedPrice,
  ExecutedPrice$inboundSchema,
  ExecutedPrice$Outbound,
  ExecutedPrice$outboundSchema,
} from "./executedprice.js";
import {
  Executions,
  Executions$inboundSchema,
  Executions$Outbound,
  Executions$outboundSchema,
} from "./executions.js";
import {
  Fee,
  Fee$inboundSchema,
  Fee$Outbound,
  Fee$outboundSchema,
} from "./fee.js";

/**
 * The type of the asset in this order
 */
export enum CompressedOrderAssetType {
  AssetTypeUnspecified = "ASSET_TYPE_UNSPECIFIED",
  Equity = "EQUITY",
  MutualFund = "MUTUAL_FUND",
}
/**
 * The type of the asset in this order
 */
export type CompressedOrderAssetTypeOpen = OpenEnum<
  typeof CompressedOrderAssetType
>;

/**
 * The product of order quantity & price, summed across all fills, reported in the currency specified in the order. (This will be rounded to 2 decimal places for USD currencies). Will be absent if an order has no fill information.
 */
export type CompressedOrderCumulativeNotionalValue = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The summed quantity value across all fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no fill information.
 */
export type CompressedOrderFilledQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The identifier type of the asset being ordered. For Equities: only SYMBOL is supported
 */
export enum CompressedOrderIdentifierType {
  Symbol = "SYMBOL",
  Cusip = "CUSIP",
  Isin = "ISIN",
}
/**
 * The identifier type of the asset being ordered. For Equities: only SYMBOL is supported
 */
export type CompressedOrderIdentifierTypeOpen = OpenEnum<
  typeof CompressedOrderIdentifierType
>;

/**
 * The amount of the LOI. This is a monetary value in the same currency as the order.
 */
export type CompressedOrderAmount = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The period start date, specific to the US Eastern Time Zone, of the LOI. Date range: 90 days in the past and 13 months in the future from the order_date.
 */
export type CompressedOrderPeriodStartDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Letter of Intent (LOI). An LOI allows investors to receive sales charge discounts based on a commitment to buy a specified monetary amount of shares over a period of time, usually 13 months. Either ROA or LOI may be specified, but not both.
 */
export type CompressedOrderLetterOfIntent = {
  /**
   * The amount of the LOI. This is a monetary value in the same currency as the order.
   */
  amount?: CompressedOrderAmount | null | undefined;
  /**
   * The period start date, specific to the US Eastern Time Zone, of the LOI. Date range: 90 days in the past and 13 months in the future from the order_date.
   */
  periodStartDate?: CompressedOrderPeriodStartDate | null | undefined;
};

/**
 * Notional quantity of the order, measured in USD. Maximum 2 decimal place precision. Either a quantity or notional_value MUST be specified (but not both). For Equities: currently not supported yet For Mutual Funds: Only supported for BUY orders. The order will be transacted at the full notional amount specified.
 */
export type CompressedOrderNotionalValue = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * When an order has the REJECTED status, this will be populated with a system code describing the rejection.
 */
export enum CompressedOrderOrderRejectedReason {
  OrderRejectReasonUnspecified = "ORDER_REJECT_REASON_UNSPECIFIED",
  BrokerOption = "BROKER_OPTION",
  UnknownSecurity = "UNKNOWN_SECURITY",
  ExchangeClosed = "EXCHANGE_CLOSED",
  TooLateToEnter = "TOO_LATE_TO_ENTER",
  UnknownOrder = "UNKNOWN_ORDER",
  DuplicateOrder = "DUPLICATE_ORDER",
  StaleOrder = "STALE_ORDER",
  BelowNotionalMinimum = "BELOW_NOTIONAL_MINIMUM",
  AccountNotEntitled = "ACCOUNT_NOT_ENTITLED",
  SystemError = "SYSTEM_ERROR",
  BlockingCorporateAction = "BLOCKING_CORPORATE_ACTION",
  UnavailablePriceQuote = "UNAVAILABLE_PRICE_QUOTE",
  ExecutionMisconfiguredClient = "EXECUTION_MISCONFIGURED_CLIENT",
  FractionalQuantityNotAllowedForSecurity =
    "FRACTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY",
  OnlyFractionalSellOrWholeOrdersAllowedForSecurity =
    "ONLY_FRACTIONAL_SELL_OR_WHOLE_ORDERS_ALLOWED_FOR_SECURITY",
  SymbolNotTradeable = "SYMBOL_NOT_TRADEABLE",
  AboveNotionalMaximum = "ABOVE_NOTIONAL_MAXIMUM",
  AboveShareMaximum = "ABOVE_SHARE_MAXIMUM",
  MaxSellQuantityRequired = "MAX_SELL_QUANTITY_REQUIRED",
  MaxSellQuantityProhibited = "MAX_SELL_QUANTITY_PROHIBITED",
  StockTradesDisabled = "STOCK_TRADES_DISABLED",
  AssetNotSetUpToTrade = "ASSET_NOT_SET_UP_TO_TRADE",
  AnotherBasketOrderForAccountHasFailedRiskChecks =
    "ANOTHER_BASKET_ORDER_FOR_ACCOUNT_HAS_FAILED_RISK_CHECKS",
}
/**
 * When an order has the REJECTED status, this will be populated with a system code describing the rejection.
 */
export type CompressedOrderOrderRejectedReasonOpen = OpenEnum<
  typeof CompressedOrderOrderRejectedReason
>;

/**
 * The processing status of the order
 */
export enum CompressedOrderOrderStatus {
  OrderStatusUnspecified = "ORDER_STATUS_UNSPECIFIED",
  PendingNew = "PENDING_NEW",
  New = "NEW",
  PartiallyFilled = "PARTIALLY_FILLED",
  Filled = "FILLED",
  Rejected = "REJECTED",
}
/**
 * The processing status of the order
 */
export type CompressedOrderOrderStatusOpen = OpenEnum<
  typeof CompressedOrderOrderStatus
>;

/**
 * The execution type of this order. Only MARKET is supported.
 */
export enum CompressedOrderOrderType {
  OrderTypeUnspecified = "ORDER_TYPE_UNSPECIFIED",
  Market = "MARKET",
}
/**
 * The execution type of this order. Only MARKET is supported.
 */
export type CompressedOrderOrderTypeOpen = OpenEnum<
  typeof CompressedOrderOrderType
>;

/**
 * Numeric quantity of the order. Either a quantity or notional_value MUST be specified (but not both). For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places. For Mutual Funds: Only supported for SELL orders. Represents the number of shares, up to a maximum of 3 decimal places.
 */
export type CompressedOrderQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The amount of the ROA. This is a monetary value in the same currency as the order. Only 9999999.99 is supported.
 */
export type CompressedOrderRightsOfAccumulationAmount = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Rights of Accumulation (ROA). An ROA allows an investor to aggregate their own fund shares with the holdings of certain related parties toward achieving the investment thresholds at which sales charge discounts become available. Either ROA or LOI may be specified, but not both.
 */
export type CompressedOrderRightsOfAccumulation = {
  /**
   * The amount of the ROA. This is a monetary value in the same currency as the order. Only 9999999.99 is supported.
   */
  amount?: CompressedOrderRightsOfAccumulationAmount | null | undefined;
};

/**
 * The side of this order.
 */
export enum CompressedOrderSide {
  SideUnspecified = "SIDE_UNSPECIFIED",
  Buy = "BUY",
  Sell = "SELL",
}
/**
 * The side of this order.
 */
export type CompressedOrderSideOpen = OpenEnum<typeof CompressedOrderSide>;

/**
 * Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
 */
export enum CompressedOrderTimeInForce {
  TimeInForceUnspecified = "TIME_IN_FORCE_UNSPECIFIED",
  Day = "DAY",
}
/**
 * Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
 */
export type CompressedOrderTimeInForceOpen = OpenEnum<
  typeof CompressedOrderTimeInForce
>;

/**
 * The message describing an orders that have been compressed into a single order
 */
export type CompressedOrder = {
  /**
   * Apex Asset ID for this asset. This will not be returned in the initial CreateOrder response and will be available after an order completes validation. If the provided identifier does not match any Apex asset available for trading, an OrderRejectReason of "UNKNOWN_SECURITY" will be returned and the asset_id will not be set.
   */
  assetId?: string | undefined;
  /**
   * The type of the asset in this order
   */
  assetType?: CompressedOrderAssetTypeOpen | undefined;
  /**
   * The identifier of the account transacting this order
   */
  averagePriceAccountId?: string | undefined;
  /**
   * The average prices, as weighted averages, across all executions in this order. Will be absent if an order has no executions.
   *
   * @remarks
   *
   *  When asset_type = EQUITY, there will be at most one value present, with a type of PRICE_PER_UNIT. This will have up to 4 decimal places for USD amounts less than $1, and a maximum of two for larger USD amounts.
   */
  averagePrices?: Array<ExecutedPrice> | undefined;
  /**
   * System generated unique id for the compressed order.
   */
  compressedOrderId?: string | undefined;
  /**
   * Time of the order creation
   */
  createTime?: Date | null | undefined;
  /**
   * The product of order quantity & price, summed across all fills, reported in the currency specified in the order. (This will be rounded to 2 decimal places for USD currencies). Will be absent if an order has no fill information.
   */
  cumulativeNotionalValue?:
    | CompressedOrderCumulativeNotionalValue
    | null
    | undefined;
  /**
   * Defaults to "USD". Only "USD" is supported. Full list of currency codes is defined at: https://en.wikipedia.org/wiki/ISO_4217
   */
  currencyCode?: string | undefined;
  /**
   * The execution-level details that compose this order
   */
  executions?: Array<Executions> | undefined;
  /**
   * Fees that will be applied to this order.
   */
  fees?: Array<Fee> | undefined;
  /**
   * The summed quantity value across all fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no fill information.
   */
  filledQuantity?: CompressedOrderFilledQuantity | null | undefined;
  /**
   * Identifier of the asset (of the type specified in `identifier_type`).
   */
  identifier?: string | undefined;
  /**
   * The identifier type of the asset being ordered. For Equities: only SYMBOL is supported
   */
  identifierType?: CompressedOrderIdentifierTypeOpen | undefined;
  /**
   * Time of the last order update
   */
  lastUpdateTime?: Date | null | undefined;
  /**
   * Letter of Intent (LOI). An LOI allows investors to receive sales charge discounts based on a commitment to buy a specified monetary amount of shares over a period of time, usually 13 months. Either ROA or LOI may be specified, but not both.
   */
  letterOfIntent?: CompressedOrderLetterOfIntent | null | undefined;
  /**
   * System generated name of the order.
   */
  name?: string | undefined;
  /**
   * Notional quantity of the order, measured in USD. Maximum 2 decimal place precision. Either a quantity or notional_value MUST be specified (but not both). For Equities: currently not supported yet For Mutual Funds: Only supported for BUY orders. The order will be transacted at the full notional amount specified.
   */
  notionalValue?: CompressedOrderNotionalValue | null | undefined;
  /**
   * When an order has the REJECTED status, this will be populated with a system code describing the rejection.
   */
  orderRejectedReason?: CompressedOrderOrderRejectedReasonOpen | undefined;
  /**
   * The processing status of the order
   */
  orderStatus?: CompressedOrderOrderStatusOpen | undefined;
  /**
   * The execution type of this order. Only MARKET is supported.
   */
  orderType?: CompressedOrderOrderTypeOpen | undefined;
  /**
   * Numeric quantity of the order. Either a quantity or notional_value MUST be specified (but not both). For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places. For Mutual Funds: Only supported for SELL orders. Represents the number of shares, up to a maximum of 3 decimal places.
   */
  quantity?: CompressedOrderQuantity | null | undefined;
  /**
   * Rights of Accumulation (ROA). An ROA allows an investor to aggregate their own fund shares with the holdings of certain related parties toward achieving the investment thresholds at which sales charge discounts become available. Either ROA or LOI may be specified, but not both.
   */
  rightsOfAccumulation?: CompressedOrderRightsOfAccumulation | null | undefined;
  /**
   * The side of this order.
   */
  side?: CompressedOrderSideOpen | undefined;
  /**
   * Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
   */
  timeInForce?: CompressedOrderTimeInForceOpen | undefined;
};

/** @internal */
export const CompressedOrderAssetType$inboundSchema: z.ZodType<
  CompressedOrderAssetTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CompressedOrderAssetType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CompressedOrderAssetType$outboundSchema: z.ZodType<
  CompressedOrderAssetTypeOpen,
  z.ZodTypeDef,
  CompressedOrderAssetTypeOpen
> = z.union([
  z.nativeEnum(CompressedOrderAssetType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderAssetType$ {
  /** @deprecated use `CompressedOrderAssetType$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderAssetType$inboundSchema;
  /** @deprecated use `CompressedOrderAssetType$outboundSchema` instead. */
  export const outboundSchema = CompressedOrderAssetType$outboundSchema;
}

/** @internal */
export const CompressedOrderCumulativeNotionalValue$inboundSchema: z.ZodType<
  CompressedOrderCumulativeNotionalValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type CompressedOrderCumulativeNotionalValue$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const CompressedOrderCumulativeNotionalValue$outboundSchema: z.ZodType<
  CompressedOrderCumulativeNotionalValue$Outbound,
  z.ZodTypeDef,
  CompressedOrderCumulativeNotionalValue
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderCumulativeNotionalValue$ {
  /** @deprecated use `CompressedOrderCumulativeNotionalValue$inboundSchema` instead. */
  export const inboundSchema =
    CompressedOrderCumulativeNotionalValue$inboundSchema;
  /** @deprecated use `CompressedOrderCumulativeNotionalValue$outboundSchema` instead. */
  export const outboundSchema =
    CompressedOrderCumulativeNotionalValue$outboundSchema;
  /** @deprecated use `CompressedOrderCumulativeNotionalValue$Outbound` instead. */
  export type Outbound = CompressedOrderCumulativeNotionalValue$Outbound;
}

/** @internal */
export const CompressedOrderFilledQuantity$inboundSchema: z.ZodType<
  CompressedOrderFilledQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type CompressedOrderFilledQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const CompressedOrderFilledQuantity$outboundSchema: z.ZodType<
  CompressedOrderFilledQuantity$Outbound,
  z.ZodTypeDef,
  CompressedOrderFilledQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderFilledQuantity$ {
  /** @deprecated use `CompressedOrderFilledQuantity$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderFilledQuantity$inboundSchema;
  /** @deprecated use `CompressedOrderFilledQuantity$outboundSchema` instead. */
  export const outboundSchema = CompressedOrderFilledQuantity$outboundSchema;
  /** @deprecated use `CompressedOrderFilledQuantity$Outbound` instead. */
  export type Outbound = CompressedOrderFilledQuantity$Outbound;
}

/** @internal */
export const CompressedOrderIdentifierType$inboundSchema: z.ZodType<
  CompressedOrderIdentifierTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CompressedOrderIdentifierType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CompressedOrderIdentifierType$outboundSchema: z.ZodType<
  CompressedOrderIdentifierTypeOpen,
  z.ZodTypeDef,
  CompressedOrderIdentifierTypeOpen
> = z.union([
  z.nativeEnum(CompressedOrderIdentifierType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderIdentifierType$ {
  /** @deprecated use `CompressedOrderIdentifierType$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderIdentifierType$inboundSchema;
  /** @deprecated use `CompressedOrderIdentifierType$outboundSchema` instead. */
  export const outboundSchema = CompressedOrderIdentifierType$outboundSchema;
}

/** @internal */
export const CompressedOrderAmount$inboundSchema: z.ZodType<
  CompressedOrderAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type CompressedOrderAmount$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const CompressedOrderAmount$outboundSchema: z.ZodType<
  CompressedOrderAmount$Outbound,
  z.ZodTypeDef,
  CompressedOrderAmount
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderAmount$ {
  /** @deprecated use `CompressedOrderAmount$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderAmount$inboundSchema;
  /** @deprecated use `CompressedOrderAmount$outboundSchema` instead. */
  export const outboundSchema = CompressedOrderAmount$outboundSchema;
  /** @deprecated use `CompressedOrderAmount$Outbound` instead. */
  export type Outbound = CompressedOrderAmount$Outbound;
}

/** @internal */
export const CompressedOrderPeriodStartDate$inboundSchema: z.ZodType<
  CompressedOrderPeriodStartDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type CompressedOrderPeriodStartDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const CompressedOrderPeriodStartDate$outboundSchema: z.ZodType<
  CompressedOrderPeriodStartDate$Outbound,
  z.ZodTypeDef,
  CompressedOrderPeriodStartDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderPeriodStartDate$ {
  /** @deprecated use `CompressedOrderPeriodStartDate$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderPeriodStartDate$inboundSchema;
  /** @deprecated use `CompressedOrderPeriodStartDate$outboundSchema` instead. */
  export const outboundSchema = CompressedOrderPeriodStartDate$outboundSchema;
  /** @deprecated use `CompressedOrderPeriodStartDate$Outbound` instead. */
  export type Outbound = CompressedOrderPeriodStartDate$Outbound;
}

/** @internal */
export const CompressedOrderLetterOfIntent$inboundSchema: z.ZodType<
  CompressedOrderLetterOfIntent,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.nullable(z.lazy(() => CompressedOrderAmount$inboundSchema))
    .optional(),
  period_start_date: z.nullable(
    z.lazy(() => CompressedOrderPeriodStartDate$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "period_start_date": "periodStartDate",
  });
});

/** @internal */
export type CompressedOrderLetterOfIntent$Outbound = {
  amount?: CompressedOrderAmount$Outbound | null | undefined;
  period_start_date?:
    | CompressedOrderPeriodStartDate$Outbound
    | null
    | undefined;
};

/** @internal */
export const CompressedOrderLetterOfIntent$outboundSchema: z.ZodType<
  CompressedOrderLetterOfIntent$Outbound,
  z.ZodTypeDef,
  CompressedOrderLetterOfIntent
> = z.object({
  amount: z.nullable(z.lazy(() => CompressedOrderAmount$outboundSchema))
    .optional(),
  periodStartDate: z.nullable(
    z.lazy(() => CompressedOrderPeriodStartDate$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    periodStartDate: "period_start_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderLetterOfIntent$ {
  /** @deprecated use `CompressedOrderLetterOfIntent$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderLetterOfIntent$inboundSchema;
  /** @deprecated use `CompressedOrderLetterOfIntent$outboundSchema` instead. */
  export const outboundSchema = CompressedOrderLetterOfIntent$outboundSchema;
  /** @deprecated use `CompressedOrderLetterOfIntent$Outbound` instead. */
  export type Outbound = CompressedOrderLetterOfIntent$Outbound;
}

/** @internal */
export const CompressedOrderNotionalValue$inboundSchema: z.ZodType<
  CompressedOrderNotionalValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type CompressedOrderNotionalValue$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const CompressedOrderNotionalValue$outboundSchema: z.ZodType<
  CompressedOrderNotionalValue$Outbound,
  z.ZodTypeDef,
  CompressedOrderNotionalValue
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderNotionalValue$ {
  /** @deprecated use `CompressedOrderNotionalValue$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderNotionalValue$inboundSchema;
  /** @deprecated use `CompressedOrderNotionalValue$outboundSchema` instead. */
  export const outboundSchema = CompressedOrderNotionalValue$outboundSchema;
  /** @deprecated use `CompressedOrderNotionalValue$Outbound` instead. */
  export type Outbound = CompressedOrderNotionalValue$Outbound;
}

/** @internal */
export const CompressedOrderOrderRejectedReason$inboundSchema: z.ZodType<
  CompressedOrderOrderRejectedReasonOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CompressedOrderOrderRejectedReason),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CompressedOrderOrderRejectedReason$outboundSchema: z.ZodType<
  CompressedOrderOrderRejectedReasonOpen,
  z.ZodTypeDef,
  CompressedOrderOrderRejectedReasonOpen
> = z.union([
  z.nativeEnum(CompressedOrderOrderRejectedReason),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderOrderRejectedReason$ {
  /** @deprecated use `CompressedOrderOrderRejectedReason$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderOrderRejectedReason$inboundSchema;
  /** @deprecated use `CompressedOrderOrderRejectedReason$outboundSchema` instead. */
  export const outboundSchema =
    CompressedOrderOrderRejectedReason$outboundSchema;
}

/** @internal */
export const CompressedOrderOrderStatus$inboundSchema: z.ZodType<
  CompressedOrderOrderStatusOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CompressedOrderOrderStatus),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CompressedOrderOrderStatus$outboundSchema: z.ZodType<
  CompressedOrderOrderStatusOpen,
  z.ZodTypeDef,
  CompressedOrderOrderStatusOpen
> = z.union([
  z.nativeEnum(CompressedOrderOrderStatus),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderOrderStatus$ {
  /** @deprecated use `CompressedOrderOrderStatus$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderOrderStatus$inboundSchema;
  /** @deprecated use `CompressedOrderOrderStatus$outboundSchema` instead. */
  export const outboundSchema = CompressedOrderOrderStatus$outboundSchema;
}

/** @internal */
export const CompressedOrderOrderType$inboundSchema: z.ZodType<
  CompressedOrderOrderTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CompressedOrderOrderType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CompressedOrderOrderType$outboundSchema: z.ZodType<
  CompressedOrderOrderTypeOpen,
  z.ZodTypeDef,
  CompressedOrderOrderTypeOpen
> = z.union([
  z.nativeEnum(CompressedOrderOrderType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderOrderType$ {
  /** @deprecated use `CompressedOrderOrderType$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderOrderType$inboundSchema;
  /** @deprecated use `CompressedOrderOrderType$outboundSchema` instead. */
  export const outboundSchema = CompressedOrderOrderType$outboundSchema;
}

/** @internal */
export const CompressedOrderQuantity$inboundSchema: z.ZodType<
  CompressedOrderQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type CompressedOrderQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const CompressedOrderQuantity$outboundSchema: z.ZodType<
  CompressedOrderQuantity$Outbound,
  z.ZodTypeDef,
  CompressedOrderQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderQuantity$ {
  /** @deprecated use `CompressedOrderQuantity$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderQuantity$inboundSchema;
  /** @deprecated use `CompressedOrderQuantity$outboundSchema` instead. */
  export const outboundSchema = CompressedOrderQuantity$outboundSchema;
  /** @deprecated use `CompressedOrderQuantity$Outbound` instead. */
  export type Outbound = CompressedOrderQuantity$Outbound;
}

/** @internal */
export const CompressedOrderRightsOfAccumulationAmount$inboundSchema: z.ZodType<
  CompressedOrderRightsOfAccumulationAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type CompressedOrderRightsOfAccumulationAmount$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const CompressedOrderRightsOfAccumulationAmount$outboundSchema:
  z.ZodType<
    CompressedOrderRightsOfAccumulationAmount$Outbound,
    z.ZodTypeDef,
    CompressedOrderRightsOfAccumulationAmount
  > = z.object({
    value: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderRightsOfAccumulationAmount$ {
  /** @deprecated use `CompressedOrderRightsOfAccumulationAmount$inboundSchema` instead. */
  export const inboundSchema =
    CompressedOrderRightsOfAccumulationAmount$inboundSchema;
  /** @deprecated use `CompressedOrderRightsOfAccumulationAmount$outboundSchema` instead. */
  export const outboundSchema =
    CompressedOrderRightsOfAccumulationAmount$outboundSchema;
  /** @deprecated use `CompressedOrderRightsOfAccumulationAmount$Outbound` instead. */
  export type Outbound = CompressedOrderRightsOfAccumulationAmount$Outbound;
}

/** @internal */
export const CompressedOrderRightsOfAccumulation$inboundSchema: z.ZodType<
  CompressedOrderRightsOfAccumulation,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.nullable(
    z.lazy(() => CompressedOrderRightsOfAccumulationAmount$inboundSchema),
  ).optional(),
});

/** @internal */
export type CompressedOrderRightsOfAccumulation$Outbound = {
  amount?:
    | CompressedOrderRightsOfAccumulationAmount$Outbound
    | null
    | undefined;
};

/** @internal */
export const CompressedOrderRightsOfAccumulation$outboundSchema: z.ZodType<
  CompressedOrderRightsOfAccumulation$Outbound,
  z.ZodTypeDef,
  CompressedOrderRightsOfAccumulation
> = z.object({
  amount: z.nullable(
    z.lazy(() => CompressedOrderRightsOfAccumulationAmount$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderRightsOfAccumulation$ {
  /** @deprecated use `CompressedOrderRightsOfAccumulation$inboundSchema` instead. */
  export const inboundSchema =
    CompressedOrderRightsOfAccumulation$inboundSchema;
  /** @deprecated use `CompressedOrderRightsOfAccumulation$outboundSchema` instead. */
  export const outboundSchema =
    CompressedOrderRightsOfAccumulation$outboundSchema;
  /** @deprecated use `CompressedOrderRightsOfAccumulation$Outbound` instead. */
  export type Outbound = CompressedOrderRightsOfAccumulation$Outbound;
}

/** @internal */
export const CompressedOrderSide$inboundSchema: z.ZodType<
  CompressedOrderSideOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CompressedOrderSide),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CompressedOrderSide$outboundSchema: z.ZodType<
  CompressedOrderSideOpen,
  z.ZodTypeDef,
  CompressedOrderSideOpen
> = z.union([
  z.nativeEnum(CompressedOrderSide),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderSide$ {
  /** @deprecated use `CompressedOrderSide$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderSide$inboundSchema;
  /** @deprecated use `CompressedOrderSide$outboundSchema` instead. */
  export const outboundSchema = CompressedOrderSide$outboundSchema;
}

/** @internal */
export const CompressedOrderTimeInForce$inboundSchema: z.ZodType<
  CompressedOrderTimeInForceOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CompressedOrderTimeInForce),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CompressedOrderTimeInForce$outboundSchema: z.ZodType<
  CompressedOrderTimeInForceOpen,
  z.ZodTypeDef,
  CompressedOrderTimeInForceOpen
> = z.union([
  z.nativeEnum(CompressedOrderTimeInForce),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrderTimeInForce$ {
  /** @deprecated use `CompressedOrderTimeInForce$inboundSchema` instead. */
  export const inboundSchema = CompressedOrderTimeInForce$inboundSchema;
  /** @deprecated use `CompressedOrderTimeInForce$outboundSchema` instead. */
  export const outboundSchema = CompressedOrderTimeInForce$outboundSchema;
}

/** @internal */
export const CompressedOrder$inboundSchema: z.ZodType<
  CompressedOrder,
  z.ZodTypeDef,
  unknown
> = z.object({
  asset_id: z.string().optional(),
  asset_type: CompressedOrderAssetType$inboundSchema.optional(),
  average_price_account_id: z.string().optional(),
  average_prices: z.array(ExecutedPrice$inboundSchema).optional(),
  compressed_order_id: z.string().optional(),
  create_time: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  cumulative_notional_value: z.nullable(
    z.lazy(() => CompressedOrderCumulativeNotionalValue$inboundSchema),
  ).optional(),
  currency_code: z.string().optional(),
  executions: z.array(Executions$inboundSchema).optional(),
  fees: z.array(Fee$inboundSchema).optional(),
  filled_quantity: z.nullable(
    z.lazy(() => CompressedOrderFilledQuantity$inboundSchema),
  ).optional(),
  identifier: z.string().optional(),
  identifier_type: CompressedOrderIdentifierType$inboundSchema.optional(),
  last_update_time: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  letter_of_intent: z.nullable(
    z.lazy(() => CompressedOrderLetterOfIntent$inboundSchema),
  ).optional(),
  name: z.string().optional(),
  notional_value: z.nullable(
    z.lazy(() => CompressedOrderNotionalValue$inboundSchema),
  ).optional(),
  order_rejected_reason: CompressedOrderOrderRejectedReason$inboundSchema
    .optional(),
  order_status: CompressedOrderOrderStatus$inboundSchema.optional(),
  order_type: CompressedOrderOrderType$inboundSchema.optional(),
  quantity: z.nullable(z.lazy(() => CompressedOrderQuantity$inboundSchema))
    .optional(),
  rights_of_accumulation: z.nullable(
    z.lazy(() => CompressedOrderRightsOfAccumulation$inboundSchema),
  ).optional(),
  side: CompressedOrderSide$inboundSchema.optional(),
  time_in_force: CompressedOrderTimeInForce$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "asset_id": "assetId",
    "asset_type": "assetType",
    "average_price_account_id": "averagePriceAccountId",
    "average_prices": "averagePrices",
    "compressed_order_id": "compressedOrderId",
    "create_time": "createTime",
    "cumulative_notional_value": "cumulativeNotionalValue",
    "currency_code": "currencyCode",
    "filled_quantity": "filledQuantity",
    "identifier_type": "identifierType",
    "last_update_time": "lastUpdateTime",
    "letter_of_intent": "letterOfIntent",
    "notional_value": "notionalValue",
    "order_rejected_reason": "orderRejectedReason",
    "order_status": "orderStatus",
    "order_type": "orderType",
    "rights_of_accumulation": "rightsOfAccumulation",
    "time_in_force": "timeInForce",
  });
});

/** @internal */
export type CompressedOrder$Outbound = {
  asset_id?: string | undefined;
  asset_type?: string | undefined;
  average_price_account_id?: string | undefined;
  average_prices?: Array<ExecutedPrice$Outbound> | undefined;
  compressed_order_id?: string | undefined;
  create_time?: string | null | undefined;
  cumulative_notional_value?:
    | CompressedOrderCumulativeNotionalValue$Outbound
    | null
    | undefined;
  currency_code?: string | undefined;
  executions?: Array<Executions$Outbound> | undefined;
  fees?: Array<Fee$Outbound> | undefined;
  filled_quantity?: CompressedOrderFilledQuantity$Outbound | null | undefined;
  identifier?: string | undefined;
  identifier_type?: string | undefined;
  last_update_time?: string | null | undefined;
  letter_of_intent?: CompressedOrderLetterOfIntent$Outbound | null | undefined;
  name?: string | undefined;
  notional_value?: CompressedOrderNotionalValue$Outbound | null | undefined;
  order_rejected_reason?: string | undefined;
  order_status?: string | undefined;
  order_type?: string | undefined;
  quantity?: CompressedOrderQuantity$Outbound | null | undefined;
  rights_of_accumulation?:
    | CompressedOrderRightsOfAccumulation$Outbound
    | null
    | undefined;
  side?: string | undefined;
  time_in_force?: string | undefined;
};

/** @internal */
export const CompressedOrder$outboundSchema: z.ZodType<
  CompressedOrder$Outbound,
  z.ZodTypeDef,
  CompressedOrder
> = z.object({
  assetId: z.string().optional(),
  assetType: CompressedOrderAssetType$outboundSchema.optional(),
  averagePriceAccountId: z.string().optional(),
  averagePrices: z.array(ExecutedPrice$outboundSchema).optional(),
  compressedOrderId: z.string().optional(),
  createTime: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  cumulativeNotionalValue: z.nullable(
    z.lazy(() => CompressedOrderCumulativeNotionalValue$outboundSchema),
  ).optional(),
  currencyCode: z.string().optional(),
  executions: z.array(Executions$outboundSchema).optional(),
  fees: z.array(Fee$outboundSchema).optional(),
  filledQuantity: z.nullable(
    z.lazy(() => CompressedOrderFilledQuantity$outboundSchema),
  ).optional(),
  identifier: z.string().optional(),
  identifierType: CompressedOrderIdentifierType$outboundSchema.optional(),
  lastUpdateTime: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  letterOfIntent: z.nullable(
    z.lazy(() => CompressedOrderLetterOfIntent$outboundSchema),
  ).optional(),
  name: z.string().optional(),
  notionalValue: z.nullable(
    z.lazy(() => CompressedOrderNotionalValue$outboundSchema),
  ).optional(),
  orderRejectedReason: CompressedOrderOrderRejectedReason$outboundSchema
    .optional(),
  orderStatus: CompressedOrderOrderStatus$outboundSchema.optional(),
  orderType: CompressedOrderOrderType$outboundSchema.optional(),
  quantity: z.nullable(z.lazy(() => CompressedOrderQuantity$outboundSchema))
    .optional(),
  rightsOfAccumulation: z.nullable(
    z.lazy(() => CompressedOrderRightsOfAccumulation$outboundSchema),
  ).optional(),
  side: CompressedOrderSide$outboundSchema.optional(),
  timeInForce: CompressedOrderTimeInForce$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    assetId: "asset_id",
    assetType: "asset_type",
    averagePriceAccountId: "average_price_account_id",
    averagePrices: "average_prices",
    compressedOrderId: "compressed_order_id",
    createTime: "create_time",
    cumulativeNotionalValue: "cumulative_notional_value",
    currencyCode: "currency_code",
    filledQuantity: "filled_quantity",
    identifierType: "identifier_type",
    lastUpdateTime: "last_update_time",
    letterOfIntent: "letter_of_intent",
    notionalValue: "notional_value",
    orderRejectedReason: "order_rejected_reason",
    orderStatus: "order_status",
    orderType: "order_type",
    rightsOfAccumulation: "rights_of_accumulation",
    timeInForce: "time_in_force",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompressedOrder$ {
  /** @deprecated use `CompressedOrder$inboundSchema` instead. */
  export const inboundSchema = CompressedOrder$inboundSchema;
  /** @deprecated use `CompressedOrder$outboundSchema` instead. */
  export const outboundSchema = CompressedOrder$outboundSchema;
  /** @deprecated use `CompressedOrder$Outbound` instead. */
  export type Outbound = CompressedOrder$Outbound;
}
