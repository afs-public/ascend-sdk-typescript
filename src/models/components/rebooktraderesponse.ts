/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  BookingFee,
  BookingFee$inboundSchema,
  BookingFee$Outbound,
  BookingFee$outboundSchema,
} from "./bookingfee.js";
import {
  BookingLot,
  BookingLot$inboundSchema,
  BookingLot$Outbound,
  BookingLot$outboundSchema,
} from "./bookinglot.js";
import {
  Execution,
  Execution$inboundSchema,
  Execution$Outbound,
  Execution$outboundSchema,
} from "./execution.js";

/**
 * Type of the asset being traded. Required for SYMBOL and CUSIP.
 */
export enum RebookTradeResponseAssetType {
  AssetTypeUnspecified = "ASSET_TYPE_UNSPECIFIED",
  Equity = "EQUITY",
  FixedIncome = "FIXED_INCOME",
}
/**
 * Type of the asset being traded. Required for SYMBOL and CUSIP.
 */
export type RebookTradeResponseAssetTypeOpen = OpenEnum<
  typeof RebookTradeResponseAssetType
>;

/**
 * Broker capacity for the trade.
 */
export enum RebookTradeResponseBrokerCapacity {
  CapacityUnspecified = "CAPACITY_UNSPECIFIED",
  Agency = "AGENCY",
  Principal = "PRINCIPAL",
  Mixed = "MIXED",
}
/**
 * Broker capacity for the trade.
 */
export type RebookTradeResponseBrokerCapacityOpen = OpenEnum<
  typeof RebookTradeResponseBrokerCapacity
>;

/**
 * Identifier type for the asset being traded.
 */
export enum RebookTradeResponseIdentifierType {
  IdentifierTypeUnspecified = "IDENTIFIER_TYPE_UNSPECIFIED",
  AssetId = "ASSET_ID",
  Symbol = "SYMBOL",
  Cusip = "CUSIP",
  Isin = "ISIN",
}
/**
 * Identifier type for the asset being traded.
 */
export type RebookTradeResponseIdentifierTypeOpen = OpenEnum<
  typeof RebookTradeResponseIdentifierType
>;

/**
 * Date field to support extended trading hours.
 */
export type RebookTradeResponseLocalMarketTradeDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Route type for the trade.
 */
export enum RebookTradeResponseRouteType {
  RouteTypeUnspecified = "ROUTE_TYPE_UNSPECIFIED",
  Dma = "DMA",
  Mngd = "MNGD",
  Quik = "QUIK",
  Algo = "ALGO",
  Away = "AWAY",
  Corr = "CORR",
  Boats = "BOATS",
}
/**
 * Route type for the trade.
 */
export type RebookTradeResponseRouteTypeOpen = OpenEnum<
  typeof RebookTradeResponseRouteType
>;

/**
 * Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time.
 */
export type RebookTradeResponseSettlementDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Denotes if the trade is a SELL or a BUY.
 */
export enum RebookTradeResponseSide {
  SideUnspecified = "SIDE_UNSPECIFIED",
  Buy = "BUY",
  Sell = "SELL",
}
/**
 * Denotes if the trade is a SELL or a BUY.
 */
export type RebookTradeResponseSideOpen = OpenEnum<
  typeof RebookTradeResponseSide
>;

/**
 * Side modifier for the trade.
 */
export enum RebookTradeResponseSideModifier {
  SideModifierUnspecified = "SIDE_MODIFIER_UNSPECIFIED",
  Short = "SHORT",
  ShortExempt = "SHORT_EXEMPT",
  ShortCover = "SHORT_COVER",
  Open = "OPEN",
  Close = "CLOSE",
}
/**
 * Side modifier for the trade.
 */
export type RebookTradeResponseSideModifierOpen = OpenEnum<
  typeof RebookTradeResponseSideModifier
>;

export enum RebookTradeResponseSpecialInstructions {
  SpecialInstructionsUnspecified = "SPECIAL_INSTRUCTIONS_UNSPECIFIED",
  Rule144 = "RULE_144",
  WithDividend = "WITH_DIVIDEND",
  WithRights = "WITH_RIGHTS",
  CloseContract = "CLOSE_CONTRACT",
  CoverShort = "COVER_SHORT",
  CrossTrade = "CROSS_TRADE",
  OpenContractCovered = "OPEN_CONTRACT_COVERED",
  DiscretionExercised = "DISCRETION_EXERCISED",
  DiscretionNotExercised = "DISCRETION_NOT_EXERCISED",
  OptionAssignment = "OPTION_ASSIGNMENT",
  EmployeeStockOption = "EMPLOYEE_STOCK_OPTION",
  InvestmentBanking = "INVESTMENT_BANKING",
  BrokerDealerOrder = "BROKER_DEALER_ORDER",
  MakeMarketInSecurity = "MAKE_MARKET_IN_SECURITY",
  MakeMarketSolicited = "MAKE_MARKET_SOLICITED",
  MakeMarketUnsolicited = "MAKE_MARKET_UNSOLICITED",
  CustomerDirected = "CUSTOMER_DIRECTED",
  FullyRegistered = "FULLY_REGISTERED",
  OpenContract = "OPEN_CONTRACT",
  OddlotDiffOnRequest = "ODDLOT_DIFF_ON_REQUEST",
  ProspectusEnclosed = "PROSPECTUS_ENCLOSED",
  ProspectusSeparateMail = "PROSPECTUS_SEPARATE_MAIL",
  Solicited = "SOLICITED",
  Unsolicited = "UNSOLICITED",
  XDividend = "X_DIVIDEND",
  ActingAsPrincipal = "ACTING_AS_PRINCIPAL",
  AveragePrice = "AVERAGE_PRICE",
  BrokerLiquidation = "BROKER_LIQUIDATION",
  CouponBooks = "COUPON_BOOKS",
  HasPostageFee = "HAS_POSTAGE_FEE",
  InternetOrder = "INTERNET_ORDER",
  MarginSellout = "MARGIN_SELLOUT",
  MarketMakersAsPrincipal = "MARKET_MAKERS_AS_PRINCIPAL",
  NegativeNetProceed = "NEGATIVE_NET_PROCEED",
  PreFigIndicator = "PRE_FIG_INDICATOR",
  RisklessPrincipalInstruction = "RISKLESS_PRINCIPAL_INSTRUCTION",
  ShortInstruction = "SHORT_INSTRUCTION",
  ThirdMarket = "THIRD_MARKET",
  SuppressMsrbTransmission = "SUPPRESS_MSRB_TRANSMISSION",
  SuppressTraceReporting = "SUPPRESS_TRACE_REPORTING",
  SuppressEmailNotification = "SUPPRESS_EMAIL_NOTIFICATION",
  StockReward = "STOCK_REWARD",
  SuppressRegFees = "SUPPRESS_REG_FEES",
  SuppressSecFee = "SUPPRESS_SEC_FEE",
  SuppressTafFee = "SUPPRESS_TAF_FEE",
  DividendReinvestment = "DIVIDEND_REINVESTMENT",
}
export type RebookTradeResponseSpecialInstructionsOpen = OpenEnum<
  typeof RebookTradeResponseSpecialInstructions
>;

/**
 * Exchange venue
 */
export enum RebookTradeResponseVenue {
  ExchangeVenueUnspecified = "EXCHANGE_VENUE_UNSPECIFIED",
  Amex = "AMEX",
  Arca = "ARCA",
  Bats = "BATS",
  BatsByx = "BATS_BYX",
  Boston = "BOSTON",
  Box = "BOX",
  Bzx = "BZX",
  C2 = "C2",
  Cboe = "CBOE",
  Chicago = "CHICAGO",
  Cincinnati = "CINCINNATI",
  Edga = "EDGA",
  Edgx = "EDGX",
  Exclearing = "EXCLEARING",
  Iex = "IEX",
  Ise = "ISE",
  IseGemini = "ISE_GEMINI",
  Miax = "MIAX",
  Nasdaq = "NASDAQ",
  NasdaqOmxBx = "NASDAQ_OMX_BX",
  Nyse = "NYSE",
  Phlx = "PHLX",
  Otc = "OTC",
  Qsr = "QSR",
}
/**
 * Exchange venue
 */
export type RebookTradeResponseVenueOpen = OpenEnum<
  typeof RebookTradeResponseVenue
>;

/**
 * Denotes that this trade was either when_issued or when_distributed.
 */
export enum RebookTradeResponseWhenIssued {
  WhenIssuedTypeUnspecified = "WHEN_ISSUED_TYPE_UNSPECIFIED",
  WhenIssued = "WHEN_ISSUED",
  WhenDistributed = "WHEN_DISTRIBUTED",
}
/**
 * Denotes that this trade was either when_issued or when_distributed.
 */
export type RebookTradeResponseWhenIssuedOpen = OpenEnum<
  typeof RebookTradeResponseWhenIssued
>;

/**
 * The new trade that is booked.
 */
export type NewTrade = {
  /**
   * A globally unique identifier referencing a single account.
   */
  accountId?: string | undefined;
  /**
   * The current activity_id of this trade in the Ledger.
   */
  activityId?: string | undefined;
  /**
   * Free form instructions that can be used to provide additional instructions (that are not captured by existing special instructions) and will be put on the trade confirm.
   */
  additionalInstructions?: string | undefined;
  /**
   * Fractional support for market-makers' internal order ids.
   */
  alternateOrderId?: string | undefined;
  /**
   * Type of the asset being traded. Required for SYMBOL and CUSIP.
   */
  assetType?: RebookTradeResponseAssetTypeOpen | undefined;
  /**
   * Broker capacity for the trade.
   */
  brokerCapacity?: RebookTradeResponseBrokerCapacityOpen | undefined;
  /**
   * The unique identifier that is associated with an order. Must be unique by date per trade per client.
   */
  clientOrderId?: string | undefined;
  /**
   * Executing broker of the trade.
   */
  executingBroker?: string | undefined;
  /**
   * The executions (sometimes referred to as partial-fills) that comprise the trade.
   */
  executions?: Array<Execution> | undefined;
  /**
   * Any client calculated fees associated with the trade. Only allowed if trade.open = false. Regulatory fees will be calculated automatically if they are not explicitly overwritten or suppressed.
   */
  fees?: Array<BookingFee> | undefined;
  /**
   * Identifier (of the type specified in `identifier_type`). Responses will supply the originally requested identifier.
   */
  identifier?: string | undefined;
  /**
   * Identifier type for the asset being traded.
   */
  identifierType?: RebookTradeResponseIdentifierTypeOpen | undefined;
  /**
   * Unicode CLDR region code. Issuing Region Code is required for some `identifier_type`s, especially CUSIP.
   */
  issuingRegionCode?: string | undefined;
  /**
   * Date field to support extended trading hours.
   */
  localMarketTradeDate?:
    | RebookTradeResponseLocalMarketTradeDate
    | null
    | undefined;
  /**
   * One or many lot matching instructions for the trade.
   */
  lotMatchingInstructions?: Array<BookingLot> | undefined;
  /**
   * Market Identifier Code
   */
  micCode?: string | undefined;
  /**
   * The resource name of the trade.
   */
  name?: string | undefined;
  /**
   * State of this trade's completeness in filling. True: trade is not done filling and can append more executions onto the trade False: trade is done filling and cannot append more executions onto the trade By default, trades are closed when they are created. An open trade can later be closed by calling the CompleteTrade endpoint. Additional executions can be appended to an open trade by calling the CreateExecution endpoint. Trades that are left open will be automatically closed nightly before Ledger's EOD.
   */
  open?: boolean | undefined;
  /**
   * Street-level order id, unique by day per broker.
   */
  orderId?: string | undefined;
  /**
   * Route type for the trade.
   */
  routeType?: RebookTradeResponseRouteTypeOpen | undefined;
  /**
   * Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time.
   */
  settlementDate?: RebookTradeResponseSettlementDate | null | undefined;
  /**
   * Denotes if the trade is a SELL or a BUY.
   */
  side?: RebookTradeResponseSideOpen | undefined;
  /**
   * Side modifier for the trade.
   */
  sideModifier?: RebookTradeResponseSideModifierOpen | undefined;
  /**
   * The source of the submission.
   */
  sourceApplication?: string | undefined;
  /**
   * An enumerated list of values used to indicate certain attributes about a trade (E.g. DISCRETION_EXERCISED, BROKER_LIQUIDATION) and/or trigger downstream processing rules (e.g. SUPPRESS_TRACE_REPORTING)
   */
  specialInstructions?:
    | Array<RebookTradeResponseSpecialInstructionsOpen>
    | undefined;
  /**
   * A ULID to uniquely identify the trade globally.
   */
  tradeId?: string | undefined;
  /**
   * Exchange venue
   */
  venue?: RebookTradeResponseVenueOpen | undefined;
  /**
   * Denotes that this trade was either when_issued or when_distributed.
   */
  whenIssued?: RebookTradeResponseWhenIssuedOpen | undefined;
};

/**
 * Type of the asset being traded. Required for SYMBOL and CUSIP.
 */
export enum RebookTradeResponseOriginalTradeAssetType {
  AssetTypeUnspecified = "ASSET_TYPE_UNSPECIFIED",
  Equity = "EQUITY",
  FixedIncome = "FIXED_INCOME",
}
/**
 * Type of the asset being traded. Required for SYMBOL and CUSIP.
 */
export type RebookTradeResponseOriginalTradeAssetTypeOpen = OpenEnum<
  typeof RebookTradeResponseOriginalTradeAssetType
>;

/**
 * Broker capacity for the trade.
 */
export enum RebookTradeResponseOriginalTradeBrokerCapacity {
  CapacityUnspecified = "CAPACITY_UNSPECIFIED",
  Agency = "AGENCY",
  Principal = "PRINCIPAL",
  Mixed = "MIXED",
}
/**
 * Broker capacity for the trade.
 */
export type RebookTradeResponseOriginalTradeBrokerCapacityOpen = OpenEnum<
  typeof RebookTradeResponseOriginalTradeBrokerCapacity
>;

/**
 * Identifier type for the asset being traded.
 */
export enum RebookTradeResponseOriginalTradeIdentifierType {
  IdentifierTypeUnspecified = "IDENTIFIER_TYPE_UNSPECIFIED",
  AssetId = "ASSET_ID",
  Symbol = "SYMBOL",
  Cusip = "CUSIP",
  Isin = "ISIN",
}
/**
 * Identifier type for the asset being traded.
 */
export type RebookTradeResponseOriginalTradeIdentifierTypeOpen = OpenEnum<
  typeof RebookTradeResponseOriginalTradeIdentifierType
>;

/**
 * Date field to support extended trading hours.
 */
export type RebookTradeResponseOriginalTradeLocalMarketTradeDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Route type for the trade.
 */
export enum RebookTradeResponseOriginalTradeRouteType {
  RouteTypeUnspecified = "ROUTE_TYPE_UNSPECIFIED",
  Dma = "DMA",
  Mngd = "MNGD",
  Quik = "QUIK",
  Algo = "ALGO",
  Away = "AWAY",
  Corr = "CORR",
  Boats = "BOATS",
}
/**
 * Route type for the trade.
 */
export type RebookTradeResponseOriginalTradeRouteTypeOpen = OpenEnum<
  typeof RebookTradeResponseOriginalTradeRouteType
>;

/**
 * Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time.
 */
export type RebookTradeResponseOriginalTradeSettlementDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Denotes if the trade is a SELL or a BUY.
 */
export enum RebookTradeResponseOriginalTradeSide {
  SideUnspecified = "SIDE_UNSPECIFIED",
  Buy = "BUY",
  Sell = "SELL",
}
/**
 * Denotes if the trade is a SELL or a BUY.
 */
export type RebookTradeResponseOriginalTradeSideOpen = OpenEnum<
  typeof RebookTradeResponseOriginalTradeSide
>;

/**
 * Side modifier for the trade.
 */
export enum RebookTradeResponseOriginalTradeSideModifier {
  SideModifierUnspecified = "SIDE_MODIFIER_UNSPECIFIED",
  Short = "SHORT",
  ShortExempt = "SHORT_EXEMPT",
  ShortCover = "SHORT_COVER",
  Open = "OPEN",
  Close = "CLOSE",
}
/**
 * Side modifier for the trade.
 */
export type RebookTradeResponseOriginalTradeSideModifierOpen = OpenEnum<
  typeof RebookTradeResponseOriginalTradeSideModifier
>;

export enum RebookTradeResponseOriginalTradeSpecialInstructions {
  SpecialInstructionsUnspecified = "SPECIAL_INSTRUCTIONS_UNSPECIFIED",
  Rule144 = "RULE_144",
  WithDividend = "WITH_DIVIDEND",
  WithRights = "WITH_RIGHTS",
  CloseContract = "CLOSE_CONTRACT",
  CoverShort = "COVER_SHORT",
  CrossTrade = "CROSS_TRADE",
  OpenContractCovered = "OPEN_CONTRACT_COVERED",
  DiscretionExercised = "DISCRETION_EXERCISED",
  DiscretionNotExercised = "DISCRETION_NOT_EXERCISED",
  OptionAssignment = "OPTION_ASSIGNMENT",
  EmployeeStockOption = "EMPLOYEE_STOCK_OPTION",
  InvestmentBanking = "INVESTMENT_BANKING",
  BrokerDealerOrder = "BROKER_DEALER_ORDER",
  MakeMarketInSecurity = "MAKE_MARKET_IN_SECURITY",
  MakeMarketSolicited = "MAKE_MARKET_SOLICITED",
  MakeMarketUnsolicited = "MAKE_MARKET_UNSOLICITED",
  CustomerDirected = "CUSTOMER_DIRECTED",
  FullyRegistered = "FULLY_REGISTERED",
  OpenContract = "OPEN_CONTRACT",
  OddlotDiffOnRequest = "ODDLOT_DIFF_ON_REQUEST",
  ProspectusEnclosed = "PROSPECTUS_ENCLOSED",
  ProspectusSeparateMail = "PROSPECTUS_SEPARATE_MAIL",
  Solicited = "SOLICITED",
  Unsolicited = "UNSOLICITED",
  XDividend = "X_DIVIDEND",
  ActingAsPrincipal = "ACTING_AS_PRINCIPAL",
  AveragePrice = "AVERAGE_PRICE",
  BrokerLiquidation = "BROKER_LIQUIDATION",
  CouponBooks = "COUPON_BOOKS",
  HasPostageFee = "HAS_POSTAGE_FEE",
  InternetOrder = "INTERNET_ORDER",
  MarginSellout = "MARGIN_SELLOUT",
  MarketMakersAsPrincipal = "MARKET_MAKERS_AS_PRINCIPAL",
  NegativeNetProceed = "NEGATIVE_NET_PROCEED",
  PreFigIndicator = "PRE_FIG_INDICATOR",
  RisklessPrincipalInstruction = "RISKLESS_PRINCIPAL_INSTRUCTION",
  ShortInstruction = "SHORT_INSTRUCTION",
  ThirdMarket = "THIRD_MARKET",
  SuppressMsrbTransmission = "SUPPRESS_MSRB_TRANSMISSION",
  SuppressTraceReporting = "SUPPRESS_TRACE_REPORTING",
  SuppressEmailNotification = "SUPPRESS_EMAIL_NOTIFICATION",
  StockReward = "STOCK_REWARD",
  SuppressRegFees = "SUPPRESS_REG_FEES",
  SuppressSecFee = "SUPPRESS_SEC_FEE",
  SuppressTafFee = "SUPPRESS_TAF_FEE",
  DividendReinvestment = "DIVIDEND_REINVESTMENT",
}
export type RebookTradeResponseOriginalTradeSpecialInstructionsOpen = OpenEnum<
  typeof RebookTradeResponseOriginalTradeSpecialInstructions
>;

/**
 * Exchange venue
 */
export enum RebookTradeResponseOriginalTradeVenue {
  ExchangeVenueUnspecified = "EXCHANGE_VENUE_UNSPECIFIED",
  Amex = "AMEX",
  Arca = "ARCA",
  Bats = "BATS",
  BatsByx = "BATS_BYX",
  Boston = "BOSTON",
  Box = "BOX",
  Bzx = "BZX",
  C2 = "C2",
  Cboe = "CBOE",
  Chicago = "CHICAGO",
  Cincinnati = "CINCINNATI",
  Edga = "EDGA",
  Edgx = "EDGX",
  Exclearing = "EXCLEARING",
  Iex = "IEX",
  Ise = "ISE",
  IseGemini = "ISE_GEMINI",
  Miax = "MIAX",
  Nasdaq = "NASDAQ",
  NasdaqOmxBx = "NASDAQ_OMX_BX",
  Nyse = "NYSE",
  Phlx = "PHLX",
  Otc = "OTC",
  Qsr = "QSR",
}
/**
 * Exchange venue
 */
export type RebookTradeResponseOriginalTradeVenueOpen = OpenEnum<
  typeof RebookTradeResponseOriginalTradeVenue
>;

/**
 * Denotes that this trade was either when_issued or when_distributed.
 */
export enum RebookTradeResponseOriginalTradeWhenIssued {
  WhenIssuedTypeUnspecified = "WHEN_ISSUED_TYPE_UNSPECIFIED",
  WhenIssued = "WHEN_ISSUED",
  WhenDistributed = "WHEN_DISTRIBUTED",
}
/**
 * Denotes that this trade was either when_issued or when_distributed.
 */
export type RebookTradeResponseOriginalTradeWhenIssuedOpen = OpenEnum<
  typeof RebookTradeResponseOriginalTradeWhenIssued
>;

/**
 * The original trade that was rebooked.
 */
export type OriginalTrade = {
  /**
   * A globally unique identifier referencing a single account.
   */
  accountId?: string | undefined;
  /**
   * The current activity_id of this trade in the Ledger.
   */
  activityId?: string | undefined;
  /**
   * Free form instructions that can be used to provide additional instructions (that are not captured by existing special instructions) and will be put on the trade confirm.
   */
  additionalInstructions?: string | undefined;
  /**
   * Fractional support for market-makers' internal order ids.
   */
  alternateOrderId?: string | undefined;
  /**
   * Type of the asset being traded. Required for SYMBOL and CUSIP.
   */
  assetType?: RebookTradeResponseOriginalTradeAssetTypeOpen | undefined;
  /**
   * Broker capacity for the trade.
   */
  brokerCapacity?:
    | RebookTradeResponseOriginalTradeBrokerCapacityOpen
    | undefined;
  /**
   * The unique identifier that is associated with an order. Must be unique by date per trade per client.
   */
  clientOrderId?: string | undefined;
  /**
   * Executing broker of the trade.
   */
  executingBroker?: string | undefined;
  /**
   * The executions (sometimes referred to as partial-fills) that comprise the trade.
   */
  executions?: Array<Execution> | undefined;
  /**
   * Any client calculated fees associated with the trade. Only allowed if trade.open = false. Regulatory fees will be calculated automatically if they are not explicitly overwritten or suppressed.
   */
  fees?: Array<BookingFee> | undefined;
  /**
   * Identifier (of the type specified in `identifier_type`). Responses will supply the originally requested identifier.
   */
  identifier?: string | undefined;
  /**
   * Identifier type for the asset being traded.
   */
  identifierType?:
    | RebookTradeResponseOriginalTradeIdentifierTypeOpen
    | undefined;
  /**
   * Unicode CLDR region code. Issuing Region Code is required for some `identifier_type`s, especially CUSIP.
   */
  issuingRegionCode?: string | undefined;
  /**
   * Date field to support extended trading hours.
   */
  localMarketTradeDate?:
    | RebookTradeResponseOriginalTradeLocalMarketTradeDate
    | null
    | undefined;
  /**
   * One or many lot matching instructions for the trade.
   */
  lotMatchingInstructions?: Array<BookingLot> | undefined;
  /**
   * Market Identifier Code
   */
  micCode?: string | undefined;
  /**
   * The resource name of the trade.
   */
  name?: string | undefined;
  /**
   * State of this trade's completeness in filling. True: trade is not done filling and can append more executions onto the trade False: trade is done filling and cannot append more executions onto the trade By default, trades are closed when they are created. An open trade can later be closed by calling the CompleteTrade endpoint. Additional executions can be appended to an open trade by calling the CreateExecution endpoint. Trades that are left open will be automatically closed nightly before Ledger's EOD.
   */
  open?: boolean | undefined;
  /**
   * Street-level order id, unique by day per broker.
   */
  orderId?: string | undefined;
  /**
   * Route type for the trade.
   */
  routeType?: RebookTradeResponseOriginalTradeRouteTypeOpen | undefined;
  /**
   * Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time.
   */
  settlementDate?:
    | RebookTradeResponseOriginalTradeSettlementDate
    | null
    | undefined;
  /**
   * Denotes if the trade is a SELL or a BUY.
   */
  side?: RebookTradeResponseOriginalTradeSideOpen | undefined;
  /**
   * Side modifier for the trade.
   */
  sideModifier?: RebookTradeResponseOriginalTradeSideModifierOpen | undefined;
  /**
   * The source of the submission.
   */
  sourceApplication?: string | undefined;
  /**
   * An enumerated list of values used to indicate certain attributes about a trade (E.g. DISCRETION_EXERCISED, BROKER_LIQUIDATION) and/or trigger downstream processing rules (e.g. SUPPRESS_TRACE_REPORTING)
   */
  specialInstructions?:
    | Array<RebookTradeResponseOriginalTradeSpecialInstructionsOpen>
    | undefined;
  /**
   * A ULID to uniquely identify the trade globally.
   */
  tradeId?: string | undefined;
  /**
   * Exchange venue
   */
  venue?: RebookTradeResponseOriginalTradeVenueOpen | undefined;
  /**
   * Denotes that this trade was either when_issued or when_distributed.
   */
  whenIssued?: RebookTradeResponseOriginalTradeWhenIssuedOpen | undefined;
};

/**
 * A response for the rebook trade method.
 */
export type RebookTradeResponse = {
  /**
   * The new trade that is booked.
   */
  newTrade?: NewTrade | null | undefined;
  /**
   * The original trade that was rebooked.
   */
  originalTrade?: OriginalTrade | null | undefined;
};

/** @internal */
export const RebookTradeResponseAssetType$inboundSchema: z.ZodType<
  RebookTradeResponseAssetTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseAssetType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseAssetType$outboundSchema: z.ZodType<
  RebookTradeResponseAssetTypeOpen,
  z.ZodTypeDef,
  RebookTradeResponseAssetTypeOpen
> = z.union([
  z.nativeEnum(RebookTradeResponseAssetType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseAssetType$ {
  /** @deprecated use `RebookTradeResponseAssetType$inboundSchema` instead. */
  export const inboundSchema = RebookTradeResponseAssetType$inboundSchema;
  /** @deprecated use `RebookTradeResponseAssetType$outboundSchema` instead. */
  export const outboundSchema = RebookTradeResponseAssetType$outboundSchema;
}

/** @internal */
export const RebookTradeResponseBrokerCapacity$inboundSchema: z.ZodType<
  RebookTradeResponseBrokerCapacityOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseBrokerCapacity),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseBrokerCapacity$outboundSchema: z.ZodType<
  RebookTradeResponseBrokerCapacityOpen,
  z.ZodTypeDef,
  RebookTradeResponseBrokerCapacityOpen
> = z.union([
  z.nativeEnum(RebookTradeResponseBrokerCapacity),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseBrokerCapacity$ {
  /** @deprecated use `RebookTradeResponseBrokerCapacity$inboundSchema` instead. */
  export const inboundSchema = RebookTradeResponseBrokerCapacity$inboundSchema;
  /** @deprecated use `RebookTradeResponseBrokerCapacity$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseBrokerCapacity$outboundSchema;
}

/** @internal */
export const RebookTradeResponseIdentifierType$inboundSchema: z.ZodType<
  RebookTradeResponseIdentifierTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseIdentifierType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseIdentifierType$outboundSchema: z.ZodType<
  RebookTradeResponseIdentifierTypeOpen,
  z.ZodTypeDef,
  RebookTradeResponseIdentifierTypeOpen
> = z.union([
  z.nativeEnum(RebookTradeResponseIdentifierType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseIdentifierType$ {
  /** @deprecated use `RebookTradeResponseIdentifierType$inboundSchema` instead. */
  export const inboundSchema = RebookTradeResponseIdentifierType$inboundSchema;
  /** @deprecated use `RebookTradeResponseIdentifierType$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseIdentifierType$outboundSchema;
}

/** @internal */
export const RebookTradeResponseLocalMarketTradeDate$inboundSchema: z.ZodType<
  RebookTradeResponseLocalMarketTradeDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type RebookTradeResponseLocalMarketTradeDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const RebookTradeResponseLocalMarketTradeDate$outboundSchema: z.ZodType<
  RebookTradeResponseLocalMarketTradeDate$Outbound,
  z.ZodTypeDef,
  RebookTradeResponseLocalMarketTradeDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseLocalMarketTradeDate$ {
  /** @deprecated use `RebookTradeResponseLocalMarketTradeDate$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseLocalMarketTradeDate$inboundSchema;
  /** @deprecated use `RebookTradeResponseLocalMarketTradeDate$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseLocalMarketTradeDate$outboundSchema;
  /** @deprecated use `RebookTradeResponseLocalMarketTradeDate$Outbound` instead. */
  export type Outbound = RebookTradeResponseLocalMarketTradeDate$Outbound;
}

export function rebookTradeResponseLocalMarketTradeDateToJSON(
  rebookTradeResponseLocalMarketTradeDate:
    RebookTradeResponseLocalMarketTradeDate,
): string {
  return JSON.stringify(
    RebookTradeResponseLocalMarketTradeDate$outboundSchema.parse(
      rebookTradeResponseLocalMarketTradeDate,
    ),
  );
}

export function rebookTradeResponseLocalMarketTradeDateFromJSON(
  jsonString: string,
): SafeParseResult<
  RebookTradeResponseLocalMarketTradeDate,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RebookTradeResponseLocalMarketTradeDate$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RebookTradeResponseLocalMarketTradeDate' from JSON`,
  );
}

/** @internal */
export const RebookTradeResponseRouteType$inboundSchema: z.ZodType<
  RebookTradeResponseRouteTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseRouteType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseRouteType$outboundSchema: z.ZodType<
  RebookTradeResponseRouteTypeOpen,
  z.ZodTypeDef,
  RebookTradeResponseRouteTypeOpen
> = z.union([
  z.nativeEnum(RebookTradeResponseRouteType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseRouteType$ {
  /** @deprecated use `RebookTradeResponseRouteType$inboundSchema` instead. */
  export const inboundSchema = RebookTradeResponseRouteType$inboundSchema;
  /** @deprecated use `RebookTradeResponseRouteType$outboundSchema` instead. */
  export const outboundSchema = RebookTradeResponseRouteType$outboundSchema;
}

/** @internal */
export const RebookTradeResponseSettlementDate$inboundSchema: z.ZodType<
  RebookTradeResponseSettlementDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type RebookTradeResponseSettlementDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const RebookTradeResponseSettlementDate$outboundSchema: z.ZodType<
  RebookTradeResponseSettlementDate$Outbound,
  z.ZodTypeDef,
  RebookTradeResponseSettlementDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseSettlementDate$ {
  /** @deprecated use `RebookTradeResponseSettlementDate$inboundSchema` instead. */
  export const inboundSchema = RebookTradeResponseSettlementDate$inboundSchema;
  /** @deprecated use `RebookTradeResponseSettlementDate$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseSettlementDate$outboundSchema;
  /** @deprecated use `RebookTradeResponseSettlementDate$Outbound` instead. */
  export type Outbound = RebookTradeResponseSettlementDate$Outbound;
}

export function rebookTradeResponseSettlementDateToJSON(
  rebookTradeResponseSettlementDate: RebookTradeResponseSettlementDate,
): string {
  return JSON.stringify(
    RebookTradeResponseSettlementDate$outboundSchema.parse(
      rebookTradeResponseSettlementDate,
    ),
  );
}

export function rebookTradeResponseSettlementDateFromJSON(
  jsonString: string,
): SafeParseResult<RebookTradeResponseSettlementDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RebookTradeResponseSettlementDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RebookTradeResponseSettlementDate' from JSON`,
  );
}

/** @internal */
export const RebookTradeResponseSide$inboundSchema: z.ZodType<
  RebookTradeResponseSideOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseSide),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseSide$outboundSchema: z.ZodType<
  RebookTradeResponseSideOpen,
  z.ZodTypeDef,
  RebookTradeResponseSideOpen
> = z.union([
  z.nativeEnum(RebookTradeResponseSide),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseSide$ {
  /** @deprecated use `RebookTradeResponseSide$inboundSchema` instead. */
  export const inboundSchema = RebookTradeResponseSide$inboundSchema;
  /** @deprecated use `RebookTradeResponseSide$outboundSchema` instead. */
  export const outboundSchema = RebookTradeResponseSide$outboundSchema;
}

/** @internal */
export const RebookTradeResponseSideModifier$inboundSchema: z.ZodType<
  RebookTradeResponseSideModifierOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseSideModifier),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseSideModifier$outboundSchema: z.ZodType<
  RebookTradeResponseSideModifierOpen,
  z.ZodTypeDef,
  RebookTradeResponseSideModifierOpen
> = z.union([
  z.nativeEnum(RebookTradeResponseSideModifier),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseSideModifier$ {
  /** @deprecated use `RebookTradeResponseSideModifier$inboundSchema` instead. */
  export const inboundSchema = RebookTradeResponseSideModifier$inboundSchema;
  /** @deprecated use `RebookTradeResponseSideModifier$outboundSchema` instead. */
  export const outboundSchema = RebookTradeResponseSideModifier$outboundSchema;
}

/** @internal */
export const RebookTradeResponseSpecialInstructions$inboundSchema: z.ZodType<
  RebookTradeResponseSpecialInstructionsOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseSpecialInstructions),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseSpecialInstructions$outboundSchema: z.ZodType<
  RebookTradeResponseSpecialInstructionsOpen,
  z.ZodTypeDef,
  RebookTradeResponseSpecialInstructionsOpen
> = z.union([
  z.nativeEnum(RebookTradeResponseSpecialInstructions),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseSpecialInstructions$ {
  /** @deprecated use `RebookTradeResponseSpecialInstructions$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseSpecialInstructions$inboundSchema;
  /** @deprecated use `RebookTradeResponseSpecialInstructions$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseSpecialInstructions$outboundSchema;
}

/** @internal */
export const RebookTradeResponseVenue$inboundSchema: z.ZodType<
  RebookTradeResponseVenueOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseVenue),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseVenue$outboundSchema: z.ZodType<
  RebookTradeResponseVenueOpen,
  z.ZodTypeDef,
  RebookTradeResponseVenueOpen
> = z.union([
  z.nativeEnum(RebookTradeResponseVenue),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseVenue$ {
  /** @deprecated use `RebookTradeResponseVenue$inboundSchema` instead. */
  export const inboundSchema = RebookTradeResponseVenue$inboundSchema;
  /** @deprecated use `RebookTradeResponseVenue$outboundSchema` instead. */
  export const outboundSchema = RebookTradeResponseVenue$outboundSchema;
}

/** @internal */
export const RebookTradeResponseWhenIssued$inboundSchema: z.ZodType<
  RebookTradeResponseWhenIssuedOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseWhenIssued),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseWhenIssued$outboundSchema: z.ZodType<
  RebookTradeResponseWhenIssuedOpen,
  z.ZodTypeDef,
  RebookTradeResponseWhenIssuedOpen
> = z.union([
  z.nativeEnum(RebookTradeResponseWhenIssued),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseWhenIssued$ {
  /** @deprecated use `RebookTradeResponseWhenIssued$inboundSchema` instead. */
  export const inboundSchema = RebookTradeResponseWhenIssued$inboundSchema;
  /** @deprecated use `RebookTradeResponseWhenIssued$outboundSchema` instead. */
  export const outboundSchema = RebookTradeResponseWhenIssued$outboundSchema;
}

/** @internal */
export const NewTrade$inboundSchema: z.ZodType<
  NewTrade,
  z.ZodTypeDef,
  unknown
> = z.object({
  account_id: z.string().optional(),
  activity_id: z.string().optional(),
  additional_instructions: z.string().optional(),
  alternate_order_id: z.string().optional(),
  asset_type: RebookTradeResponseAssetType$inboundSchema.optional(),
  broker_capacity: RebookTradeResponseBrokerCapacity$inboundSchema.optional(),
  client_order_id: z.string().optional(),
  executing_broker: z.string().optional(),
  executions: z.array(Execution$inboundSchema).optional(),
  fees: z.array(BookingFee$inboundSchema).optional(),
  identifier: z.string().optional(),
  identifier_type: RebookTradeResponseIdentifierType$inboundSchema.optional(),
  issuing_region_code: z.string().optional(),
  local_market_trade_date: z.nullable(
    z.lazy(() => RebookTradeResponseLocalMarketTradeDate$inboundSchema),
  ).optional(),
  lot_matching_instructions: z.array(BookingLot$inboundSchema).optional(),
  mic_code: z.string().optional(),
  name: z.string().optional(),
  open: z.boolean().optional(),
  order_id: z.string().optional(),
  route_type: RebookTradeResponseRouteType$inboundSchema.optional(),
  settlement_date: z.nullable(
    z.lazy(() => RebookTradeResponseSettlementDate$inboundSchema),
  ).optional(),
  side: RebookTradeResponseSide$inboundSchema.optional(),
  side_modifier: RebookTradeResponseSideModifier$inboundSchema.optional(),
  source_application: z.string().optional(),
  special_instructions: z.array(
    RebookTradeResponseSpecialInstructions$inboundSchema,
  ).optional(),
  trade_id: z.string().optional(),
  venue: RebookTradeResponseVenue$inboundSchema.optional(),
  when_issued: RebookTradeResponseWhenIssued$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "account_id": "accountId",
    "activity_id": "activityId",
    "additional_instructions": "additionalInstructions",
    "alternate_order_id": "alternateOrderId",
    "asset_type": "assetType",
    "broker_capacity": "brokerCapacity",
    "client_order_id": "clientOrderId",
    "executing_broker": "executingBroker",
    "identifier_type": "identifierType",
    "issuing_region_code": "issuingRegionCode",
    "local_market_trade_date": "localMarketTradeDate",
    "lot_matching_instructions": "lotMatchingInstructions",
    "mic_code": "micCode",
    "order_id": "orderId",
    "route_type": "routeType",
    "settlement_date": "settlementDate",
    "side_modifier": "sideModifier",
    "source_application": "sourceApplication",
    "special_instructions": "specialInstructions",
    "trade_id": "tradeId",
    "when_issued": "whenIssued",
  });
});

/** @internal */
export type NewTrade$Outbound = {
  account_id?: string | undefined;
  activity_id?: string | undefined;
  additional_instructions?: string | undefined;
  alternate_order_id?: string | undefined;
  asset_type?: string | undefined;
  broker_capacity?: string | undefined;
  client_order_id?: string | undefined;
  executing_broker?: string | undefined;
  executions?: Array<Execution$Outbound> | undefined;
  fees?: Array<BookingFee$Outbound> | undefined;
  identifier?: string | undefined;
  identifier_type?: string | undefined;
  issuing_region_code?: string | undefined;
  local_market_trade_date?:
    | RebookTradeResponseLocalMarketTradeDate$Outbound
    | null
    | undefined;
  lot_matching_instructions?: Array<BookingLot$Outbound> | undefined;
  mic_code?: string | undefined;
  name?: string | undefined;
  open?: boolean | undefined;
  order_id?: string | undefined;
  route_type?: string | undefined;
  settlement_date?:
    | RebookTradeResponseSettlementDate$Outbound
    | null
    | undefined;
  side?: string | undefined;
  side_modifier?: string | undefined;
  source_application?: string | undefined;
  special_instructions?: Array<string> | undefined;
  trade_id?: string | undefined;
  venue?: string | undefined;
  when_issued?: string | undefined;
};

/** @internal */
export const NewTrade$outboundSchema: z.ZodType<
  NewTrade$Outbound,
  z.ZodTypeDef,
  NewTrade
> = z.object({
  accountId: z.string().optional(),
  activityId: z.string().optional(),
  additionalInstructions: z.string().optional(),
  alternateOrderId: z.string().optional(),
  assetType: RebookTradeResponseAssetType$outboundSchema.optional(),
  brokerCapacity: RebookTradeResponseBrokerCapacity$outboundSchema.optional(),
  clientOrderId: z.string().optional(),
  executingBroker: z.string().optional(),
  executions: z.array(Execution$outboundSchema).optional(),
  fees: z.array(BookingFee$outboundSchema).optional(),
  identifier: z.string().optional(),
  identifierType: RebookTradeResponseIdentifierType$outboundSchema.optional(),
  issuingRegionCode: z.string().optional(),
  localMarketTradeDate: z.nullable(
    z.lazy(() => RebookTradeResponseLocalMarketTradeDate$outboundSchema),
  ).optional(),
  lotMatchingInstructions: z.array(BookingLot$outboundSchema).optional(),
  micCode: z.string().optional(),
  name: z.string().optional(),
  open: z.boolean().optional(),
  orderId: z.string().optional(),
  routeType: RebookTradeResponseRouteType$outboundSchema.optional(),
  settlementDate: z.nullable(
    z.lazy(() => RebookTradeResponseSettlementDate$outboundSchema),
  ).optional(),
  side: RebookTradeResponseSide$outboundSchema.optional(),
  sideModifier: RebookTradeResponseSideModifier$outboundSchema.optional(),
  sourceApplication: z.string().optional(),
  specialInstructions: z.array(
    RebookTradeResponseSpecialInstructions$outboundSchema,
  ).optional(),
  tradeId: z.string().optional(),
  venue: RebookTradeResponseVenue$outboundSchema.optional(),
  whenIssued: RebookTradeResponseWhenIssued$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    accountId: "account_id",
    activityId: "activity_id",
    additionalInstructions: "additional_instructions",
    alternateOrderId: "alternate_order_id",
    assetType: "asset_type",
    brokerCapacity: "broker_capacity",
    clientOrderId: "client_order_id",
    executingBroker: "executing_broker",
    identifierType: "identifier_type",
    issuingRegionCode: "issuing_region_code",
    localMarketTradeDate: "local_market_trade_date",
    lotMatchingInstructions: "lot_matching_instructions",
    micCode: "mic_code",
    orderId: "order_id",
    routeType: "route_type",
    settlementDate: "settlement_date",
    sideModifier: "side_modifier",
    sourceApplication: "source_application",
    specialInstructions: "special_instructions",
    tradeId: "trade_id",
    whenIssued: "when_issued",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NewTrade$ {
  /** @deprecated use `NewTrade$inboundSchema` instead. */
  export const inboundSchema = NewTrade$inboundSchema;
  /** @deprecated use `NewTrade$outboundSchema` instead. */
  export const outboundSchema = NewTrade$outboundSchema;
  /** @deprecated use `NewTrade$Outbound` instead. */
  export type Outbound = NewTrade$Outbound;
}

export function newTradeToJSON(newTrade: NewTrade): string {
  return JSON.stringify(NewTrade$outboundSchema.parse(newTrade));
}

export function newTradeFromJSON(
  jsonString: string,
): SafeParseResult<NewTrade, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NewTrade$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NewTrade' from JSON`,
  );
}

/** @internal */
export const RebookTradeResponseOriginalTradeAssetType$inboundSchema: z.ZodType<
  RebookTradeResponseOriginalTradeAssetTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseOriginalTradeAssetType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseOriginalTradeAssetType$outboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeAssetTypeOpen,
    z.ZodTypeDef,
    RebookTradeResponseOriginalTradeAssetTypeOpen
  > = z.union([
    z.nativeEnum(RebookTradeResponseOriginalTradeAssetType),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseOriginalTradeAssetType$ {
  /** @deprecated use `RebookTradeResponseOriginalTradeAssetType$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseOriginalTradeAssetType$inboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeAssetType$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseOriginalTradeAssetType$outboundSchema;
}

/** @internal */
export const RebookTradeResponseOriginalTradeBrokerCapacity$inboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeBrokerCapacityOpen,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(RebookTradeResponseOriginalTradeBrokerCapacity),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const RebookTradeResponseOriginalTradeBrokerCapacity$outboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeBrokerCapacityOpen,
    z.ZodTypeDef,
    RebookTradeResponseOriginalTradeBrokerCapacityOpen
  > = z.union([
    z.nativeEnum(RebookTradeResponseOriginalTradeBrokerCapacity),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseOriginalTradeBrokerCapacity$ {
  /** @deprecated use `RebookTradeResponseOriginalTradeBrokerCapacity$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseOriginalTradeBrokerCapacity$inboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeBrokerCapacity$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseOriginalTradeBrokerCapacity$outboundSchema;
}

/** @internal */
export const RebookTradeResponseOriginalTradeIdentifierType$inboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeIdentifierTypeOpen,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(RebookTradeResponseOriginalTradeIdentifierType),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const RebookTradeResponseOriginalTradeIdentifierType$outboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeIdentifierTypeOpen,
    z.ZodTypeDef,
    RebookTradeResponseOriginalTradeIdentifierTypeOpen
  > = z.union([
    z.nativeEnum(RebookTradeResponseOriginalTradeIdentifierType),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseOriginalTradeIdentifierType$ {
  /** @deprecated use `RebookTradeResponseOriginalTradeIdentifierType$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseOriginalTradeIdentifierType$inboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeIdentifierType$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseOriginalTradeIdentifierType$outboundSchema;
}

/** @internal */
export const RebookTradeResponseOriginalTradeLocalMarketTradeDate$inboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeLocalMarketTradeDate,
    z.ZodTypeDef,
    unknown
  > = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
  });

/** @internal */
export type RebookTradeResponseOriginalTradeLocalMarketTradeDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const RebookTradeResponseOriginalTradeLocalMarketTradeDate$outboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeLocalMarketTradeDate$Outbound,
    z.ZodTypeDef,
    RebookTradeResponseOriginalTradeLocalMarketTradeDate
  > = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseOriginalTradeLocalMarketTradeDate$ {
  /** @deprecated use `RebookTradeResponseOriginalTradeLocalMarketTradeDate$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseOriginalTradeLocalMarketTradeDate$inboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeLocalMarketTradeDate$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseOriginalTradeLocalMarketTradeDate$outboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeLocalMarketTradeDate$Outbound` instead. */
  export type Outbound =
    RebookTradeResponseOriginalTradeLocalMarketTradeDate$Outbound;
}

export function rebookTradeResponseOriginalTradeLocalMarketTradeDateToJSON(
  rebookTradeResponseOriginalTradeLocalMarketTradeDate:
    RebookTradeResponseOriginalTradeLocalMarketTradeDate,
): string {
  return JSON.stringify(
    RebookTradeResponseOriginalTradeLocalMarketTradeDate$outboundSchema.parse(
      rebookTradeResponseOriginalTradeLocalMarketTradeDate,
    ),
  );
}

export function rebookTradeResponseOriginalTradeLocalMarketTradeDateFromJSON(
  jsonString: string,
): SafeParseResult<
  RebookTradeResponseOriginalTradeLocalMarketTradeDate,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RebookTradeResponseOriginalTradeLocalMarketTradeDate$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RebookTradeResponseOriginalTradeLocalMarketTradeDate' from JSON`,
  );
}

/** @internal */
export const RebookTradeResponseOriginalTradeRouteType$inboundSchema: z.ZodType<
  RebookTradeResponseOriginalTradeRouteTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseOriginalTradeRouteType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseOriginalTradeRouteType$outboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeRouteTypeOpen,
    z.ZodTypeDef,
    RebookTradeResponseOriginalTradeRouteTypeOpen
  > = z.union([
    z.nativeEnum(RebookTradeResponseOriginalTradeRouteType),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseOriginalTradeRouteType$ {
  /** @deprecated use `RebookTradeResponseOriginalTradeRouteType$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseOriginalTradeRouteType$inboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeRouteType$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseOriginalTradeRouteType$outboundSchema;
}

/** @internal */
export const RebookTradeResponseOriginalTradeSettlementDate$inboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeSettlementDate,
    z.ZodTypeDef,
    unknown
  > = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
  });

/** @internal */
export type RebookTradeResponseOriginalTradeSettlementDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const RebookTradeResponseOriginalTradeSettlementDate$outboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeSettlementDate$Outbound,
    z.ZodTypeDef,
    RebookTradeResponseOriginalTradeSettlementDate
  > = z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseOriginalTradeSettlementDate$ {
  /** @deprecated use `RebookTradeResponseOriginalTradeSettlementDate$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseOriginalTradeSettlementDate$inboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeSettlementDate$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseOriginalTradeSettlementDate$outboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeSettlementDate$Outbound` instead. */
  export type Outbound =
    RebookTradeResponseOriginalTradeSettlementDate$Outbound;
}

export function rebookTradeResponseOriginalTradeSettlementDateToJSON(
  rebookTradeResponseOriginalTradeSettlementDate:
    RebookTradeResponseOriginalTradeSettlementDate,
): string {
  return JSON.stringify(
    RebookTradeResponseOriginalTradeSettlementDate$outboundSchema.parse(
      rebookTradeResponseOriginalTradeSettlementDate,
    ),
  );
}

export function rebookTradeResponseOriginalTradeSettlementDateFromJSON(
  jsonString: string,
): SafeParseResult<
  RebookTradeResponseOriginalTradeSettlementDate,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RebookTradeResponseOriginalTradeSettlementDate$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RebookTradeResponseOriginalTradeSettlementDate' from JSON`,
  );
}

/** @internal */
export const RebookTradeResponseOriginalTradeSide$inboundSchema: z.ZodType<
  RebookTradeResponseOriginalTradeSideOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseOriginalTradeSide),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseOriginalTradeSide$outboundSchema: z.ZodType<
  RebookTradeResponseOriginalTradeSideOpen,
  z.ZodTypeDef,
  RebookTradeResponseOriginalTradeSideOpen
> = z.union([
  z.nativeEnum(RebookTradeResponseOriginalTradeSide),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseOriginalTradeSide$ {
  /** @deprecated use `RebookTradeResponseOriginalTradeSide$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseOriginalTradeSide$inboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeSide$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseOriginalTradeSide$outboundSchema;
}

/** @internal */
export const RebookTradeResponseOriginalTradeSideModifier$inboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeSideModifierOpen,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(RebookTradeResponseOriginalTradeSideModifier),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const RebookTradeResponseOriginalTradeSideModifier$outboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeSideModifierOpen,
    z.ZodTypeDef,
    RebookTradeResponseOriginalTradeSideModifierOpen
  > = z.union([
    z.nativeEnum(RebookTradeResponseOriginalTradeSideModifier),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseOriginalTradeSideModifier$ {
  /** @deprecated use `RebookTradeResponseOriginalTradeSideModifier$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseOriginalTradeSideModifier$inboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeSideModifier$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseOriginalTradeSideModifier$outboundSchema;
}

/** @internal */
export const RebookTradeResponseOriginalTradeSpecialInstructions$inboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeSpecialInstructionsOpen,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(RebookTradeResponseOriginalTradeSpecialInstructions),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const RebookTradeResponseOriginalTradeSpecialInstructions$outboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeSpecialInstructionsOpen,
    z.ZodTypeDef,
    RebookTradeResponseOriginalTradeSpecialInstructionsOpen
  > = z.union([
    z.nativeEnum(RebookTradeResponseOriginalTradeSpecialInstructions),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseOriginalTradeSpecialInstructions$ {
  /** @deprecated use `RebookTradeResponseOriginalTradeSpecialInstructions$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseOriginalTradeSpecialInstructions$inboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeSpecialInstructions$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseOriginalTradeSpecialInstructions$outboundSchema;
}

/** @internal */
export const RebookTradeResponseOriginalTradeVenue$inboundSchema: z.ZodType<
  RebookTradeResponseOriginalTradeVenueOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RebookTradeResponseOriginalTradeVenue),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RebookTradeResponseOriginalTradeVenue$outboundSchema: z.ZodType<
  RebookTradeResponseOriginalTradeVenueOpen,
  z.ZodTypeDef,
  RebookTradeResponseOriginalTradeVenueOpen
> = z.union([
  z.nativeEnum(RebookTradeResponseOriginalTradeVenue),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseOriginalTradeVenue$ {
  /** @deprecated use `RebookTradeResponseOriginalTradeVenue$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseOriginalTradeVenue$inboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeVenue$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseOriginalTradeVenue$outboundSchema;
}

/** @internal */
export const RebookTradeResponseOriginalTradeWhenIssued$inboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeWhenIssuedOpen,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(RebookTradeResponseOriginalTradeWhenIssued),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const RebookTradeResponseOriginalTradeWhenIssued$outboundSchema:
  z.ZodType<
    RebookTradeResponseOriginalTradeWhenIssuedOpen,
    z.ZodTypeDef,
    RebookTradeResponseOriginalTradeWhenIssuedOpen
  > = z.union([
    z.nativeEnum(RebookTradeResponseOriginalTradeWhenIssued),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponseOriginalTradeWhenIssued$ {
  /** @deprecated use `RebookTradeResponseOriginalTradeWhenIssued$inboundSchema` instead. */
  export const inboundSchema =
    RebookTradeResponseOriginalTradeWhenIssued$inboundSchema;
  /** @deprecated use `RebookTradeResponseOriginalTradeWhenIssued$outboundSchema` instead. */
  export const outboundSchema =
    RebookTradeResponseOriginalTradeWhenIssued$outboundSchema;
}

/** @internal */
export const OriginalTrade$inboundSchema: z.ZodType<
  OriginalTrade,
  z.ZodTypeDef,
  unknown
> = z.object({
  account_id: z.string().optional(),
  activity_id: z.string().optional(),
  additional_instructions: z.string().optional(),
  alternate_order_id: z.string().optional(),
  asset_type: RebookTradeResponseOriginalTradeAssetType$inboundSchema
    .optional(),
  broker_capacity: RebookTradeResponseOriginalTradeBrokerCapacity$inboundSchema
    .optional(),
  client_order_id: z.string().optional(),
  executing_broker: z.string().optional(),
  executions: z.array(Execution$inboundSchema).optional(),
  fees: z.array(BookingFee$inboundSchema).optional(),
  identifier: z.string().optional(),
  identifier_type: RebookTradeResponseOriginalTradeIdentifierType$inboundSchema
    .optional(),
  issuing_region_code: z.string().optional(),
  local_market_trade_date: z.nullable(
    z.lazy(() =>
      RebookTradeResponseOriginalTradeLocalMarketTradeDate$inboundSchema
    ),
  ).optional(),
  lot_matching_instructions: z.array(BookingLot$inboundSchema).optional(),
  mic_code: z.string().optional(),
  name: z.string().optional(),
  open: z.boolean().optional(),
  order_id: z.string().optional(),
  route_type: RebookTradeResponseOriginalTradeRouteType$inboundSchema
    .optional(),
  settlement_date: z.nullable(
    z.lazy(() => RebookTradeResponseOriginalTradeSettlementDate$inboundSchema),
  ).optional(),
  side: RebookTradeResponseOriginalTradeSide$inboundSchema.optional(),
  side_modifier: RebookTradeResponseOriginalTradeSideModifier$inboundSchema
    .optional(),
  source_application: z.string().optional(),
  special_instructions: z.array(
    RebookTradeResponseOriginalTradeSpecialInstructions$inboundSchema,
  ).optional(),
  trade_id: z.string().optional(),
  venue: RebookTradeResponseOriginalTradeVenue$inboundSchema.optional(),
  when_issued: RebookTradeResponseOriginalTradeWhenIssued$inboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "account_id": "accountId",
    "activity_id": "activityId",
    "additional_instructions": "additionalInstructions",
    "alternate_order_id": "alternateOrderId",
    "asset_type": "assetType",
    "broker_capacity": "brokerCapacity",
    "client_order_id": "clientOrderId",
    "executing_broker": "executingBroker",
    "identifier_type": "identifierType",
    "issuing_region_code": "issuingRegionCode",
    "local_market_trade_date": "localMarketTradeDate",
    "lot_matching_instructions": "lotMatchingInstructions",
    "mic_code": "micCode",
    "order_id": "orderId",
    "route_type": "routeType",
    "settlement_date": "settlementDate",
    "side_modifier": "sideModifier",
    "source_application": "sourceApplication",
    "special_instructions": "specialInstructions",
    "trade_id": "tradeId",
    "when_issued": "whenIssued",
  });
});

/** @internal */
export type OriginalTrade$Outbound = {
  account_id?: string | undefined;
  activity_id?: string | undefined;
  additional_instructions?: string | undefined;
  alternate_order_id?: string | undefined;
  asset_type?: string | undefined;
  broker_capacity?: string | undefined;
  client_order_id?: string | undefined;
  executing_broker?: string | undefined;
  executions?: Array<Execution$Outbound> | undefined;
  fees?: Array<BookingFee$Outbound> | undefined;
  identifier?: string | undefined;
  identifier_type?: string | undefined;
  issuing_region_code?: string | undefined;
  local_market_trade_date?:
    | RebookTradeResponseOriginalTradeLocalMarketTradeDate$Outbound
    | null
    | undefined;
  lot_matching_instructions?: Array<BookingLot$Outbound> | undefined;
  mic_code?: string | undefined;
  name?: string | undefined;
  open?: boolean | undefined;
  order_id?: string | undefined;
  route_type?: string | undefined;
  settlement_date?:
    | RebookTradeResponseOriginalTradeSettlementDate$Outbound
    | null
    | undefined;
  side?: string | undefined;
  side_modifier?: string | undefined;
  source_application?: string | undefined;
  special_instructions?: Array<string> | undefined;
  trade_id?: string | undefined;
  venue?: string | undefined;
  when_issued?: string | undefined;
};

/** @internal */
export const OriginalTrade$outboundSchema: z.ZodType<
  OriginalTrade$Outbound,
  z.ZodTypeDef,
  OriginalTrade
> = z.object({
  accountId: z.string().optional(),
  activityId: z.string().optional(),
  additionalInstructions: z.string().optional(),
  alternateOrderId: z.string().optional(),
  assetType: RebookTradeResponseOriginalTradeAssetType$outboundSchema
    .optional(),
  brokerCapacity: RebookTradeResponseOriginalTradeBrokerCapacity$outboundSchema
    .optional(),
  clientOrderId: z.string().optional(),
  executingBroker: z.string().optional(),
  executions: z.array(Execution$outboundSchema).optional(),
  fees: z.array(BookingFee$outboundSchema).optional(),
  identifier: z.string().optional(),
  identifierType: RebookTradeResponseOriginalTradeIdentifierType$outboundSchema
    .optional(),
  issuingRegionCode: z.string().optional(),
  localMarketTradeDate: z.nullable(
    z.lazy(() =>
      RebookTradeResponseOriginalTradeLocalMarketTradeDate$outboundSchema
    ),
  ).optional(),
  lotMatchingInstructions: z.array(BookingLot$outboundSchema).optional(),
  micCode: z.string().optional(),
  name: z.string().optional(),
  open: z.boolean().optional(),
  orderId: z.string().optional(),
  routeType: RebookTradeResponseOriginalTradeRouteType$outboundSchema
    .optional(),
  settlementDate: z.nullable(
    z.lazy(() => RebookTradeResponseOriginalTradeSettlementDate$outboundSchema),
  ).optional(),
  side: RebookTradeResponseOriginalTradeSide$outboundSchema.optional(),
  sideModifier: RebookTradeResponseOriginalTradeSideModifier$outboundSchema
    .optional(),
  sourceApplication: z.string().optional(),
  specialInstructions: z.array(
    RebookTradeResponseOriginalTradeSpecialInstructions$outboundSchema,
  ).optional(),
  tradeId: z.string().optional(),
  venue: RebookTradeResponseOriginalTradeVenue$outboundSchema.optional(),
  whenIssued: RebookTradeResponseOriginalTradeWhenIssued$outboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    accountId: "account_id",
    activityId: "activity_id",
    additionalInstructions: "additional_instructions",
    alternateOrderId: "alternate_order_id",
    assetType: "asset_type",
    brokerCapacity: "broker_capacity",
    clientOrderId: "client_order_id",
    executingBroker: "executing_broker",
    identifierType: "identifier_type",
    issuingRegionCode: "issuing_region_code",
    localMarketTradeDate: "local_market_trade_date",
    lotMatchingInstructions: "lot_matching_instructions",
    micCode: "mic_code",
    orderId: "order_id",
    routeType: "route_type",
    settlementDate: "settlement_date",
    sideModifier: "side_modifier",
    sourceApplication: "source_application",
    specialInstructions: "special_instructions",
    tradeId: "trade_id",
    whenIssued: "when_issued",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OriginalTrade$ {
  /** @deprecated use `OriginalTrade$inboundSchema` instead. */
  export const inboundSchema = OriginalTrade$inboundSchema;
  /** @deprecated use `OriginalTrade$outboundSchema` instead. */
  export const outboundSchema = OriginalTrade$outboundSchema;
  /** @deprecated use `OriginalTrade$Outbound` instead. */
  export type Outbound = OriginalTrade$Outbound;
}

export function originalTradeToJSON(originalTrade: OriginalTrade): string {
  return JSON.stringify(OriginalTrade$outboundSchema.parse(originalTrade));
}

export function originalTradeFromJSON(
  jsonString: string,
): SafeParseResult<OriginalTrade, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OriginalTrade$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OriginalTrade' from JSON`,
  );
}

/** @internal */
export const RebookTradeResponse$inboundSchema: z.ZodType<
  RebookTradeResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  new_trade: z.nullable(z.lazy(() => NewTrade$inboundSchema)).optional(),
  original_trade: z.nullable(z.lazy(() => OriginalTrade$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "new_trade": "newTrade",
    "original_trade": "originalTrade",
  });
});

/** @internal */
export type RebookTradeResponse$Outbound = {
  new_trade?: NewTrade$Outbound | null | undefined;
  original_trade?: OriginalTrade$Outbound | null | undefined;
};

/** @internal */
export const RebookTradeResponse$outboundSchema: z.ZodType<
  RebookTradeResponse$Outbound,
  z.ZodTypeDef,
  RebookTradeResponse
> = z.object({
  newTrade: z.nullable(z.lazy(() => NewTrade$outboundSchema)).optional(),
  originalTrade: z.nullable(z.lazy(() => OriginalTrade$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    newTrade: "new_trade",
    originalTrade: "original_trade",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RebookTradeResponse$ {
  /** @deprecated use `RebookTradeResponse$inboundSchema` instead. */
  export const inboundSchema = RebookTradeResponse$inboundSchema;
  /** @deprecated use `RebookTradeResponse$outboundSchema` instead. */
  export const outboundSchema = RebookTradeResponse$outboundSchema;
  /** @deprecated use `RebookTradeResponse$Outbound` instead. */
  export type Outbound = RebookTradeResponse$Outbound;
}

export function rebookTradeResponseToJSON(
  rebookTradeResponse: RebookTradeResponse,
): string {
  return JSON.stringify(
    RebookTradeResponse$outboundSchema.parse(rebookTradeResponse),
  );
}

export function rebookTradeResponseFromJSON(
  jsonString: string,
): SafeParseResult<RebookTradeResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RebookTradeResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RebookTradeResponse' from JSON`,
  );
}
