/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Identification,
  Identification$inboundSchema,
  Identification$Outbound,
  Identification$outboundSchema,
} from "./identification.js";
import {
  PostalAddress,
  PostalAddress$inboundSchema,
  PostalAddress$Outbound,
  PostalAddress$outboundSchema,
} from "./postaladdress.js";

/**
 * The type of device (e.g., mobile, desktop, tablet)
 */
export enum IdentityLookupDeviceType {
  DeviceTypeUnspecified = "DEVICE_TYPE_UNSPECIFIED",
  Desktop = "DESKTOP",
  Mobile = "MOBILE",
  Tablet = "TABLET",
}
/**
 * The type of device (e.g., mobile, desktop, tablet)
 */
export type IdentityLookupDeviceTypeOpen = OpenEnum<
  typeof IdentityLookupDeviceType
>;

/**
 * Geographic location coordinates of the end-user's device
 */
export type Geolocation = {
  /**
   * The latitude in degrees. It must be in the range [-90.0, +90.0].
   */
  latitude?: number | undefined;
  /**
   * The longitude in degrees. It must be in the range [-180.0, +180.0].
   */
  longitude?: number | undefined;
};

/**
 * Method used to determine the end-user's device geolocation
 */
export enum IdentityLookupGeolocationMechanism {
  GeolocationMechanismUnspecified = "GEOLOCATION_MECHANISM_UNSPECIFIED",
  DeviceGps = "DEVICE_GPS",
  IpLookup = "IP_LOOKUP",
}
/**
 * Method used to determine the end-user's device geolocation
 */
export type IdentityLookupGeolocationMechanismOpen = OpenEnum<
  typeof IdentityLookupGeolocationMechanism
>;

/**
 * End-user device metadata for fraud detection and compliance purposes This must be the metadata from the actual end-user's device, not from any intermediate proxy or client server
 */
export type DeviceMetadata = {
  /**
   * Unique identifier for the device
   */
  deviceId?: string | undefined;
  /**
   * The type of device (e.g., mobile, desktop, tablet)
   */
  deviceType?: IdentityLookupDeviceTypeOpen | undefined;
  /**
   * Geographic location coordinates of the end-user's device
   */
  geolocation?: Geolocation | null | undefined;
  /**
   * Method used to determine the end-user's device geolocation
   */
  geolocationMechanism?: IdentityLookupGeolocationMechanismOpen | undefined;
  /**
   * The IP address of the end-user's device This must be the actual end-user's IP address, not the IP of any proxy or client server Must be a valid IPv4 or IPv6 address format IPv4 examples: "203.0.113.42", "198.51.100.1", "8.8.8.8" IPv6 examples: "2001:0db8:85a3::8a2e:0370:7334", "2606:4700:4700::1111"
   */
  ipAddress?: string | undefined;
  /**
   * The user agent string from the end-user's device browser or application
   */
  userAgent?: string | undefined;
};

/**
 * The type of identification document
 */
export enum IdentityLookupType {
  TypeUnspecified = "TYPE_UNSPECIFIED",
  Ssn = "SSN",
}
/**
 * The type of identification document
 */
export type IdentityLookupTypeOpen = OpenEnum<typeof IdentityLookupType>;

/**
 * Identification document for verification
 */
export type IdentityLookupIdentification = {
  /**
   * CLDR format
   */
  regionCode?: string | undefined;
  /**
   * The type of identification document
   */
  type?: IdentityLookupTypeOpen | undefined;
  /**
   * The value of the identification document
   */
  value?: string | undefined;
};

/**
 * Birth date of the identity
 */
export type IdentityLookupBirthDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * A short code.
 *
 * @remarks
 *
 *  Reference(s):
 *  - https://en.wikipedia.org/wiki/Short_code
 */
export type IdentityLookupLookupResultShortCode = {
  /**
   * Required. The short code digits, without a leading plus ('+') or country calling code, e.g. "611".
   */
  number?: string | undefined;
  /**
   * Required. The BCP-47 region code of the location where calls to this short code can be made, such as "US" and "BB".
   *
   * @remarks
   *
   *  Reference(s):
   *  - http://www.unicode.org/reports/tr35/#unicode_region_subtag
   */
  regionCode?: string | undefined;
};

/**
 * Phone number associated with the identity
 */
export type IdentityLookupLookupResultPhoneNumber = {
  /**
   * The phone number, represented as a leading plus sign ('+'), followed by a phone number that uses a relaxed ITU E.164 format consisting of the country calling code (1 to 3 digits) and the subscriber number, with no additional spaces or formatting, e.g.: - correct: "+15552220123" - incorrect: "+1 (555) 222-01234 x123".
   *
   * @remarks
   *
   *  The ITU E.164 format limits the latter to 12 digits, but in practice not all countries respect that, so we relax that restriction here. National-only numbers are not allowed.
   *
   *  References: - https://www.itu.int/rec/T-REC-E.164-201011-I - https://en.wikipedia.org/wiki/E.164. - https://en.wikipedia.org/wiki/List_of_country_calling_codes
   */
  e164Number?: string | undefined;
  /**
   * The phone number's extension. The extension is not standardized in ITU recommendations, except for being defined as a series of numbers with a maximum length of 40 digits. Other than digits, some other dialing characters such as ',' (indicating a wait) or '#' may be stored here.
   *
   * @remarks
   *
   *  Note that no regions currently use extensions with short codes, so this field is normally only set in conjunction with an E.164 number. It is held separately from the E.164 number to allow for short code extensions in the future.
   */
  extension?: string | undefined;
  /**
   * A short code.
   *
   * @remarks
   *
   *  Reference(s):
   *  - https://en.wikipedia.org/wiki/Short_code
   */
  shortCode?: IdentityLookupLookupResultShortCode | null | undefined;
};

/**
 * Will be populated when `state` is `IDENTITY_FOUND` Depending on the confidence level, some fields may be missing
 */
export type LookupResult = {
  /**
   * Addresses associated with the identity
   */
  addresses?: Array<PostalAddress> | undefined;
  /**
   * Birth date of the identity
   */
  birthDate?: IdentityLookupBirthDate | null | undefined;
  /**
   * Email addresses associated with the identity
   */
  emails?: Array<string> | undefined;
  /**
   * Family name of the identity
   */
  familyName?: string | undefined;
  /**
   * Given name of the identity
   */
  givenName?: string | undefined;
  /**
   * Identification documents associated with the identity
   */
  identification?: Array<Identification> | undefined;
  /**
   * Middle name of the identity
   */
  middleName?: string | undefined;
  /**
   * Phone number associated with the identity
   */
  phoneNumber?: IdentityLookupLookupResultPhoneNumber | null | undefined;
};

/**
 * A short code.
 *
 * @remarks
 *
 *  Reference(s):
 *  - https://en.wikipedia.org/wiki/Short_code
 */
export type IdentityLookupShortCode = {
  /**
   * Required. The short code digits, without a leading plus ('+') or country calling code, e.g. "611".
   */
  number?: string | undefined;
  /**
   * Required. The BCP-47 region code of the location where calls to this short code can be made, such as "US" and "BB".
   *
   * @remarks
   *
   *  Reference(s):
   *  - http://www.unicode.org/reports/tr35/#unicode_region_subtag
   */
  regionCode?: string | undefined;
};

/**
 * Phone number to be used for 2FA in E.164 format
 */
export type IdentityLookupPhoneNumber = {
  /**
   * The phone number, represented as a leading plus sign ('+'), followed by a phone number that uses a relaxed ITU E.164 format consisting of the country calling code (1 to 3 digits) and the subscriber number, with no additional spaces or formatting, e.g.: - correct: "+15552220123" - incorrect: "+1 (555) 222-01234 x123".
   *
   * @remarks
   *
   *  The ITU E.164 format limits the latter to 12 digits, but in practice not all countries respect that, so we relax that restriction here. National-only numbers are not allowed.
   *
   *  References: - https://www.itu.int/rec/T-REC-E.164-201011-I - https://en.wikipedia.org/wiki/E.164. - https://en.wikipedia.org/wiki/List_of_country_calling_codes
   */
  e164Number?: string | undefined;
  /**
   * The phone number's extension. The extension is not standardized in ITU recommendations, except for being defined as a series of numbers with a maximum length of 40 digits. Other than digits, some other dialing characters such as ',' (indicating a wait) or '#' may be stored here.
   *
   * @remarks
   *
   *  Note that no regions currently use extensions with short codes, so this field is normally only set in conjunction with an E.164 number. It is held separately from the E.164 number to allow for short code extensions in the future.
   */
  extension?: string | undefined;
  /**
   * A short code.
   *
   * @remarks
   *
   *  Reference(s):
   *  - https://en.wikipedia.org/wiki/Short_code
   */
  shortCode?: IdentityLookupShortCode | null | undefined;
};

/**
 * Current state of the identity lookup
 */
export enum IdentityLookupState {
  StateUnspecified = "STATE_UNSPECIFIED",
  VerificationPending = "VERIFICATION_PENDING",
  VerificationExpired = "VERIFICATION_EXPIRED",
  IdentityFound = "IDENTITY_FOUND",
  NoIdentityFound = "NO_IDENTITY_FOUND",
}
/**
 * Current state of the identity lookup
 */
export type IdentityLookupStateOpen = OpenEnum<typeof IdentityLookupState>;

/**
 * Represents an identity lookup resource
 */
export type IdentityLookup = {
  /**
   * Time when the identity lookup was created
   */
  createTime?: Date | null | undefined;
  /**
   * End-user device metadata for fraud detection and compliance purposes This must be the metadata from the actual end-user's device, not from any intermediate proxy or client server
   */
  deviceMetadata?: DeviceMetadata | null | undefined;
  /**
   * Identification document for verification
   */
  identification?: IdentityLookupIdentification | null | undefined;
  /**
   * Will be populated when `state` is `IDENTITY_FOUND` Depending on the confidence level, some fields may be missing
   */
  lookupResult?: LookupResult | null | undefined;
  /**
   * The resource name of the identity lookup
   */
  name?: string | undefined;
  /**
   * Phone number to be used for 2FA in E.164 format
   */
  phoneNumber?: IdentityLookupPhoneNumber | null | undefined;
  /**
   * Current state of the identity lookup
   */
  state?: IdentityLookupStateOpen | undefined;
  /**
   * Time when the identity lookup was last updated
   */
  updateTime?: Date | null | undefined;
  /**
   * Verify User has consented to an identity lookup
   */
  userConsent?: boolean | undefined;
};

/** @internal */
export const IdentityLookupDeviceType$inboundSchema: z.ZodType<
  IdentityLookupDeviceTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(IdentityLookupDeviceType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const IdentityLookupDeviceType$outboundSchema: z.ZodType<
  IdentityLookupDeviceTypeOpen,
  z.ZodTypeDef,
  IdentityLookupDeviceTypeOpen
> = z.union([
  z.nativeEnum(IdentityLookupDeviceType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdentityLookupDeviceType$ {
  /** @deprecated use `IdentityLookupDeviceType$inboundSchema` instead. */
  export const inboundSchema = IdentityLookupDeviceType$inboundSchema;
  /** @deprecated use `IdentityLookupDeviceType$outboundSchema` instead. */
  export const outboundSchema = IdentityLookupDeviceType$outboundSchema;
}

/** @internal */
export const Geolocation$inboundSchema: z.ZodType<
  Geolocation,
  z.ZodTypeDef,
  unknown
> = z.object({
  latitude: z.number().optional(),
  longitude: z.number().optional(),
});

/** @internal */
export type Geolocation$Outbound = {
  latitude?: number | undefined;
  longitude?: number | undefined;
};

/** @internal */
export const Geolocation$outboundSchema: z.ZodType<
  Geolocation$Outbound,
  z.ZodTypeDef,
  Geolocation
> = z.object({
  latitude: z.number().optional(),
  longitude: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Geolocation$ {
  /** @deprecated use `Geolocation$inboundSchema` instead. */
  export const inboundSchema = Geolocation$inboundSchema;
  /** @deprecated use `Geolocation$outboundSchema` instead. */
  export const outboundSchema = Geolocation$outboundSchema;
  /** @deprecated use `Geolocation$Outbound` instead. */
  export type Outbound = Geolocation$Outbound;
}

export function geolocationToJSON(geolocation: Geolocation): string {
  return JSON.stringify(Geolocation$outboundSchema.parse(geolocation));
}

export function geolocationFromJSON(
  jsonString: string,
): SafeParseResult<Geolocation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Geolocation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Geolocation' from JSON`,
  );
}

/** @internal */
export const IdentityLookupGeolocationMechanism$inboundSchema: z.ZodType<
  IdentityLookupGeolocationMechanismOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(IdentityLookupGeolocationMechanism),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const IdentityLookupGeolocationMechanism$outboundSchema: z.ZodType<
  IdentityLookupGeolocationMechanismOpen,
  z.ZodTypeDef,
  IdentityLookupGeolocationMechanismOpen
> = z.union([
  z.nativeEnum(IdentityLookupGeolocationMechanism),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdentityLookupGeolocationMechanism$ {
  /** @deprecated use `IdentityLookupGeolocationMechanism$inboundSchema` instead. */
  export const inboundSchema = IdentityLookupGeolocationMechanism$inboundSchema;
  /** @deprecated use `IdentityLookupGeolocationMechanism$outboundSchema` instead. */
  export const outboundSchema =
    IdentityLookupGeolocationMechanism$outboundSchema;
}

/** @internal */
export const DeviceMetadata$inboundSchema: z.ZodType<
  DeviceMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  device_id: z.string().optional(),
  device_type: IdentityLookupDeviceType$inboundSchema.optional(),
  geolocation: z.nullable(z.lazy(() => Geolocation$inboundSchema)).optional(),
  geolocation_mechanism: IdentityLookupGeolocationMechanism$inboundSchema
    .optional(),
  ip_address: z.string().optional(),
  user_agent: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "device_id": "deviceId",
    "device_type": "deviceType",
    "geolocation_mechanism": "geolocationMechanism",
    "ip_address": "ipAddress",
    "user_agent": "userAgent",
  });
});

/** @internal */
export type DeviceMetadata$Outbound = {
  device_id?: string | undefined;
  device_type?: string | undefined;
  geolocation?: Geolocation$Outbound | null | undefined;
  geolocation_mechanism?: string | undefined;
  ip_address?: string | undefined;
  user_agent?: string | undefined;
};

/** @internal */
export const DeviceMetadata$outboundSchema: z.ZodType<
  DeviceMetadata$Outbound,
  z.ZodTypeDef,
  DeviceMetadata
> = z.object({
  deviceId: z.string().optional(),
  deviceType: IdentityLookupDeviceType$outboundSchema.optional(),
  geolocation: z.nullable(z.lazy(() => Geolocation$outboundSchema)).optional(),
  geolocationMechanism: IdentityLookupGeolocationMechanism$outboundSchema
    .optional(),
  ipAddress: z.string().optional(),
  userAgent: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    deviceId: "device_id",
    deviceType: "device_type",
    geolocationMechanism: "geolocation_mechanism",
    ipAddress: "ip_address",
    userAgent: "user_agent",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeviceMetadata$ {
  /** @deprecated use `DeviceMetadata$inboundSchema` instead. */
  export const inboundSchema = DeviceMetadata$inboundSchema;
  /** @deprecated use `DeviceMetadata$outboundSchema` instead. */
  export const outboundSchema = DeviceMetadata$outboundSchema;
  /** @deprecated use `DeviceMetadata$Outbound` instead. */
  export type Outbound = DeviceMetadata$Outbound;
}

export function deviceMetadataToJSON(deviceMetadata: DeviceMetadata): string {
  return JSON.stringify(DeviceMetadata$outboundSchema.parse(deviceMetadata));
}

export function deviceMetadataFromJSON(
  jsonString: string,
): SafeParseResult<DeviceMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeviceMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeviceMetadata' from JSON`,
  );
}

/** @internal */
export const IdentityLookupType$inboundSchema: z.ZodType<
  IdentityLookupTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(IdentityLookupType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const IdentityLookupType$outboundSchema: z.ZodType<
  IdentityLookupTypeOpen,
  z.ZodTypeDef,
  IdentityLookupTypeOpen
> = z.union([
  z.nativeEnum(IdentityLookupType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdentityLookupType$ {
  /** @deprecated use `IdentityLookupType$inboundSchema` instead. */
  export const inboundSchema = IdentityLookupType$inboundSchema;
  /** @deprecated use `IdentityLookupType$outboundSchema` instead. */
  export const outboundSchema = IdentityLookupType$outboundSchema;
}

/** @internal */
export const IdentityLookupIdentification$inboundSchema: z.ZodType<
  IdentityLookupIdentification,
  z.ZodTypeDef,
  unknown
> = z.object({
  region_code: z.string().optional(),
  type: IdentityLookupType$inboundSchema.optional(),
  value: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "region_code": "regionCode",
  });
});

/** @internal */
export type IdentityLookupIdentification$Outbound = {
  region_code?: string | undefined;
  type?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const IdentityLookupIdentification$outboundSchema: z.ZodType<
  IdentityLookupIdentification$Outbound,
  z.ZodTypeDef,
  IdentityLookupIdentification
> = z.object({
  regionCode: z.string().optional(),
  type: IdentityLookupType$outboundSchema.optional(),
  value: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    regionCode: "region_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdentityLookupIdentification$ {
  /** @deprecated use `IdentityLookupIdentification$inboundSchema` instead. */
  export const inboundSchema = IdentityLookupIdentification$inboundSchema;
  /** @deprecated use `IdentityLookupIdentification$outboundSchema` instead. */
  export const outboundSchema = IdentityLookupIdentification$outboundSchema;
  /** @deprecated use `IdentityLookupIdentification$Outbound` instead. */
  export type Outbound = IdentityLookupIdentification$Outbound;
}

export function identityLookupIdentificationToJSON(
  identityLookupIdentification: IdentityLookupIdentification,
): string {
  return JSON.stringify(
    IdentityLookupIdentification$outboundSchema.parse(
      identityLookupIdentification,
    ),
  );
}

export function identityLookupIdentificationFromJSON(
  jsonString: string,
): SafeParseResult<IdentityLookupIdentification, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IdentityLookupIdentification$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IdentityLookupIdentification' from JSON`,
  );
}

/** @internal */
export const IdentityLookupBirthDate$inboundSchema: z.ZodType<
  IdentityLookupBirthDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type IdentityLookupBirthDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const IdentityLookupBirthDate$outboundSchema: z.ZodType<
  IdentityLookupBirthDate$Outbound,
  z.ZodTypeDef,
  IdentityLookupBirthDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdentityLookupBirthDate$ {
  /** @deprecated use `IdentityLookupBirthDate$inboundSchema` instead. */
  export const inboundSchema = IdentityLookupBirthDate$inboundSchema;
  /** @deprecated use `IdentityLookupBirthDate$outboundSchema` instead. */
  export const outboundSchema = IdentityLookupBirthDate$outboundSchema;
  /** @deprecated use `IdentityLookupBirthDate$Outbound` instead. */
  export type Outbound = IdentityLookupBirthDate$Outbound;
}

export function identityLookupBirthDateToJSON(
  identityLookupBirthDate: IdentityLookupBirthDate,
): string {
  return JSON.stringify(
    IdentityLookupBirthDate$outboundSchema.parse(identityLookupBirthDate),
  );
}

export function identityLookupBirthDateFromJSON(
  jsonString: string,
): SafeParseResult<IdentityLookupBirthDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IdentityLookupBirthDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IdentityLookupBirthDate' from JSON`,
  );
}

/** @internal */
export const IdentityLookupLookupResultShortCode$inboundSchema: z.ZodType<
  IdentityLookupLookupResultShortCode,
  z.ZodTypeDef,
  unknown
> = z.object({
  number: z.string().optional(),
  region_code: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "region_code": "regionCode",
  });
});

/** @internal */
export type IdentityLookupLookupResultShortCode$Outbound = {
  number?: string | undefined;
  region_code?: string | undefined;
};

/** @internal */
export const IdentityLookupLookupResultShortCode$outboundSchema: z.ZodType<
  IdentityLookupLookupResultShortCode$Outbound,
  z.ZodTypeDef,
  IdentityLookupLookupResultShortCode
> = z.object({
  number: z.string().optional(),
  regionCode: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    regionCode: "region_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdentityLookupLookupResultShortCode$ {
  /** @deprecated use `IdentityLookupLookupResultShortCode$inboundSchema` instead. */
  export const inboundSchema =
    IdentityLookupLookupResultShortCode$inboundSchema;
  /** @deprecated use `IdentityLookupLookupResultShortCode$outboundSchema` instead. */
  export const outboundSchema =
    IdentityLookupLookupResultShortCode$outboundSchema;
  /** @deprecated use `IdentityLookupLookupResultShortCode$Outbound` instead. */
  export type Outbound = IdentityLookupLookupResultShortCode$Outbound;
}

export function identityLookupLookupResultShortCodeToJSON(
  identityLookupLookupResultShortCode: IdentityLookupLookupResultShortCode,
): string {
  return JSON.stringify(
    IdentityLookupLookupResultShortCode$outboundSchema.parse(
      identityLookupLookupResultShortCode,
    ),
  );
}

export function identityLookupLookupResultShortCodeFromJSON(
  jsonString: string,
): SafeParseResult<IdentityLookupLookupResultShortCode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      IdentityLookupLookupResultShortCode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IdentityLookupLookupResultShortCode' from JSON`,
  );
}

/** @internal */
export const IdentityLookupLookupResultPhoneNumber$inboundSchema: z.ZodType<
  IdentityLookupLookupResultPhoneNumber,
  z.ZodTypeDef,
  unknown
> = z.object({
  e164_number: z.string().optional(),
  extension: z.string().optional(),
  short_code: z.nullable(
    z.lazy(() => IdentityLookupLookupResultShortCode$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "e164_number": "e164Number",
    "short_code": "shortCode",
  });
});

/** @internal */
export type IdentityLookupLookupResultPhoneNumber$Outbound = {
  e164_number?: string | undefined;
  extension?: string | undefined;
  short_code?: IdentityLookupLookupResultShortCode$Outbound | null | undefined;
};

/** @internal */
export const IdentityLookupLookupResultPhoneNumber$outboundSchema: z.ZodType<
  IdentityLookupLookupResultPhoneNumber$Outbound,
  z.ZodTypeDef,
  IdentityLookupLookupResultPhoneNumber
> = z.object({
  e164Number: z.string().optional(),
  extension: z.string().optional(),
  shortCode: z.nullable(
    z.lazy(() => IdentityLookupLookupResultShortCode$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    e164Number: "e164_number",
    shortCode: "short_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdentityLookupLookupResultPhoneNumber$ {
  /** @deprecated use `IdentityLookupLookupResultPhoneNumber$inboundSchema` instead. */
  export const inboundSchema =
    IdentityLookupLookupResultPhoneNumber$inboundSchema;
  /** @deprecated use `IdentityLookupLookupResultPhoneNumber$outboundSchema` instead. */
  export const outboundSchema =
    IdentityLookupLookupResultPhoneNumber$outboundSchema;
  /** @deprecated use `IdentityLookupLookupResultPhoneNumber$Outbound` instead. */
  export type Outbound = IdentityLookupLookupResultPhoneNumber$Outbound;
}

export function identityLookupLookupResultPhoneNumberToJSON(
  identityLookupLookupResultPhoneNumber: IdentityLookupLookupResultPhoneNumber,
): string {
  return JSON.stringify(
    IdentityLookupLookupResultPhoneNumber$outboundSchema.parse(
      identityLookupLookupResultPhoneNumber,
    ),
  );
}

export function identityLookupLookupResultPhoneNumberFromJSON(
  jsonString: string,
): SafeParseResult<IdentityLookupLookupResultPhoneNumber, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      IdentityLookupLookupResultPhoneNumber$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IdentityLookupLookupResultPhoneNumber' from JSON`,
  );
}

/** @internal */
export const LookupResult$inboundSchema: z.ZodType<
  LookupResult,
  z.ZodTypeDef,
  unknown
> = z.object({
  addresses: z.array(PostalAddress$inboundSchema).optional(),
  birth_date: z.nullable(z.lazy(() => IdentityLookupBirthDate$inboundSchema))
    .optional(),
  emails: z.array(z.string()).optional(),
  family_name: z.string().optional(),
  given_name: z.string().optional(),
  identification: z.array(Identification$inboundSchema).optional(),
  middle_name: z.string().optional(),
  phone_number: z.nullable(
    z.lazy(() => IdentityLookupLookupResultPhoneNumber$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "birth_date": "birthDate",
    "family_name": "familyName",
    "given_name": "givenName",
    "middle_name": "middleName",
    "phone_number": "phoneNumber",
  });
});

/** @internal */
export type LookupResult$Outbound = {
  addresses?: Array<PostalAddress$Outbound> | undefined;
  birth_date?: IdentityLookupBirthDate$Outbound | null | undefined;
  emails?: Array<string> | undefined;
  family_name?: string | undefined;
  given_name?: string | undefined;
  identification?: Array<Identification$Outbound> | undefined;
  middle_name?: string | undefined;
  phone_number?:
    | IdentityLookupLookupResultPhoneNumber$Outbound
    | null
    | undefined;
};

/** @internal */
export const LookupResult$outboundSchema: z.ZodType<
  LookupResult$Outbound,
  z.ZodTypeDef,
  LookupResult
> = z.object({
  addresses: z.array(PostalAddress$outboundSchema).optional(),
  birthDate: z.nullable(z.lazy(() => IdentityLookupBirthDate$outboundSchema))
    .optional(),
  emails: z.array(z.string()).optional(),
  familyName: z.string().optional(),
  givenName: z.string().optional(),
  identification: z.array(Identification$outboundSchema).optional(),
  middleName: z.string().optional(),
  phoneNumber: z.nullable(
    z.lazy(() => IdentityLookupLookupResultPhoneNumber$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    birthDate: "birth_date",
    familyName: "family_name",
    givenName: "given_name",
    middleName: "middle_name",
    phoneNumber: "phone_number",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LookupResult$ {
  /** @deprecated use `LookupResult$inboundSchema` instead. */
  export const inboundSchema = LookupResult$inboundSchema;
  /** @deprecated use `LookupResult$outboundSchema` instead. */
  export const outboundSchema = LookupResult$outboundSchema;
  /** @deprecated use `LookupResult$Outbound` instead. */
  export type Outbound = LookupResult$Outbound;
}

export function lookupResultToJSON(lookupResult: LookupResult): string {
  return JSON.stringify(LookupResult$outboundSchema.parse(lookupResult));
}

export function lookupResultFromJSON(
  jsonString: string,
): SafeParseResult<LookupResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LookupResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LookupResult' from JSON`,
  );
}

/** @internal */
export const IdentityLookupShortCode$inboundSchema: z.ZodType<
  IdentityLookupShortCode,
  z.ZodTypeDef,
  unknown
> = z.object({
  number: z.string().optional(),
  region_code: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "region_code": "regionCode",
  });
});

/** @internal */
export type IdentityLookupShortCode$Outbound = {
  number?: string | undefined;
  region_code?: string | undefined;
};

/** @internal */
export const IdentityLookupShortCode$outboundSchema: z.ZodType<
  IdentityLookupShortCode$Outbound,
  z.ZodTypeDef,
  IdentityLookupShortCode
> = z.object({
  number: z.string().optional(),
  regionCode: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    regionCode: "region_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdentityLookupShortCode$ {
  /** @deprecated use `IdentityLookupShortCode$inboundSchema` instead. */
  export const inboundSchema = IdentityLookupShortCode$inboundSchema;
  /** @deprecated use `IdentityLookupShortCode$outboundSchema` instead. */
  export const outboundSchema = IdentityLookupShortCode$outboundSchema;
  /** @deprecated use `IdentityLookupShortCode$Outbound` instead. */
  export type Outbound = IdentityLookupShortCode$Outbound;
}

export function identityLookupShortCodeToJSON(
  identityLookupShortCode: IdentityLookupShortCode,
): string {
  return JSON.stringify(
    IdentityLookupShortCode$outboundSchema.parse(identityLookupShortCode),
  );
}

export function identityLookupShortCodeFromJSON(
  jsonString: string,
): SafeParseResult<IdentityLookupShortCode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IdentityLookupShortCode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IdentityLookupShortCode' from JSON`,
  );
}

/** @internal */
export const IdentityLookupPhoneNumber$inboundSchema: z.ZodType<
  IdentityLookupPhoneNumber,
  z.ZodTypeDef,
  unknown
> = z.object({
  e164_number: z.string().optional(),
  extension: z.string().optional(),
  short_code: z.nullable(z.lazy(() => IdentityLookupShortCode$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "e164_number": "e164Number",
    "short_code": "shortCode",
  });
});

/** @internal */
export type IdentityLookupPhoneNumber$Outbound = {
  e164_number?: string | undefined;
  extension?: string | undefined;
  short_code?: IdentityLookupShortCode$Outbound | null | undefined;
};

/** @internal */
export const IdentityLookupPhoneNumber$outboundSchema: z.ZodType<
  IdentityLookupPhoneNumber$Outbound,
  z.ZodTypeDef,
  IdentityLookupPhoneNumber
> = z.object({
  e164Number: z.string().optional(),
  extension: z.string().optional(),
  shortCode: z.nullable(z.lazy(() => IdentityLookupShortCode$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    e164Number: "e164_number",
    shortCode: "short_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdentityLookupPhoneNumber$ {
  /** @deprecated use `IdentityLookupPhoneNumber$inboundSchema` instead. */
  export const inboundSchema = IdentityLookupPhoneNumber$inboundSchema;
  /** @deprecated use `IdentityLookupPhoneNumber$outboundSchema` instead. */
  export const outboundSchema = IdentityLookupPhoneNumber$outboundSchema;
  /** @deprecated use `IdentityLookupPhoneNumber$Outbound` instead. */
  export type Outbound = IdentityLookupPhoneNumber$Outbound;
}

export function identityLookupPhoneNumberToJSON(
  identityLookupPhoneNumber: IdentityLookupPhoneNumber,
): string {
  return JSON.stringify(
    IdentityLookupPhoneNumber$outboundSchema.parse(identityLookupPhoneNumber),
  );
}

export function identityLookupPhoneNumberFromJSON(
  jsonString: string,
): SafeParseResult<IdentityLookupPhoneNumber, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IdentityLookupPhoneNumber$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IdentityLookupPhoneNumber' from JSON`,
  );
}

/** @internal */
export const IdentityLookupState$inboundSchema: z.ZodType<
  IdentityLookupStateOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(IdentityLookupState),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const IdentityLookupState$outboundSchema: z.ZodType<
  IdentityLookupStateOpen,
  z.ZodTypeDef,
  IdentityLookupStateOpen
> = z.union([
  z.nativeEnum(IdentityLookupState),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdentityLookupState$ {
  /** @deprecated use `IdentityLookupState$inboundSchema` instead. */
  export const inboundSchema = IdentityLookupState$inboundSchema;
  /** @deprecated use `IdentityLookupState$outboundSchema` instead. */
  export const outboundSchema = IdentityLookupState$outboundSchema;
}

/** @internal */
export const IdentityLookup$inboundSchema: z.ZodType<
  IdentityLookup,
  z.ZodTypeDef,
  unknown
> = z.object({
  create_time: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  device_metadata: z.nullable(z.lazy(() => DeviceMetadata$inboundSchema))
    .optional(),
  identification: z.nullable(
    z.lazy(() => IdentityLookupIdentification$inboundSchema),
  ).optional(),
  lookup_result: z.nullable(z.lazy(() => LookupResult$inboundSchema))
    .optional(),
  name: z.string().optional(),
  phone_number: z.nullable(
    z.lazy(() => IdentityLookupPhoneNumber$inboundSchema),
  ).optional(),
  state: IdentityLookupState$inboundSchema.optional(),
  update_time: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  user_consent: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "create_time": "createTime",
    "device_metadata": "deviceMetadata",
    "lookup_result": "lookupResult",
    "phone_number": "phoneNumber",
    "update_time": "updateTime",
    "user_consent": "userConsent",
  });
});

/** @internal */
export type IdentityLookup$Outbound = {
  create_time?: string | null | undefined;
  device_metadata?: DeviceMetadata$Outbound | null | undefined;
  identification?: IdentityLookupIdentification$Outbound | null | undefined;
  lookup_result?: LookupResult$Outbound | null | undefined;
  name?: string | undefined;
  phone_number?: IdentityLookupPhoneNumber$Outbound | null | undefined;
  state?: string | undefined;
  update_time?: string | null | undefined;
  user_consent?: boolean | undefined;
};

/** @internal */
export const IdentityLookup$outboundSchema: z.ZodType<
  IdentityLookup$Outbound,
  z.ZodTypeDef,
  IdentityLookup
> = z.object({
  createTime: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  deviceMetadata: z.nullable(z.lazy(() => DeviceMetadata$outboundSchema))
    .optional(),
  identification: z.nullable(
    z.lazy(() => IdentityLookupIdentification$outboundSchema),
  ).optional(),
  lookupResult: z.nullable(z.lazy(() => LookupResult$outboundSchema))
    .optional(),
  name: z.string().optional(),
  phoneNumber: z.nullable(
    z.lazy(() => IdentityLookupPhoneNumber$outboundSchema),
  ).optional(),
  state: IdentityLookupState$outboundSchema.optional(),
  updateTime: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  userConsent: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    createTime: "create_time",
    deviceMetadata: "device_metadata",
    lookupResult: "lookup_result",
    phoneNumber: "phone_number",
    updateTime: "update_time",
    userConsent: "user_consent",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IdentityLookup$ {
  /** @deprecated use `IdentityLookup$inboundSchema` instead. */
  export const inboundSchema = IdentityLookup$inboundSchema;
  /** @deprecated use `IdentityLookup$outboundSchema` instead. */
  export const outboundSchema = IdentityLookup$outboundSchema;
  /** @deprecated use `IdentityLookup$Outbound` instead. */
  export type Outbound = IdentityLookup$Outbound;
}

export function identityLookupToJSON(identityLookup: IdentityLookup): string {
  return JSON.stringify(IdentityLookup$outboundSchema.parse(identityLookup));
}

export function identityLookupFromJSON(
  jsonString: string,
): SafeParseResult<IdentityLookup, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IdentityLookup$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IdentityLookup' from JSON`,
  );
}
