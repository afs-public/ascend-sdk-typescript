/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Lot,
  Lot$inboundSchema,
  Lot$Outbound,
  Lot$outboundSchema,
} from "./lot.js";
import {
  YieldRecord,
  YieldRecord$inboundSchema,
  YieldRecord$Outbound,
  YieldRecord$outboundSchema,
} from "./yieldrecord.js";

/**
 * Used to record the movement of funds or shares to/ from the pending_acats memo location
 */
export type AcatsPendingOut = {
  /**
   * the unique transfer Identifier assigned by NSCC
   */
  acatsControlNumber?: string | undefined;
  /**
   * Free form text field
   */
  additionalInstructions?: string | undefined;
};

/**
 * Indicates the memo location impacted by an entry
 */
export enum AccountMemo {
  MemoTypeUnspecified = "MEMO_TYPE_UNSPECIFIED",
  FullyPaidStockLoan = "FULLY_PAID_STOCK_LOAN",
  Free = "FREE",
  PendingOutgoingAcat = "PENDING_OUTGOING_ACAT",
  PendingDrip = "PENDING_DRIP",
  PendingWithdrawal = "PENDING_WITHDRAWAL",
}
/**
 * Indicates the memo location impacted by an entry
 */
export type AccountMemoOpen = OpenEnum<typeof AccountMemo>;

/**
 * The type of asset movement being performed within the lifecycle of an account transfer process
 */
export enum AccountTransferType {
  AccountTransferTypeUnspecified = "ACCOUNT_TRANSFER_TYPE_UNSPECIFIED",
  PartialTransferReceiver = "PARTIAL_TRANSFER_RECEIVER",
  PartialTransferDeliverer = "PARTIAL_TRANSFER_DELIVERER",
  FullAccountTransfer = "FULL_ACCOUNT_TRANSFER",
  ResidualCredit = "RESIDUAL_CREDIT",
  MutualFundCleanup = "MUTUAL_FUND_CLEANUP",
  FailReversal = "FAIL_REVERSAL",
  Reclaim = "RECLAIM",
  PositionTransferFund = "POSITION_TRANSFER_FUND",
}
/**
 * The type of asset movement being performed within the lifecycle of an account transfer process
 */
export type AccountTransferTypeOpen = OpenEnum<typeof AccountTransferType>;

/**
 * Indicates whether the account transfer is incoming or outgoing
 */
export enum Action {
  ActionUnspecified = "ACTION_UNSPECIFIED",
  Incoming = "INCOMING",
  Outgoing = "OUTGOING",
  CashInLieu = "CASH_IN_LIEU",
}
/**
 * Indicates whether the account transfer is incoming or outgoing
 */
export type ActionOpen = OpenEnum<typeof Action>;

/**
 * the method used for the account transfer
 */
export enum Method {
  AccountTransferMethodUnspecified = "ACCOUNT_TRANSFER_METHOD_UNSPECIFIED",
  Acats = "ACATS",
  Internal = "INTERNAL",
  Manual = "MANUAL",
}
/**
 * the method used for the account transfer
 */
export type MethodOpen = OpenEnum<typeof Method>;

/**
 * Used to record the movement of funds or shares during the bookkeeping phase of an account transfer and details related to the account transfer
 */
export type AccountTransfer = {
  /**
   * sequence number assigned by the DTCC ACATS transfer system for each asset transferred
   */
  acatsAssetSequenceNumber?: string | undefined;
  /**
   * the unique transfer Identifier assigned by NSCC
   */
  acatsControlNumber?: string | undefined;
  /**
   * The type of asset movement being performed within the lifecycle of an account transfer process
   */
  accountTransferType?: AccountTransferTypeOpen | undefined;
  /**
   * Indicates whether the account transfer is incoming or outgoing
   */
  action?: ActionOpen | undefined;
  /**
   * Free form text field
   */
  additionalInstructions?: string | undefined;
  /**
   * account number at the contra firm
   */
  contraPartyAccountNumber?: string | undefined;
  /**
   * contra party identifier
   */
  contraPartyId?: string | undefined;
  /**
   * Contra party institution for the account transfer
   */
  institution?: string | undefined;
  /**
   * the method used for the account transfer
   */
  method?: MethodOpen | undefined;
};

/**
 * Indicates that the entry references accrued interest that has been earned but not yet paid between the last interest payment and the date of the trade
 */
export type EntryAccruedInterest = {};

/**
 * Common fields for corporate actions
 */
export type CorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * Object containing metadata for acquisition events
 */
export type Acquisition = {
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | CorporateActionGeneralInformation
    | null
    | undefined;
};

/**
 * The activity date refers to the specific calendar day on which a financial transaction, such as a trade at an exchange or a deposit at a bank, was executed. This date is specific to the institution where the transaction took place, capturing the exact day on which the institution formally records and effects the transaction
 */
export type ActivityDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The execution route Apex used for this trade
 */
export enum EntryBrokerCapacity {
  CapacityUnspecified = "CAPACITY_UNSPECIFIED",
  Agency = "AGENCY",
  Principal = "PRINCIPAL",
  Mixed = "MIXED",
}
/**
 * The execution route Apex used for this trade
 */
export type EntryBrokerCapacityOpen = OpenEnum<typeof EntryBrokerCapacity>;

/**
 * The price for the instrument that is prevailing in the market
 */
export type EntryPrevailingMarketPrice = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Total monetary value of the price_adjustment
 */
export type EntryPriceAdjustmentAmount = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)
 */
export type PriceAdjustmentPercent = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The type of price adjustment being applied by the broker to the net price of the security
 */
export enum EntryPriceAdjustmentType {
  PriceAdjustmentTypeUnspecified = "PRICE_ADJUSTMENT_TYPE_UNSPECIFIED",
  Markup = "MARKUP",
  Markdown = "MARKDOWN",
  SalesLoad = "SALES_LOAD",
}
/**
 * The type of price adjustment being applied by the broker to the net price of the security
 */
export type EntryPriceAdjustmentTypeOpen = OpenEnum<
  typeof EntryPriceAdjustmentType
>;

/**
 * Information about any price adjustments applied to the security
 */
export type PriceAdjustmentRecord = {
  /**
   * Total monetary value of the price_adjustment
   */
  priceAdjustmentAmount?: EntryPriceAdjustmentAmount | null | undefined;
  /**
   * The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)
   */
  priceAdjustmentPercent?: PriceAdjustmentPercent | null | undefined;
  /**
   * The type of price adjustment being applied by the broker to the net price of the security
   */
  priceAdjustmentType?: EntryPriceAdjustmentTypeOpen | undefined;
};

/**
 * Object containing metadata for trade allocation
 */
export type Allocation = {
  /**
   * To be populated by the submitter of the trade detail
   */
  additionalInstructions?: Array<string> | undefined;
  /**
   * ULID assigned by the Booking API if a trade belongs to an allocation
   */
  bookingApiTradeAllocationId?: string | undefined;
  /**
   * The execution route Apex used for this trade
   */
  brokerCapacity?: EntryBrokerCapacityOpen | undefined;
  /**
   * Client usage area (intact)
   */
  clientMemo?: string | undefined;
  /**
   * Client-provided order ID present in execution reports
   */
  clientOrderId?: string | undefined;
  /**
   * External system ID provided by a client
   */
  externalId?: string | undefined;
  /**
   * Order ID generated by the trading-gateway
   */
  gatewayClientOrderId?: string | undefined;
  /**
   * Indicates the trade should be omitted from client billing
   */
  internalError?: boolean | undefined;
  /**
   * Trade lots
   */
  lots?: Array<Lot> | undefined;
  /**
   * The price for the instrument that is prevailing in the market
   */
  prevailingMarketPrice?: EntryPrevailingMarketPrice | null | undefined;
  /**
   * Information about any price adjustments applied to the security
   */
  priceAdjustmentRecord?: PriceAdjustmentRecord | null | undefined;
  /**
   * Special instructions for the trade
   */
  specialInstructions?: Array<string> | undefined;
  /**
   * The yields associated with a fixed income trade
   */
  yieldRecords?: Array<YieldRecord> | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type CashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type PaymentDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's trade quantity
 */
export type EntryBondDefaultQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Object containing metadata for bond defaults
 */
export type BondDefault = {
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: CashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The anticipated payment date at the depository
   */
  paymentDate?: PaymentDate | null | undefined;
  /**
   * Corresponds to the position's trade quantity
   */
  quantity?: EntryBondDefaultQuantity | null | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type EntryCashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryCapitalGainsCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntryPaymentDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's trade quantity
 */
export type EntryCapitalGainsQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The date on which positions are recorded in order to calculate entitlement
 */
export type RecordDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Used to record a distribution of cash that an issuer has determined will be declared as income financed from capital gains and not ordinary income and details related to the capital gain
 */
export type CapitalGains = {
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: EntryCashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryCapitalGainsCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * Corresponds to corporateactions.announcement.capital_gains
   */
  longTermGain?: boolean | undefined;
  /**
   * The anticipated payment date at the depository
   */
  paymentDate?: EntryPaymentDate | null | undefined;
  /**
   * Identifies whether dividend income is potentially qualified for the lower maximum individual federal tax rate under the Jobs and Growth Tax Relief Reconciliation Act of 2003
   */
  qualified?: boolean | undefined;
  /**
   * Corresponds to the position's trade quantity
   */
  quantity?: EntryCapitalGainsQuantity | null | undefined;
  /**
   * The date on which positions are recorded in order to calculate entitlement
   */
  recordDate?: RecordDate | null | undefined;
  /**
   * Indicates whether the cash dividend was reinvested
   */
  reinvested?: boolean | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type EntryCashDividendCashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryCashDividendCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * Corresponds to the raw bucket value that denotes a position is allocated to the "fpsl" memo location
 */
export type EntryFpsl = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Corresponds to the raw bucket value that denotes a position is allocated to the "free" memo location
 */
export type EntryFree = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntryCashDividendPaymentDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * When ex-date occurs before the record date, quantity will equal the settled date position balance on the position date of the event When ex-date occurs after the record date, quantity will equal the trade date position balance on the position date of the event
 */
export type EntryCashDividendQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The date on which positions are recorded in order to calculate entitlement
 */
export type EntryRecordDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's settled quantity
 */
export type EntryCashDividendSettled = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Corresponds to the subtype of corporaction type
 */
export enum Subtype {
  CorporateactionsubtypeUnspecified = "CORPORATEACTIONSUBTYPE_UNSPECIFIED",
  AdditionalDividend = "ADDITIONAL_DIVIDEND",
  ApproximateRate = "APPROXIMATE_RATE",
  DividendArrears = "DIVIDEND_ARREARS",
  DividendCancelled = "DIVIDEND_CANCELLED",
  DividendPaymentTaxClassifications = "DIVIDEND_PAYMENT_TAX_CLASSIFICATIONS",
  DividendRescinded = "DIVIDEND_RESCINDED",
  EstimatedReturnOfCapital = "ESTIMATED_RETURN_OF_CAPITAL",
  EstimatedReturnOfCapitalPlusIncome =
    "ESTIMATED_RETURN_OF_CAPITAL_PLUS_INCOME",
  ExtraDividend = "EXTRA_DIVIDEND",
  ExtraDividendPlusIncome = "EXTRA_DIVIDEND_PLUS_INCOME",
  FinalPaymentTransferBooksAreClosed =
    "FINAL_PAYMENT_TRANSFER_BOOKS_ARE_CLOSED",
  GrossRate = "GROSS_RATE",
  InitialDividend = "INITIAL_DIVIDEND",
  InitialDividendLongPeriod = "INITIAL_DIVIDEND_LONG_PERIOD",
  InitialDividendShortPeriod = "INITIAL_DIVIDEND_SHORT_PERIOD",
  LimitedPartnershipDistribution = "LIMITED_PARTNERSHIP_DISTRIBUTION",
  Liquidation = "LIQUIDATION",
  NetRate = "NET_RATE",
  Other = "OTHER",
  ProceedsFromSaleOfRights = "PROCEEDS_FROM_SALE_OF_RIGHTS",
  RegularDividend = "REGULAR_DIVIDEND",
  ReturnOfCapital = "RETURN_OF_CAPITAL",
  ReturnOfCapitalPlusIncome = "RETURN_OF_CAPITAL_PLUS_INCOME",
  SpecialDividend = "SPECIAL_DIVIDEND",
  SpecialDividendPlusIncome = "SPECIAL_DIVIDEND_PLUS_INCOME",
  YearEndDividend = "YEAR_END_DIVIDEND",
  YearEndDividendPlusIncome = "YEAR_END_DIVIDEND_PLUS_INCOME",
  Partial = "PARTIAL",
  Full = "FULL",
  Maturity = "MATURITY",
  Termination = "TERMINATION",
  RedemptionOfWarrants = "REDEMPTION_OF_WARRANTS",
}
/**
 * Corresponds to the subtype of corporaction type
 */
export type SubtypeOpen = OpenEnum<typeof Subtype>;

/**
 * Used to record the distribution of cash to shareholders, paid by the issuer, usually based upon current earnings and/or accumulated profits as declared by the board of directors and details related to the cash dividend
 */
export type CashDividend = {
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: EntryCashDividendCashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryCashDividendCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * Corresponds to the raw bucket value that denotes a position is allocated to the "fpsl" memo location
   */
  fpsl?: EntryFpsl | null | undefined;
  /**
   * Corresponds to the raw bucket value that denotes a position is allocated to the "free" memo location
   */
  free?: EntryFree | null | undefined;
  /**
   * Corresponds to corporateactions.announcement.capital_gains
   */
  longTermGain?: boolean | undefined;
  /**
   * The anticipated payment date at the depository
   */
  paymentDate?: EntryCashDividendPaymentDate | null | undefined;
  /**
   * Identifies whether dividend income is potentially qualified for the lower maximum individual federal tax rate under the Jobs and Growth Tax Relief Reconciliation Act of 2003
   */
  qualified?: boolean | undefined;
  /**
   * When ex-date occurs before the record date, quantity will equal the settled date position balance on the position date of the event When ex-date occurs after the record date, quantity will equal the trade date position balance on the position date of the event
   */
  quantity?: EntryCashDividendQuantity | null | undefined;
  /**
   * The date on which positions are recorded in order to calculate entitlement
   */
  recordDate?: EntryRecordDate | null | undefined;
  /**
   * Indicates whether the cash dividend was reinvested
   */
  reinvested?: boolean | undefined;
  /**
   * Corresponds to the position's settled quantity
   */
  settled?: EntryCashDividendSettled | null | undefined;
  /**
   * Indicates whether the corporate action event is a substitute payment
   */
  substitutePayment?: boolean | undefined;
  /**
   * Corresponds to the subtype of corporaction type
   */
  subtype?: SubtypeOpen | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryCashInLieuCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * Object containing metadata for cash in lieu
 */
export type CashInLieu = {
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryCashInLieuCorporateActionGeneralInformation
    | null
    | undefined;
};

/**
 * Indicates that the entry references commission charged by brokers or financial intermediaries for executing financial transactions on behalf of clients
 */
export type EntryCommission = {};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type EntryConversionCashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryConversionCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which shares will be disbursed to the shareholder
 */
export type StockRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Corresponds to whether the event is CASH | STOCK | CASH_AND_STOCK
 */
export enum EntryConversionType {
  EventTypeUnspecified = "EVENT_TYPE_UNSPECIFIED",
  Cash = "CASH",
  Stock = "STOCK",
  CashAndStock = "CASH_AND_STOCK",
}
/**
 * Corresponds to whether the event is CASH | STOCK | CASH_AND_STOCK
 */
export type EntryConversionTypeOpen = OpenEnum<typeof EntryConversionType>;

/**
 * Used to record the conversion of securities (generally convertible bonds or preferred shares) into another form of securities (usually common shares) at a pre-stated price or rate and details related to the conversion
 */
export type Conversion = {
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: EntryConversionCashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryConversionCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which shares will be disbursed to the shareholder
   */
  stockRate?: StockRate | null | undefined;
  /**
   * Corresponds to whether the event is CASH | STOCK | CASH_AND_STOCK
   */
  type?: EntryConversionTypeOpen | undefined;
};

/**
 * Object containing metadata for memo locations that have been adjusted due to a corporate action
 */
export type CorporateActionMemoAdjustment = {
  /**
   * This field serves as a unique identifier for the specific corporate action linked to the memo adjustment
   */
  corporateActionId?: string | undefined;
  /**
   * Used to capture the specific type of corporate action related to the memo adjustment
   */
  corporateActionType?: string | undefined;
};

/**
 * Provides more details on the type of credit
 */
export enum CreditType {
  CreditTypeUnspecified = "CREDIT_TYPE_UNSPECIFIED",
  FullyPaidStockLoan = "FULLY_PAID_STOCK_LOAN",
  WriteOff = "WRITE_OFF",
  Reimbursement = "REIMBURSEMENT",
  Promotional = "PROMOTIONAL",
  FdicInsuredDepositProgram = "FDIC_INSURED_DEPOSIT_PROGRAM",
  AccountTransferAdjustment = "ACCOUNT_TRANSFER_ADJUSTMENT",
}
/**
 * Provides more details on the type of credit
 */
export type CreditTypeOpen = OpenEnum<typeof CreditType>;

/**
 * Used to disburse funds into a customer's account, typically for purposes such as refunds, interest payments, or rewards from enrolled programs and details related to the credit
 */
export type Credit = {
  /**
   * Free form text field providing additional information about a transaction
   */
  additionalInstructions?: string | undefined;
  /**
   * Provides more details on the type of credit
   */
  creditType?: CreditTypeOpen | undefined;
  /**
   * Indicates whether the credit is taxable
   */
  taxable?: boolean | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryDeliveryCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * Object containing metadata for delivery events
 */
export type Delivery = {
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryDeliveryCorporateActionGeneralInformation
    | null
    | undefined;
};

/**
 * Provides detail on the contribution reason if the deposit is made to a retirement account
 */
export enum ContributionType {
  ContributionTypeUnspecified = "CONTRIBUTION_TYPE_UNSPECIFIED",
  Regular = "REGULAR",
  Employee = "EMPLOYEE",
  Employer = "EMPLOYER",
  Recharacterization = "RECHARACTERIZATION",
  Rollover60Day = "ROLLOVER_60_DAY",
  RolloverDirect = "ROLLOVER_DIRECT",
  Transfer = "TRANSFER",
  TrusteeFee = "TRUSTEE_FEE",
  Conversion = "CONVERSION",
  Repayment = "REPAYMENT",
  ContributionNonReportable = "CONTRIBUTION_NON_REPORTABLE",
}
/**
 * Provides detail on the contribution reason if the deposit is made to a retirement account
 */
export type ContributionTypeOpen = OpenEnum<typeof ContributionType>;

/**
 * The mechanism by which funds were deposited
 */
export enum EntryDepositType {
  ExternalMovementTypeUnspecified = "EXTERNAL_MOVEMENT_TYPE_UNSPECIFIED",
  Ach = "ACH",
  Check = "CHECK",
  Wire = "WIRE",
  Paypal = "PAYPAL",
  Rtp = "RTP",
  Ict = "ICT",
  Journal = "JOURNAL",
  ExternalAch = "EXTERNAL_ACH",
}
/**
 * The mechanism by which funds were deposited
 */
export type EntryDepositTypeOpen = OpenEnum<typeof EntryDepositType>;

/**
 * Used to record deposits of funds into an account and capture details related to the deposit
 */
export type Deposit = {
  /**
   * Free form text field providing additional information about a transaction
   */
  additionalInstructions?: string | undefined;
  /**
   * Provides detail on the contribution reason if the deposit is made to a retirement account
   */
  contributionType?: ContributionTypeOpen | undefined;
  /**
   * Integer representing the tax year the contribution should be applied to
   */
  contributionYear?: number | undefined;
  /**
   * Unique tracking number provided to allow tracking a wire transfer from the initiating bank to the receiving bank
   */
  fedReferenceNumber?: string | undefined;
  /**
   * Human readable account identifier for the account the assets were journaled from. To be populated when the Deposit type is Journal
   */
  originatingAccountNumber?: string | undefined;
  /**
   * The mechanism by which funds were deposited
   */
  type?: EntryDepositTypeOpen | undefined;
};

/**
 * Indicates whether the drip memo activity is reserving cash (DRIP_PENDING) or removing the reservation after a successful reinvestment trade
 */
export enum EntryAction {
  DripActionUnspecified = "DRIP_ACTION_UNSPECIFIED",
  DripPending = "DRIP_PENDING",
  DripComplete = "DRIP_COMPLETE",
}
/**
 * Indicates whether the drip memo activity is reserving cash (DRIP_PENDING) or removing the reservation after a successful reinvestment trade
 */
export type EntryActionOpen = OpenEnum<typeof EntryAction>;

/**
 * Used to record the movement of funds to/ from the pending_drip memo location
 */
export type Drip = {
  /**
   * Indicates whether the drip memo activity is reserving cash (DRIP_PENDING) or removing the reservation after a successful reinvestment trade
   */
  action?: EntryActionOpen | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type EntryExchangeCashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryExchangeCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which shares will be disbursed to the shareholder
 */
export type EntryStockRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Corresponds to whether the event is CASH | STOCK | CASH_AND_STOCK
 */
export enum EntryExchangeType {
  EventTypeUnspecified = "EVENT_TYPE_UNSPECIFIED",
  Cash = "CASH",
  Stock = "STOCK",
  CashAndStock = "CASH_AND_STOCK",
}
/**
 * Corresponds to whether the event is CASH | STOCK | CASH_AND_STOCK
 */
export type EntryExchangeTypeOpen = OpenEnum<typeof EntryExchangeType>;

/**
 * Used to record the exchange of certificates for a new security or cash and details related to the exchange
 */
export type Exchange = {
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: EntryExchangeCashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryExchangeCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which shares will be disbursed to the shareholder
   */
  stockRate?: EntryStockRate | null | undefined;
  /**
   * Corresponds to whether the event is CASH | STOCK | CASH_AND_STOCK
   */
  type?: EntryExchangeTypeOpen | undefined;
};

/**
 * Enum providing additional information about the type of fee being charged
 */
export enum EntryFeeType {
  FeeTypeUnspecified = "FEE_TYPE_UNSPECIFIED",
  ClientClearing = "CLIENT_CLEARING",
  Liquidity = "LIQUIDITY",
  GeneralPurpose = "GENERAL_PURPOSE",
  Commission = "COMMISSION",
  Taf = "TAF",
  Sec = "SEC",
  AccountClosing = "ACCOUNT_CLOSING",
  AccountIra = "ACCOUNT_IRA",
  AchReturn = "ACH_RETURN",
  Advisory = "ADVISORY",
  CheckFee = "CHECK_FEE",
  Exchange = "EXCHANGE",
  Management = "MANAGEMENT",
  Overnight = "OVERNIGHT",
  Platform = "PLATFORM",
  Statement = "STATEMENT",
  StopPayment = "STOP_PAYMENT",
  WireFee = "WIRE_FEE",
  Inactivity = "INACTIVITY",
  AmaService = "AMA_SERVICE",
  NoticeOfChange = "NOTICE_OF_CHANGE",
  AccountTransfer = "ACCOUNT_TRANSFER",
  AgencyProcessing = "AGENCY_PROCESSING",
  RtpFee = "RTP_FEE",
  DomesticWireDepositFee = "DOMESTIC_WIRE_DEPOSIT_FEE",
  DomesticWireWithdrawalFee = "DOMESTIC_WIRE_WITHDRAWAL_FEE",
  InternationalWireDepositFee = "INTERNATIONAL_WIRE_DEPOSIT_FEE",
  InternationalWireWithdrawalFee = "INTERNATIONAL_WIRE_WITHDRAWAL_FEE",
  BrokerFee = "BROKER_FEE",
  OccFee = "OCC_FEE",
  ContractFee = "CONTRACT_FEE",
  OptionsRegulatory = "OPTIONS_REGULATORY",
  FinancialTransactionTax = "FINANCIAL_TRANSACTION_TAX",
}
/**
 * Enum providing additional information about the type of fee being charged
 */
export type EntryFeeTypeOpen = OpenEnum<typeof EntryFeeType>;

/**
 * Used to record Fees that have been assessed to account and capture details related to the fee
 */
export type EntryFee = {
  /**
   * Free form text field providing additional information about a transaction
   */
  additionalInstructions?: string | undefined;
  /**
   * Enum providing additional information about the type of fee being charged
   */
  type?: EntryFeeTypeOpen | undefined;
};

/**
 * Used to calculate broadridge blotter code
 */
export enum EntryFlipBrokerCapacity {
  CapacityUnspecified = "CAPACITY_UNSPECIFIED",
  Agency = "AGENCY",
  Principal = "PRINCIPAL",
  Mixed = "MIXED",
}
/**
 * Used to calculate broadridge blotter code
 */
export type EntryFlipBrokerCapacityOpen = OpenEnum<
  typeof EntryFlipBrokerCapacity
>;

/**
 * The price for the instrument that is prevailing in the market
 */
export type EntryFlipPrevailingMarketPrice = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Total monetary value of the price_adjustment
 */
export type EntryFlipPriceAdjustmentAmount = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)
 */
export type EntryFlipPriceAdjustmentPercent = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The type of price adjustment being applied by the broker to the net price of the security
 */
export enum EntryFlipPriceAdjustmentType {
  PriceAdjustmentTypeUnspecified = "PRICE_ADJUSTMENT_TYPE_UNSPECIFIED",
  Markup = "MARKUP",
  Markdown = "MARKDOWN",
  SalesLoad = "SALES_LOAD",
}
/**
 * The type of price adjustment being applied by the broker to the net price of the security
 */
export type EntryFlipPriceAdjustmentTypeOpen = OpenEnum<
  typeof EntryFlipPriceAdjustmentType
>;

/**
 * Information about any price adjustments applied to the security
 */
export type EntryFlipPriceAdjustmentRecord = {
  /**
   * Total monetary value of the price_adjustment
   */
  priceAdjustmentAmount?: EntryFlipPriceAdjustmentAmount | null | undefined;
  /**
   * The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)
   */
  priceAdjustmentPercent?: EntryFlipPriceAdjustmentPercent | null | undefined;
  /**
   * The type of price adjustment being applied by the broker to the net price of the security
   */
  priceAdjustmentType?: EntryFlipPriceAdjustmentTypeOpen | undefined;
};

/**
 * Provides additional details for trades
 */
export type Detail = {
  /**
   * To be populated by the submitter of the trade detail
   */
  additionalInstructions?: Array<string> | undefined;
  /**
   * Max Length 50 characters. Alternate order id from the street used for FRAC trades
   */
  alternateOrderId?: string | undefined;
  /**
   * base64 encoded value assigned by the Booking API to all executions
   */
  bookingApiBookingExecutionId?: string | undefined;
  /**
   * base64 encoded value assigned by the Booking API if a trade belongs to an allocation
   */
  bookingApiTradeAllocationId?: string | undefined;
  /**
   * base64 encoded value assigned by the Booking API to all trades
   */
  bookingApiTradeId?: string | undefined;
  /**
   * Executing broker of the trade
   */
  broker?: string | undefined;
  /**
   * Used to calculate broadridge blotter code
   */
  brokerCapacity?: EntryFlipBrokerCapacityOpen | undefined;
  /**
   * client usage area (intact). len 20
   */
  clientMemo?: string | undefined;
  /**
   * Max Length 50 characters. Client provided order id present in exec reports
   */
  clientOrderId?: string | undefined;
  /**
   * MIC code for the exchange
   */
  exchange?: string | undefined;
  /**
   * Max Length 50 characters. Execution id from the street
   */
  executionId?: string | undefined;
  /**
   * Indicates whether Apex is the clearing broker for this trade
   */
  executionOnly?: boolean | undefined;
  /**
   * Max Length 50 characters. External system id provided by a client
   */
  externalId?: string | undefined;
  /**
   * The confirmation number associated with a mutual fund trade
   */
  fundConfirmationNumber?: string | undefined;
  /**
   * Order id generated by trading-gateway (Trade-Ex) to uniquely identify all orders in their system Used as the client_order_id on new order singles sent downstream of the trading-gateway
   */
  gatewayClientOrderId?: string | undefined;
  /**
   * If set to true, indicates the trade should be omitted from client billing
   */
  internalError?: boolean | undefined;
  /**
   * set on penny-for-the-lot trades
   */
  isWriteoff?: boolean | undefined;
  /**
   * Trade lots
   */
  lots?: Array<Lot> | undefined;
  /**
   * "MMAP" for multi market average price, "UNKN" for unknown
   */
  market?: string | undefined;
  /**
   * Max Length 50 characters. Internally generated order id that is returned to client on exec reports
   */
  orderId?: string | undefined;
  /**
   * The price for the instrument that is prevailing in the market
   */
  prevailingMarketPrice?: EntryFlipPrevailingMarketPrice | null | undefined;
  /**
   * Information about any price adjustments applied to the security
   */
  priceAdjustmentRecord?: EntryFlipPriceAdjustmentRecord | null | undefined;
  /**
   * The execution route Apex used for this trade
   */
  route?: string | undefined;
  /**
   * Special instructions for the trade
   */
  specialInstructions?: Array<string> | undefined;
  /**
   * Indicates the trade was executed in a security that is not currently listed. When-issued securities are bought and sold before they are officially issued, allowing investors to speculate on their future value
   */
  whenIssued?: boolean | undefined;
  /**
   * The yields associated with a fixed income trade Only valid if the SecurityType is FIXED_INCOME
   */
  yieldRecords?: Array<YieldRecord> | undefined;
};

/**
 * Object containing metadata for a Flip
 */
export type Flip = {
  /**
   * Provides additional details for trades
   */
  detail?: Detail | null | undefined;
};

/**
 * Indicates whether shares are being allocated or deallocated
 */
export enum EntryFpslAction {
  FpslActionUnspecified = "FPSL_ACTION_UNSPECIFIED",
  Allocate = "ALLOCATE",
  Deallocate = "DEALLOCATE",
}
/**
 * Indicates whether shares are being allocated or deallocated
 */
export type EntryFpslActionOpen = OpenEnum<typeof EntryFpslAction>;

/**
 * Used to record the movements of shares to/ from the fpsl memo location and details related to the fpsl memo
 */
export type Fpsl = {
  /**
   * Indicates whether shares are being allocated or deallocated
   */
  action?: EntryFpslActionOpen | undefined;
};

/**
 * The monetary value of an activity, exclusive of any fees (First money)
 */
export type EntryGrossAmount = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Date on which interest accrues before the calculation is made for payment or charge
 */
export type InterestAccrualEndDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Date on which interest begins to accrue on a cash balance or borrowed funds
 */
export type InterestAccrualStartDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

export enum InterestType {
  InterestTypeUnspecified = "INTEREST_TYPE_UNSPECIFIED",
  Credit = "CREDIT",
  Debit = "DEBIT",
}
export type InterestTypeOpen = OpenEnum<typeof InterestType>;

/**
 * Used to record the payment of interest to accounts that have maintained a cash balance or the charging of interest to accounts that have used margin and details related to the interest
 */
export type Interest = {
  /**
   * Date on which interest accrues before the calculation is made for payment or charge
   */
  interestAccrualEndDate?: InterestAccrualEndDate | null | undefined;
  /**
   * Date on which interest begins to accrue on a cash balance or borrowed funds
   */
  interestAccrualStartDate?: InterestAccrualStartDate | null | undefined;
  interestType?: InterestTypeOpen | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type EntryInterestPaymentCashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryInterestPaymentCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntryInterestPaymentPaymentDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The date on which positions are recorded in order to calculate entitlement
 */
export type EntryInterestPaymentRecordDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's settled quantity
 */
export type EntrySettled = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Used to record the The payment of an obligation an issuer has agreed to make to holders of an interest-bearing security and details related to the interest payment. Usually, the payment is made in cash and on a scheduled basis
 */
export type InterestPayment = {
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: EntryInterestPaymentCashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryInterestPaymentCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The anticipated payment date at the depository
   */
  paymentDate?: EntryInterestPaymentPaymentDate | null | undefined;
  /**
   * The date on which positions are recorded in order to calculate entitlement
   */
  recordDate?: EntryInterestPaymentRecordDate | null | undefined;
  /**
   * Corresponds to the position's settled quantity
   */
  settled?: EntrySettled | null | undefined;
};

/**
 * Corresponds to whether the entry is incoming outgoing
 */
export enum EntryLiquidationAction {
  ActionUnspecified = "ACTION_UNSPECIFIED",
  Incoming = "INCOMING",
  Outgoing = "OUTGOING",
  CashInLieu = "CASH_IN_LIEU",
}
/**
 * Corresponds to whether the entry is incoming outgoing
 */
export type EntryLiquidationActionOpen = OpenEnum<
  typeof EntryLiquidationAction
>;

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type EntryLiquidationCashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryLiquidationCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * Effective date as declared by the primary exchange that generally coincides with cessation of trading in the old security and commencement of trading in the new security
 */
export type EntryEffectiveDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntryLiquidationPaymentDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's trade quantity
 */
export type EntryLiquidationQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The date on which positions are recorded in order to calculate entitlement
 */
export type EntryLiquidationRecordDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's settled quantity
 */
export type EntryLiquidationSettled = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Corresponds to the subtype of corporaction type
 */
export enum EntrySubtype {
  CorporateactionsubtypeUnspecified = "CORPORATEACTIONSUBTYPE_UNSPECIFIED",
  AdditionalDividend = "ADDITIONAL_DIVIDEND",
  ApproximateRate = "APPROXIMATE_RATE",
  DividendArrears = "DIVIDEND_ARREARS",
  DividendCancelled = "DIVIDEND_CANCELLED",
  DividendPaymentTaxClassifications = "DIVIDEND_PAYMENT_TAX_CLASSIFICATIONS",
  DividendRescinded = "DIVIDEND_RESCINDED",
  EstimatedReturnOfCapital = "ESTIMATED_RETURN_OF_CAPITAL",
  EstimatedReturnOfCapitalPlusIncome =
    "ESTIMATED_RETURN_OF_CAPITAL_PLUS_INCOME",
  ExtraDividend = "EXTRA_DIVIDEND",
  ExtraDividendPlusIncome = "EXTRA_DIVIDEND_PLUS_INCOME",
  FinalPaymentTransferBooksAreClosed =
    "FINAL_PAYMENT_TRANSFER_BOOKS_ARE_CLOSED",
  GrossRate = "GROSS_RATE",
  InitialDividend = "INITIAL_DIVIDEND",
  InitialDividendLongPeriod = "INITIAL_DIVIDEND_LONG_PERIOD",
  InitialDividendShortPeriod = "INITIAL_DIVIDEND_SHORT_PERIOD",
  LimitedPartnershipDistribution = "LIMITED_PARTNERSHIP_DISTRIBUTION",
  Liquidation = "LIQUIDATION",
  NetRate = "NET_RATE",
  Other = "OTHER",
  ProceedsFromSaleOfRights = "PROCEEDS_FROM_SALE_OF_RIGHTS",
  RegularDividend = "REGULAR_DIVIDEND",
  ReturnOfCapital = "RETURN_OF_CAPITAL",
  ReturnOfCapitalPlusIncome = "RETURN_OF_CAPITAL_PLUS_INCOME",
  SpecialDividend = "SPECIAL_DIVIDEND",
  SpecialDividendPlusIncome = "SPECIAL_DIVIDEND_PLUS_INCOME",
  YearEndDividend = "YEAR_END_DIVIDEND",
  YearEndDividendPlusIncome = "YEAR_END_DIVIDEND_PLUS_INCOME",
  Partial = "PARTIAL",
  Full = "FULL",
  Maturity = "MATURITY",
  Termination = "TERMINATION",
  RedemptionOfWarrants = "REDEMPTION_OF_WARRANTS",
}
/**
 * Corresponds to the subtype of corporaction type
 */
export type EntrySubtypeOpen = OpenEnum<typeof EntrySubtype>;

/**
 * Used to record the dismantling of a business by an issuer, paying off debts in order of priority and distributing the remaining assets in cash and/or securities to the owners of the securities and details related to the liquidation
 */
export type Liquidation = {
  /**
   * Corresponds to whether the entry is incoming outgoing
   */
  action?: EntryLiquidationActionOpen | undefined;
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: EntryLiquidationCashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryLiquidationCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * Effective date as declared by the primary exchange that generally coincides with cessation of trading in the old security and commencement of trading in the new security
   */
  effectiveDate?: EntryEffectiveDate | null | undefined;
  /**
   * The anticipated payment date at the depository
   */
  paymentDate?: EntryLiquidationPaymentDate | null | undefined;
  /**
   * Corresponds to the position's trade quantity
   */
  quantity?: EntryLiquidationQuantity | null | undefined;
  /**
   * The date on which positions are recorded in order to calculate entitlement
   */
  recordDate?: EntryLiquidationRecordDate | null | undefined;
  /**
   * Corresponds to the position's settled quantity
   */
  settled?: EntryLiquidationSettled | null | undefined;
  /**
   * Corresponds to the subtype of corporaction type
   */
  subtype?: EntrySubtypeOpen | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type EntryMaturityCashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryMaturityCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntryMaturityPaymentDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The trade position quantity used to calculate the disbursed amount
 */
export type EntryMaturityQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Used to record he final repayment, usually in cash, by an issuer for the entire issue, or remaining outstanding securities of a specific security on a specified date and details related to the maturity
 */
export type Maturity = {
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: EntryMaturityCashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryMaturityCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The anticipated payment date at the depository
   */
  paymentDate?: EntryMaturityPaymentDate | null | undefined;
  /**
   * The trade position quantity used to calculate the disbursed amount
   */
  quantity?: EntryMaturityQuantity | null | undefined;
};

/**
 * Corresponds to whether the entry is incoming outgoing
 */
export enum EntryMergerAction {
  ActionUnspecified = "ACTION_UNSPECIFIED",
  Incoming = "INCOMING",
  Outgoing = "OUTGOING",
  CashInLieu = "CASH_IN_LIEU",
}
/**
 * Corresponds to whether the entry is incoming outgoing
 */
export type EntryMergerActionOpen = OpenEnum<typeof EntryMergerAction>;

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type EntryMergerCashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryMergerCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * Effective date as declared by the primary exchange that generally coincides with cessation of trading in the old security and commencement of trading in the new security
 */
export type EntryMergerEffectiveDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's trade quantity
 */
export type EntryMergerQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which shares will be disbursed to the shareholder
 */
export type EntryMergerStockRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Corresponds to whether the event is CASH | STOCK | CASH_AND_STOCK
 */
export enum EntryMergerType {
  EventTypeUnspecified = "EVENT_TYPE_UNSPECIFIED",
  Cash = "CASH",
  Stock = "STOCK",
  CashAndStock = "CASH_AND_STOCK",
}
/**
 * Corresponds to whether the event is CASH | STOCK | CASH_AND_STOCK
 */
export type EntryMergerTypeOpen = OpenEnum<typeof EntryMergerType>;

/**
 * Used to record the exchange of one company's security for another company's security, cash, or a combination of cash and securities and details related to the merger
 */
export type Merger = {
  /**
   * Corresponds to whether the entry is incoming outgoing
   */
  action?: EntryMergerActionOpen | undefined;
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: EntryMergerCashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryMergerCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * Effective date as declared by the primary exchange that generally coincides with cessation of trading in the old security and commencement of trading in the new security
   */
  effectiveDate?: EntryMergerEffectiveDate | null | undefined;
  /**
   * Corresponds to the position's trade quantity
   */
  quantity?: EntryMergerQuantity | null | undefined;
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which shares will be disbursed to the shareholder
   */
  stockRate?: EntryMergerStockRate | null | undefined;
  /**
   * Corresponds to whether the event is CASH | STOCK | CASH_AND_STOCK
   */
  type?: EntryMergerTypeOpen | undefined;
};

/**
 * Corresponds to whether the entry is incoming outgoing
 */
export enum EntryNameChangeAction {
  ActionUnspecified = "ACTION_UNSPECIFIED",
  Incoming = "INCOMING",
  Outgoing = "OUTGOING",
  CashInLieu = "CASH_IN_LIEU",
}
/**
 * Corresponds to whether the entry is incoming outgoing
 */
export type EntryNameChangeActionOpen = OpenEnum<typeof EntryNameChangeAction>;

/**
 * Common fields for corporate actions
 */
export type EntryNameChangeCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * Effective date as declared by the primary exchange that generally coincides with cessation of trading in the old security and commencement of trading in the new security
 */
export type EntryNameChangeEffectiveDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's settled quantity
 */
export type EntryNameChangeQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Used to record changes in the name of a security/securities by the issuer which result in surrendering physical securities or the assigning of a new security identifier which result in new securities being issued and details related to the name changes
 */
export type NameChange = {
  /**
   * Corresponds to whether the entry is incoming outgoing
   */
  action?: EntryNameChangeActionOpen | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryNameChangeCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * Effective date as declared by the primary exchange that generally coincides with cessation of trading in the old security and commencement of trading in the new security
   */
  effectiveDate?: EntryNameChangeEffectiveDate | null | undefined;
  /**
   * Corresponds to the position's settled quantity
   */
  quantity?: EntryNameChangeQuantity | null | undefined;
};

/**
 * The original entry process date; stable across reversals and corrections; use for maintaining lineage of entries through multiple corrections/reversals
 */
export type OriginalProcessDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryPaymentInKindCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntryPaymentInKindPaymentDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The date on which positions are recorded in order to calculate entitlement
 */
export type EntryPaymentInKindRecordDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's settled quantity
 */
export type EntryPaymentInKindSettled = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which shares will be disbursed to the shareholder
 */
export type EntryPaymentInKindStockRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Used to record payments on interest-bearing securities where the payment is made in additional securities rather than cash and details related to the payment
 */
export type PaymentInKind = {
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryPaymentInKindCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The anticipated payment date at the depository
   */
  paymentDate?: EntryPaymentInKindPaymentDate | null | undefined;
  /**
   * The date on which positions are recorded in order to calculate entitlement
   */
  recordDate?: EntryPaymentInKindRecordDate | null | undefined;
  /**
   * Corresponds to the position's settled quantity
   */
  settled?: EntryPaymentInKindSettled | null | undefined;
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which shares will be disbursed to the shareholder
   */
  stockRate?: EntryPaymentInKindStockRate | null | undefined;
};

/**
 * The monetary value paid for a given security in a trade Required, except for currency movements
 */
export type EntryPrice = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The date that the entry was booked on
 */
export type EntryProcessDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The quantity of shares bought, sold, or moved. For entries/ activities involving Fixed Income assets, quantity is expressed as par value Required for trades and memos, optional for movements.
 */
export type EntryQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Object containing metadata for receive events
 */
export type Receive = {};

/**
 * Corresponds to whether the entry is incoming outgoing
 */
export enum EntryRedemptionFullAction {
  ActionUnspecified = "ACTION_UNSPECIFIED",
  Incoming = "INCOMING",
  Outgoing = "OUTGOING",
  CashInLieu = "CASH_IN_LIEU",
}
/**
 * Corresponds to whether the entry is incoming outgoing
 */
export type EntryRedemptionFullActionOpen = OpenEnum<
  typeof EntryRedemptionFullAction
>;

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type EntryRedemptionFullCashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryRedemptionFullCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntryRedemptionFullPaymentDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's trade quantity
 */
export type EntryRedemptionFullQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Corresponds to the subtype of corporaction type
 */
export enum EntryRedemptionFullSubtype {
  CorporateactionsubtypeUnspecified = "CORPORATEACTIONSUBTYPE_UNSPECIFIED",
  AdditionalDividend = "ADDITIONAL_DIVIDEND",
  ApproximateRate = "APPROXIMATE_RATE",
  DividendArrears = "DIVIDEND_ARREARS",
  DividendCancelled = "DIVIDEND_CANCELLED",
  DividendPaymentTaxClassifications = "DIVIDEND_PAYMENT_TAX_CLASSIFICATIONS",
  DividendRescinded = "DIVIDEND_RESCINDED",
  EstimatedReturnOfCapital = "ESTIMATED_RETURN_OF_CAPITAL",
  EstimatedReturnOfCapitalPlusIncome =
    "ESTIMATED_RETURN_OF_CAPITAL_PLUS_INCOME",
  ExtraDividend = "EXTRA_DIVIDEND",
  ExtraDividendPlusIncome = "EXTRA_DIVIDEND_PLUS_INCOME",
  FinalPaymentTransferBooksAreClosed =
    "FINAL_PAYMENT_TRANSFER_BOOKS_ARE_CLOSED",
  GrossRate = "GROSS_RATE",
  InitialDividend = "INITIAL_DIVIDEND",
  InitialDividendLongPeriod = "INITIAL_DIVIDEND_LONG_PERIOD",
  InitialDividendShortPeriod = "INITIAL_DIVIDEND_SHORT_PERIOD",
  LimitedPartnershipDistribution = "LIMITED_PARTNERSHIP_DISTRIBUTION",
  Liquidation = "LIQUIDATION",
  NetRate = "NET_RATE",
  Other = "OTHER",
  ProceedsFromSaleOfRights = "PROCEEDS_FROM_SALE_OF_RIGHTS",
  RegularDividend = "REGULAR_DIVIDEND",
  ReturnOfCapital = "RETURN_OF_CAPITAL",
  ReturnOfCapitalPlusIncome = "RETURN_OF_CAPITAL_PLUS_INCOME",
  SpecialDividend = "SPECIAL_DIVIDEND",
  SpecialDividendPlusIncome = "SPECIAL_DIVIDEND_PLUS_INCOME",
  YearEndDividend = "YEAR_END_DIVIDEND",
  YearEndDividendPlusIncome = "YEAR_END_DIVIDEND_PLUS_INCOME",
  Partial = "PARTIAL",
  Full = "FULL",
  Maturity = "MATURITY",
  Termination = "TERMINATION",
  RedemptionOfWarrants = "REDEMPTION_OF_WARRANTS",
}
/**
 * Corresponds to the subtype of corporaction type
 */
export type EntryRedemptionFullSubtypeOpen = OpenEnum<
  typeof EntryRedemptionFullSubtype
>;

/**
 * Used to record the redemption of a security for cash in its entirety for which the holders receive the principal amount of the security and details related to the redemption
 */
export type RedemptionFull = {
  /**
   * Corresponds to whether the entry is incoming outgoing
   */
  action?: EntryRedemptionFullActionOpen | undefined;
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: EntryRedemptionFullCashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryRedemptionFullCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The anticipated payment date at the depository
   */
  paymentDate?: EntryRedemptionFullPaymentDate | null | undefined;
  /**
   * Corresponds to the position's trade quantity
   */
  quantity?: EntryRedemptionFullQuantity | null | undefined;
  /**
   * Corresponds to the subtype of corporaction type
   */
  subtype?: EntryRedemptionFullSubtypeOpen | undefined;
};

/**
 * Corresponds to whether the entry is incoming or outgoing
 */
export enum EntryRedemptionPartialAction {
  ActionUnspecified = "ACTION_UNSPECIFIED",
  Incoming = "INCOMING",
  Outgoing = "OUTGOING",
  CashInLieu = "CASH_IN_LIEU",
}
/**
 * Corresponds to whether the entry is incoming or outgoing
 */
export type EntryRedemptionPartialActionOpen = OpenEnum<
  typeof EntryRedemptionPartialAction
>;

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type EntryRedemptionPartialCashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryRedemptionPartialCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntryRedemptionPartialPaymentDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's trade quantity
 */
export type EntryRedemptionPartialQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Used when securities are redeemed by the issuer for cash, in part, before their scheduled maturity date and details related to the redemption. The outstanding amount of securities will be proportionally reduced based on a specific percentage of holding
 */
export type RedemptionPartial = {
  /**
   * Corresponds to whether the entry is incoming or outgoing
   */
  action?: EntryRedemptionPartialActionOpen | undefined;
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: EntryRedemptionPartialCashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryRedemptionPartialCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The anticipated payment date at the depository
   */
  paymentDate?: EntryRedemptionPartialPaymentDate | null | undefined;
  /**
   * Corresponds to the position's trade quantity
   */
  quantity?: EntryRedemptionPartialQuantity | null | undefined;
};

/**
 * Corresponds to whether the entry is incoming or outgoing
 */
export enum EntryReverseStockSplitAction {
  ActionUnspecified = "ACTION_UNSPECIFIED",
  Incoming = "INCOMING",
  Outgoing = "OUTGOING",
  CashInLieu = "CASH_IN_LIEU",
}
/**
 * Corresponds to whether the entry is incoming or outgoing
 */
export type EntryReverseStockSplitActionOpen = OpenEnum<
  typeof EntryReverseStockSplitAction
>;

/**
 * Common fields for corporate actions
 */
export type EntryReverseStockSplitCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * Effective date as declared by the primary exchange that generally coincides with cessation of trading in the old security and commencement of trading in the new security
 */
export type EntryReverseStockSplitEffectiveDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The previous rate of the security before the distribution
 */
export type FactorDenominator = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The rate of the security distribution
 */
export type FactorNumerator = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Corresponds to the position's trade quantity
 */
export type EntryReverseStockSplitQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which shares will be disbursed to the shareholder
 */
export type EntryReverseStockSplitStockRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Used to record the exchange of a company's security for the same company's new security at a preset rate and details related to the reverse stock split
 */
export type ReverseStockSplit = {
  /**
   * Corresponds to whether the entry is incoming or outgoing
   */
  action?: EntryReverseStockSplitActionOpen | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryReverseStockSplitCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * Effective date as declared by the primary exchange that generally coincides with cessation of trading in the old security and commencement of trading in the new security
   */
  effectiveDate?: EntryReverseStockSplitEffectiveDate | null | undefined;
  /**
   * The previous rate of the security before the distribution
   */
  factorDenominator?: FactorDenominator | null | undefined;
  /**
   * The rate of the security distribution
   */
  factorNumerator?: FactorNumerator | null | undefined;
  /**
   * Corresponds to the position's trade quantity
   */
  quantity?: EntryReverseStockSplitQuantity | null | undefined;
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which shares will be disbursed to the shareholder
   */
  stockRate?: EntryReverseStockSplitStockRate | null | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryRightsDistributionCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntryRightsDistributionPaymentDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The date on which positions are recorded in order to calculate entitlement
 */
export type EntryRightsDistributionRecordDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's settled quantity
 */
export type EntryRightsDistributionSettled = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Used to record distributions to common stock holders of a company that grant the option to purchase new or additional securities of the same company during a predetermined time period at a predetermined price and details related to the rights distribution
 */
export type RightsDistribution = {
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryRightsDistributionCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The anticipated payment date at the depository
   */
  paymentDate?: EntryRightsDistributionPaymentDate | null | undefined;
  /**
   * The date on which positions are recorded in order to calculate entitlement
   */
  recordDate?: EntryRightsDistributionRecordDate | null | undefined;
  /**
   * Corresponds to the position's settled quantity
   */
  settled?: EntryRightsDistributionSettled | null | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryRightsSubscriptionCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * Used to record the purchase of new or additional securities and details related to the subscription. Rights are often tradable in a secondary market
 */
export type RightsSubscription = {
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryRightsSubscriptionCorporateActionGeneralInformation
    | null
    | undefined;
};

/**
 * Used to record rounding adjustments when the sum(price x quantity) of all entries for a given activity do not equal the price x quantity of the fully formed activity record
 */
export type RoundingAdjustment = {
  /**
   * Free form text field providing reason for rounding
   */
  roundingReason?: string | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type EntrySaleOfRightsCashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntrySaleOfRightsCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntrySaleOfRightsPaymentDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The date on which positions are recorded in order to calculate entitlement
 */
export type EntrySaleOfRightsRecordDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's settled quantity
 */
export type EntrySaleOfRightsSettled = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Used to record payments made by the issuer to security holders when the security is subject to redemptions other than full and partial calls (e.g., early CD redemptions) and details related to the sale of rights
 */
export type SaleOfRights = {
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: EntrySaleOfRightsCashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntrySaleOfRightsCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The anticipated payment date at the depository
   */
  paymentDate?: EntrySaleOfRightsPaymentDate | null | undefined;
  /**
   * The date on which positions are recorded in order to calculate entitlement
   */
  recordDate?: EntrySaleOfRightsRecordDate | null | undefined;
  /**
   * Corresponds to the position's settled quantity
   */
  settled?: EntrySaleOfRightsSettled | null | undefined;
};

/**
 * The date a given entry/ activity will officially settle
 */
export type SettleDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Denotes whether the trade is a buy or sell
 */
export enum EntrySide {
  SideUnspecified = "SIDE_UNSPECIFIED",
  Buy = "BUY",
  Sell = "SELL",
}
/**
 * Denotes whether the trade is a buy or sell
 */
export type EntrySideOpen = OpenEnum<typeof EntrySide>;

/**
 * Indicates whether the trade is opening a new position or closing an existing position Should be populated if possible for trades; the side modifier for the trade
 */
export enum EntrySideModifier {
  SideModifierUnspecified = "SIDE_MODIFIER_UNSPECIFIED",
  Short = "SHORT",
  ShortExempt = "SHORT_EXEMPT",
  ShortCover = "SHORT_COVER",
  Open = "OPEN",
  Close = "CLOSE",
}
/**
 * Indicates whether the trade is opening a new position or closing an existing position Should be populated if possible for trades; the side modifier for the trade
 */
export type EntrySideModifierOpen = OpenEnum<typeof EntrySideModifier>;

/**
 * Common fields for corporate actions
 */
export type EntrySpinOffCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type PayDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's settled quantity
 */
export type EntrySpinOffQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The rate at which shares will be disbursed to the shareholder
 */
export type EntrySpinOffRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The date on which positions are recorded in order to calculate entitlement
 */
export type EntrySpinOffRecordDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Used to record a distribution of subsidiary securities to the shareholders of the parent company without a surrender of securities or payment and details related to the spinoff. A spin-off represents a form of divestiture resulting in an independent company
 */
export type SpinOff = {
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntrySpinOffCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The anticipated payment date at the depository
   */
  payDate?: PayDate | null | undefined;
  /**
   * Corresponds to the position's settled quantity
   */
  quantity?: EntrySpinOffQuantity | null | undefined;
  /**
   * The rate at which shares will be disbursed to the shareholder
   */
  rate?: EntrySpinOffRate | null | undefined;
  /**
   * The date on which positions are recorded in order to calculate entitlement
   */
  recordDate?: EntrySpinOffRecordDate | null | undefined;
};

/**
 * Set to be NEW for BookEntries, other statuses will be assigned via ModifyActivities; the state of the entry
 */
export enum EntryState {
  EntryStateUnspecified = "ENTRY_STATE_UNSPECIFIED",
  New = "NEW",
  Reversal = "REVERSAL",
  Correction = "CORRECTION",
}
/**
 * Set to be NEW for BookEntries, other statuses will be assigned via ModifyActivities; the state of the entry
 */
export type EntryStateOpen = OpenEnum<typeof EntryState>;

/**
 * Common fields for corporate actions
 */
export type EntryStockDividendCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntryPayDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's settled quantity
 */
export type EntryStockDividendQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The rate at which shares will be disbursed to the shareholder
 */
export type EntryRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The date on which positions are recorded in order to calculate entitlement
 */
export type EntryStockDividendRecordDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Used to record a dividend paid to shareholders in the form of shares of stock in either the issuing company or in another company and details related to the stock dividend
 */
export type StockDividend = {
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryStockDividendCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The anticipated payment date at the depository
   */
  payDate?: EntryPayDate | null | undefined;
  /**
   * Corresponds to the position's settled quantity
   */
  quantity?: EntryStockDividendQuantity | null | undefined;
  /**
   * The rate at which shares will be disbursed to the shareholder
   */
  rate?: EntryRate | null | undefined;
  /**
   * The date on which positions are recorded in order to calculate entitlement
   */
  recordDate?: EntryStockDividendRecordDate | null | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryStockSplitCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The previous rate of the security before the distribution
 */
export type EntryFactorDenominator = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The rate of the security distribution
 */
export type EntryFactorNumerator = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntryStockSplitPayDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Corresponds to the position's trade quantity
 */
export type EntryStockSplitQuantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The date on which positions are recorded in order to calculate entitlement
 */
export type EntryStockSplitRecordDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Used to record the increase in a company's number of outstanding shares of stock without any change in the shareholder's equity or the aggregate market value at the time of the split and details related to the stock split
 */
export type StockSplit = {
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryStockSplitCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The previous rate of the security before the distribution
   */
  factorDenominator?: EntryFactorDenominator | null | undefined;
  /**
   * The rate of the security distribution
   */
  factorNumerator?: EntryFactorNumerator | null | undefined;
  /**
   * The anticipated payment date at the depository
   */
  payDate?: EntryStockSplitPayDate | null | undefined;
  /**
   * Corresponds to the position's trade quantity
   */
  quantity?: EntryStockSplitQuantity | null | undefined;
  /**
   * The date on which positions are recorded in order to calculate entitlement
   */
  recordDate?: EntryStockSplitRecordDate | null | undefined;
};

/**
 * Indicates purchase or redemption of the sweep asset
 */
export enum EntrySweepAction {
  SweepActionUnspecified = "SWEEP_ACTION_UNSPECIFIED",
  Purchase = "PURCHASE",
  Redemption = "REDEMPTION",
}
/**
 * Indicates purchase or redemption of the sweep asset
 */
export type EntrySweepActionOpen = OpenEnum<typeof EntrySweepAction>;

/**
 * Sweep program that cash is being swept to/ from
 */
export enum EntrySweepType {
  SweepTypeUnspecified = "SWEEP_TYPE_UNSPECIFIED",
  Fdic = "FDIC",
  MoneyMarket = "MONEY_MARKET",
}
/**
 * Sweep program that cash is being swept to/ from
 */
export type EntrySweepTypeOpen = OpenEnum<typeof EntrySweepType>;

/**
 * Used to record sweeps from a cash balance to an alternative asset or vice versa and details related to the sweep
 */
export type Sweep = {
  /**
   * Indicates purchase or redemption of the sweep asset
   */
  action?: EntrySweepActionOpen | undefined;
  /**
   * Indicates the sweep was performed books were closed to prevent an investor account from carrying a negative cash balance overnight
   */
  eodRedemption?: boolean | undefined;
  /**
   * Sweep program that cash is being swept to/ from
   */
  type?: EntrySweepTypeOpen | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
 */
export type EntryTenderOfferCashRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryTenderOfferCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * the type of tender offer
 */
export enum TenderOfferType {
  TenderOfferTypeUnspecified = "TENDER_OFFER_TYPE_UNSPECIFIED",
  OddLotTender = "ODD_LOT_TENDER",
  DutchAuction = "DUTCH_AUCTION",
}
/**
 * the type of tender offer
 */
export type TenderOfferTypeOpen = OpenEnum<typeof TenderOfferType>;

/**
 * Used to record the sale of securities for a specified price due to an offer from the issuer or a third party and details related to the tender offer
 */
export type TenderOffer = {
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which cash will be disbursed to the shareholder
   */
  cashRate?: EntryTenderOfferCashRate | null | undefined;
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryTenderOfferCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * the type of tender offer
   */
  tenderOfferType?: TenderOfferTypeOpen | undefined;
};

/**
 * Used to calculate broadridge blotter code
 */
export enum EntryTradeBrokerCapacity {
  CapacityUnspecified = "CAPACITY_UNSPECIFIED",
  Agency = "AGENCY",
  Principal = "PRINCIPAL",
  Mixed = "MIXED",
}
/**
 * Used to calculate broadridge blotter code
 */
export type EntryTradeBrokerCapacityOpen = OpenEnum<
  typeof EntryTradeBrokerCapacity
>;

/**
 * The price for the instrument that is prevailing in the market
 */
export type EntryTradePrevailingMarketPrice = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Total monetary value of the price_adjustment
 */
export type EntryTradePriceAdjustmentAmount = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)
 */
export type EntryPriceAdjustmentPercent = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The type of price adjustment being applied by the broker to the net price of the security
 */
export enum EntryTradePriceAdjustmentType {
  PriceAdjustmentTypeUnspecified = "PRICE_ADJUSTMENT_TYPE_UNSPECIFIED",
  Markup = "MARKUP",
  Markdown = "MARKDOWN",
  SalesLoad = "SALES_LOAD",
}
/**
 * The type of price adjustment being applied by the broker to the net price of the security
 */
export type EntryTradePriceAdjustmentTypeOpen = OpenEnum<
  typeof EntryTradePriceAdjustmentType
>;

/**
 * Information about any price adjustments applied to the security
 */
export type EntryPriceAdjustmentRecord = {
  /**
   * Total monetary value of the price_adjustment
   */
  priceAdjustmentAmount?: EntryTradePriceAdjustmentAmount | null | undefined;
  /**
   * The percent at which the price was adjusted. Expressed as a number from 0.00-100 (rounded to 2 decimals)
   */
  priceAdjustmentPercent?: EntryPriceAdjustmentPercent | null | undefined;
  /**
   * The type of price adjustment being applied by the broker to the net price of the security
   */
  priceAdjustmentType?: EntryTradePriceAdjustmentTypeOpen | undefined;
};

/**
 * Used to record the the execution of a buy or sell transaction resulting in the transfer of securities and corresponding payment and details related to the trade
 */
export type EntryTrade = {
  /**
   * To be populated by the submitter of the trade detail
   */
  additionalInstructions?: Array<string> | undefined;
  /**
   * Max Length 50 characters. Alternate order id from the street used for FRAC trades
   */
  alternateOrderId?: string | undefined;
  /**
   * base64 encoded value assigned by the Booking API to all executions
   */
  bookingApiBookingExecutionId?: string | undefined;
  /**
   * base64 encoded value assigned by the Booking API if a trade belongs to an allocation
   */
  bookingApiTradeAllocationId?: string | undefined;
  /**
   * base64 encoded value assigned by the Booking API to all trades
   */
  bookingApiTradeId?: string | undefined;
  /**
   * Executing broker of the trade
   */
  broker?: string | undefined;
  /**
   * Used to calculate broadridge blotter code
   */
  brokerCapacity?: EntryTradeBrokerCapacityOpen | undefined;
  /**
   * client usage area (intact). len 20
   */
  clientMemo?: string | undefined;
  /**
   * Max Length 50 characters. Client provided order id present in exec reports
   */
  clientOrderId?: string | undefined;
  /**
   * MIC code for the exchange
   */
  exchange?: string | undefined;
  /**
   * Max Length 50 characters. Execution id from the street
   */
  executionId?: string | undefined;
  /**
   * Indicates whether Apex is the clearing broker for this trade
   */
  executionOnly?: boolean | undefined;
  /**
   * Max Length 50 characters. External system id provided by a client
   */
  externalId?: string | undefined;
  /**
   * The confirmation number associated with a mutual fund trade
   */
  fundConfirmationNumber?: string | undefined;
  /**
   * Order id generated by trading-gateway (Trade-Ex) to uniquely identify all orders in their system Used as the client_order_id on new order singles sent downstream of the trading-gateway
   */
  gatewayClientOrderId?: string | undefined;
  /**
   * If set to true, indicates the trade should be omitted from client billing
   */
  internalError?: boolean | undefined;
  /**
   * set on penny-for-the-lot trades
   */
  isWriteoff?: boolean | undefined;
  /**
   * Trade lots
   */
  lots?: Array<Lot> | undefined;
  /**
   * "MMAP" for multi market average price, "UNKN" for unknown
   */
  market?: string | undefined;
  /**
   * Max Length 50 characters. Internally generated order id that is returned to client on exec reports
   */
  orderId?: string | undefined;
  /**
   * The price for the instrument that is prevailing in the market
   */
  prevailingMarketPrice?: EntryTradePrevailingMarketPrice | null | undefined;
  /**
   * Information about any price adjustments applied to the security
   */
  priceAdjustmentRecord?: EntryPriceAdjustmentRecord | null | undefined;
  /**
   * The execution route Apex used for this trade
   */
  route?: string | undefined;
  /**
   * Special instructions for the trade
   */
  specialInstructions?: Array<string> | undefined;
  /**
   * Indicates the trade was executed in a security that is not currently listed. When-issued securities are bought and sold before they are officially issued, allowing investors to speculate on their future value
   */
  whenIssued?: boolean | undefined;
  /**
   * The yields associated with a fixed income trade Only valid if the SecurityType is FIXED_INCOME
   */
  yieldRecords?: Array<YieldRecord> | undefined;
};

/**
 * Provides more detail on the type of transfer
 */
export enum EntryTransferType {
  TransferTypeUnspecified = "TRANSFER_TYPE_UNSPECIFIED",
  TransferConversion = "TRANSFER_CONVERSION",
  Deconversion = "DECONVERSION",
  Migration = "MIGRATION",
  ManualAdjustment = "MANUAL_ADJUSTMENT",
  InternalConversion = "INTERNAL_CONVERSION",
}
/**
 * Provides more detail on the type of transfer
 */
export type EntryTransferTypeOpen = OpenEnum<typeof EntryTransferType>;

/**
 * Used to record more generic transfers of funds or securities and details related to the transfer. The transfer type and activity_description can be used to provide more specific context
 */
export type EntryTransfer = {
  /**
   * Free form text field
   */
  additionalInstructions?: string | undefined;
  /**
   * String field that can be populated with the broker dealer undergoing a clearing platform conversion. Used for activity description purposes
   */
  clientBrokerage?: string | undefined;
  /**
   * Provides more detail on the type of transfer
   */
  transferType?: EntryTransferTypeOpen | undefined;
};

/**
 * The Type of the entry; determines the set of mandatory fields as well as informing downstream processes how to handle this record
 */
export enum EntryType {
  TypeUnspecified = "TYPE_UNSPECIFIED",
  Trade = "TRADE",
  Movement = "MOVEMENT",
  Memo = "MEMO",
  CorporateAction = "CORPORATE_ACTION",
}
/**
 * The Type of the entry; determines the set of mandatory fields as well as informing downstream processes how to handle this record
 */
export type EntryTypeOpen = OpenEnum<typeof EntryType>;

/**
 * Common fields for corporate actions
 */
export type EntryUnitSplitCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which shares will be disbursed to the shareholder
 */
export type EntryUnitSplitStockRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Used to record increases in the number of units outstanding through the issuing of more units to current shareholders and details related to the unit split
 */
export type UnitSplit = {
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryUnitSplitCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * The rate (raw value, not a percentage, example: 50% will be .5 in this field) at which shares will be disbursed to the shareholder
   */
  stockRate?: EntryUnitSplitStockRate | null | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryWarrantExerciseCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * Used to record the exchange of warrants for shares and details related to the warrant exercise. The exercise will commonly require a payment based upon a pre-determined value and time and details related to the warrant exercise
 */
export type WarrantExercise = {
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryWarrantExerciseCorporateActionGeneralInformation
    | null
    | undefined;
};

/**
 * Provides information on the reason for the distribution from a retirement account
 */
export enum DistributionType {
  DistributionTypeUnspecified = "DISTRIBUTION_TYPE_UNSPECIFIED",
  Premature = "PREMATURE",
  Disability = "DISABILITY",
  Death = "DEATH",
  Normal = "NORMAL",
  Sosepp = "SOSEPP",
  RolloverToQualifiedPlan = "ROLLOVER_TO_QUALIFIED_PLAN",
  RolloverToIra = "ROLLOVER_TO_IRA",
  DistTransfer = "DIST_TRANSFER",
  ExcessContributionRemovalBeforeTaxDeadline =
    "EXCESS_CONTRIBUTION_REMOVAL_BEFORE_TAX_DEADLINE",
  ExcessContributionRemovalAfterTaxDeadline =
    "EXCESS_CONTRIBUTION_REMOVAL_AFTER_TAX_DEADLINE",
  RecharacterizationPriorYear = "RECHARACTERIZATION_PRIOR_YEAR",
  RecharacterizationCurrentYear = "RECHARACTERIZATION_CURRENT_YEAR",
  DistConversion = "DIST_CONVERSION",
  ManagementFee = "MANAGEMENT_FEE",
  PrematureSimpleIraLessThan2Years = "PREMATURE_SIMPLE_IRA_LESS_THAN_2_YEARS",
  NormalRothIraGreaterThan5Years = "NORMAL_ROTH_IRA_GREATER_THAN_5_YEARS",
  PlanLoan401K = "PLAN_LOAN_401K",
  NetIncomeAttributable = "NET_INCOME_ATTRIBUTABLE",
  Revocation = "REVOCATION",
  NonReportable = "NON_REPORTABLE",
}
/**
 * Provides information on the reason for the distribution from a retirement account
 */
export type DistributionTypeOpen = OpenEnum<typeof DistributionType>;

/**
 * Used for descriptive purposes only. Indicates the type of retirement account
 */
export enum RetirementType {
  RetirementTypeUnspecified = "RETIREMENT_TYPE_UNSPECIFIED",
  Ira = "IRA",
  Sep = "SEP",
  Simple = "SIMPLE",
  Keogh = "KEOGH",
  Roth = "ROTH",
  Qp = "QP",
  RolloverIra = "ROLLOVER_IRA",
}
/**
 * Used for descriptive purposes only. Indicates the type of retirement account
 */
export type RetirementTypeOpen = OpenEnum<typeof RetirementType>;

/**
 * Provides information on the method through which a deposit/ withdrawal was initiated
 */
export enum EntryWithdrawalType {
  ExternalMovementTypeUnspecified = "EXTERNAL_MOVEMENT_TYPE_UNSPECIFIED",
  Ach = "ACH",
  Check = "CHECK",
  Wire = "WIRE",
  Paypal = "PAYPAL",
  Rtp = "RTP",
  Ict = "ICT",
  Journal = "JOURNAL",
  ExternalAch = "EXTERNAL_ACH",
}
/**
 * Provides information on the method through which a deposit/ withdrawal was initiated
 */
export type EntryWithdrawalTypeOpen = OpenEnum<typeof EntryWithdrawalType>;

/**
 * Used to record withdrawals of funds from an account and capture details related to the withdrawal
 */
export type Withdrawal = {
  /**
   * Free form text field
   */
  additionalInstructions?: string | undefined;
  /**
   * Indicates the withdrawal was part of an account closure
   */
  closingAccount?: boolean | undefined;
  /**
   * Human readable account identifier for the account the assets were journaled. To be populated when the Withdrawal type is Journal
   */
  destinationAccountNumber?: string | undefined;
  /**
   * If populated, provides information on the institution the funds have been sent to
   */
  destinationInstitution?: string | undefined;
  /**
   * Provides information on the reason for the distribution from a retirement account
   */
  distributionType?: DistributionTypeOpen | undefined;
  /**
   * tax year associated with the distribution
   */
  distributionYear?: number | undefined;
  /**
   * Unique tracking number provided to allow tracking a wire transfer from the initiating bank to the receiving bank
   */
  fedReferenceNumber?: string | undefined;
  /**
   * If populated, provides information on the institution where the funds originated
   */
  originatingInstitution?: string | undefined;
  periodic?: boolean | undefined;
  /**
   * Used for descriptive purposes only. Indicates the type of retirement account
   */
  retirementType?: RetirementTypeOpen | undefined;
  /**
   * Indicates whether or a not a distribution is a full liquidation of a tax-advantaged account
   */
  totalDistribution?: boolean | undefined;
  /**
   * Provides information on the method through which a deposit/ withdrawal was initiated
   */
  type?: EntryWithdrawalTypeOpen | undefined;
};

/**
 * Indicates the state of the withdrawal review
 */
export enum Review {
  ReviewStateUnspecified = "REVIEW_STATE_UNSPECIFIED",
  ReviewStatePending = "REVIEW_STATE_PENDING",
  ReviewStateComplete = "REVIEW_STATE_COMPLETE",
}
/**
 * Indicates the state of the withdrawal review
 */
export type ReviewOpen = OpenEnum<typeof Review>;

/**
 * Used to record the movement of funds to/ from the pending_withdrawal memo location
 */
export type WithdrawalPendingReview = {
  /**
   * Indicates the state of the withdrawal review
   */
  review?: ReviewOpen | undefined;
};

/**
 * the rate will be converted to a percentage in the activity description
 */
export type EntryWithholdingRate = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

export enum EntryWithholdingState {
  WithholdingStateUnspecified = "WITHHOLDING_STATE_UNSPECIFIED",
  Ca = "CA",
  Me = "ME",
  Vt = "VT",
  Al = "AL",
  Ak = "AK",
  Az = "AZ",
  Ar = "AR",
  Co = "CO",
  Ct = "CT",
  De = "DE",
  Fl = "FL",
  Ga = "GA",
  Hi = "HI",
  Id = "ID",
  Il = "IL",
  In = "IN",
  Ia = "IA",
  Ks = "KS",
  Ky = "KY",
  La = "LA",
  Md = "MD",
  Ma = "MA",
  Mi = "MI",
  Mn = "MN",
  Ms = "MS",
  Mo = "MO",
  Mt = "MT",
  Ne = "NE",
  Nv = "NV",
  Nh = "NH",
  Nj = "NJ",
  Nm = "NM",
  Ny = "NY",
  Nc = "NC",
  Nd = "ND",
  Oh = "OH",
  Ok = "OK",
  Or = "OR",
  Pa = "PA",
  Ri = "RI",
  Sc = "SC",
  Sd = "SD",
  Tn = "TN",
  Tx = "TX",
  Ut = "UT",
  Va = "VA",
  Wa = "WA",
  Wv = "WV",
  Wi = "WI",
  Wy = "WY",
}
export type EntryWithholdingStateOpen = OpenEnum<typeof EntryWithholdingState>;

/**
 * The type of withholding
 */
export enum EntryWithholdingType {
  WithholdingTypeUnspecified = "WITHHOLDING_TYPE_UNSPECIFIED",
  Federal = "FEDERAL",
  State = "STATE",
  ForeignSecurity = "FOREIGN_SECURITY",
  FederalIra = "FEDERAL_IRA",
  StateIra = "STATE_IRA",
  NonResidentAlien = "NON_RESIDENT_ALIEN",
}
/**
 * The type of withholding
 */
export type EntryWithholdingTypeOpen = OpenEnum<typeof EntryWithholdingType>;

/**
 * Used to record tax withholdings and details related to the withholding
 */
export type EntryWithholding = {
  /**
   * the rate will be converted to a percentage in the activity description
   */
  rate?: EntryWithholdingRate | null | undefined;
  /**
   * Two character region code, complies with https://cldr.unicode.org/index
   */
  regionCode?: string | undefined;
  state?: EntryWithholdingStateOpen | undefined;
  /**
   * The tax year associated with the withholding
   */
  taxYear?: number | undefined;
  /**
   * The type of withholding
   */
  type?: EntryWithholdingTypeOpen | undefined;
};

/**
 * Common fields for corporate actions
 */
export type EntryWorthlessCorporateActionGeneralInformation = {
  /**
   * A unique alphanumeric value that is assigned to uniquely identify each corporate action event
   */
  corporateActionId?: string | undefined;
  /**
   * Asset Id of the new security after the corporate action event is processed
   */
  disbursedAssetId?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedCusip?: string | undefined;
  /**
   * When populated, the name of the issuer of a security and additional descriptive information about the new security after the corporate action event is processed
   */
  disbursedSymbolDescription?: string | undefined;
  /**
   * Asset Id of the existing security before the corporate action event is processed
   */
  targetAssetId?: string | undefined;
  /**
   * External Identifier of the existing security before the corporate action event is processed
   */
  targetCusip?: string | undefined;
  /**
   * Name of the issuer of a security and additional descriptive information about the existing security before the corporate action event is processed
   */
  targetSymbolDescription?: string | undefined;
};

/**
 * Effective date as declared by the primary exchange that generally coincides with cessation of trading in the old security and commencement of trading in the new security
 */
export type EntryWorthlessEffectiveDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * The anticipated payment date at the depository
 */
export type EntryWorthlessPaymentDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Used to record the removal of positions in a given security when the DTC has received formal notice that the security is worthless and details related to the worthless event
 */
export type Worthless = {
  /**
   * Common fields for corporate actions
   */
  corporateActionGeneralInformation?:
    | EntryWorthlessCorporateActionGeneralInformation
    | null
    | undefined;
  /**
   * Effective date as declared by the primary exchange that generally coincides with cessation of trading in the old security and commencement of trading in the new security
   */
  effectiveDate?: EntryWorthlessEffectiveDate | null | undefined;
  /**
   * The anticipated payment date at the depository
   */
  paymentDate?: EntryWorthlessPaymentDate | null | undefined;
};

/**
 * Entry is a single sided ledger booking that serves as the core ledger component; it is sparsely populated based on the entry type and the goal of the entry
 */
export type Entry = {
  /**
   * Used to record the movement of funds or shares to/ from the pending_acats memo location
   */
  acatsPendingOut?: AcatsPendingOut | null | undefined;
  /**
   * A globally unique identifier referencing a single account; this is the main identifier for an account used for machine-to-machine interactions
   */
  accountId?: string | undefined;
  /**
   * Indicates the memo location impacted by an entry
   */
  accountMemo?: AccountMemoOpen | undefined;
  /**
   * Used to record the movement of funds or shares during the bookkeeping phase of an account transfer and details related to the account transfer
   */
  accountTransfer?: AccountTransfer | null | undefined;
  /**
   * Indicates that the entry references accrued interest that has been earned but not yet paid between the last interest payment and the date of the trade
   */
  accruedInterest?: EntryAccruedInterest | null | undefined;
  /**
   * Object containing metadata for acquisition events
   */
  acquisition?: Acquisition | null | undefined;
  /**
   * The activity date refers to the specific calendar day on which a financial transaction, such as a trade at an exchange or a deposit at a bank, was executed. This date is specific to the institution where the transaction took place, capturing the exact day on which the institution formally records and effects the transaction
   */
  activityDate?: ActivityDate | null | undefined;
  /**
   * Apex-generated unique activity identifier
   */
  activityId?: string | undefined;
  /**
   * Activity time refers to the precise moment, recorded in Coordinated Universal Time (UTC), when a financial transaction is executed as reported to Apex
   */
  activityTime?: Date | null | undefined;
  /**
   * Object containing metadata for trade allocation
   */
  allocation?: Allocation | null | undefined;
  /**
   * An Apex-provided, global identifier created on a per asset bases which provides connectivity across all areas Required, except for currency movements which should instead have a currency_asset_id
   */
  assetId?: string | undefined;
  /**
   * Object containing metadata for bond defaults
   */
  bondDefault?: BondDefault | null | undefined;
  /**
   * Used to record a distribution of cash that an issuer has determined will be declared as income financed from capital gains and not ordinary income and details related to the capital gain
   */
  capitalGains?: CapitalGains | null | undefined;
  /**
   * Used to record the distribution of cash to shareholders, paid by the issuer, usually based upon current earnings and/or accumulated profits as declared by the board of directors and details related to the cash dividend
   */
  cashDividend?: CashDividend | null | undefined;
  /**
   * Object containing metadata for cash in lieu
   */
  cashInLieu?: CashInLieu | null | undefined;
  /**
   * Indicates that the entry references commission charged by brokers or financial intermediaries for executing financial transactions on behalf of clients
   */
  commission?: EntryCommission | null | undefined;
  /**
   * Used to record the conversion of securities (generally convertible bonds or preferred shares) into another form of securities (usually common shares) at a pre-stated price or rate and details related to the conversion
   */
  conversion?: Conversion | null | undefined;
  /**
   * Object containing metadata for memo locations that have been adjusted due to a corporate action
   */
  corporateActionMemoAdjustment?:
    | CorporateActionMemoAdjustment
    | null
    | undefined;
  /**
   * Used to disburse funds into a customer's account, typically for purposes such as refunds, interest payments, or rewards from enrolled programs and details related to the credit
   */
  credit?: Credit | null | undefined;
  /**
   * The asset_id of the currency that all monetary values relate to Required for currency movements
   */
  currencyAssetId?: string | undefined;
  /**
   * Object containing metadata for delivery events
   */
  delivery?: Delivery | null | undefined;
  /**
   * Used to record deposits of funds into an account and capture details related to the deposit
   */
  deposit?: Deposit | null | undefined;
  /**
   * A plain text description of the entry; will not be available to search on or build other features off of
   */
  description?: string | undefined;
  /**
   * Used to record the movement of funds to/ from the pending_drip memo location
   */
  drip?: Drip | null | undefined;
  /**
   * The unique id of the entry
   */
  entryId?: string | undefined;
  /**
   * Used to record the exchange of certificates for a new security or cash and details related to the exchange
   */
  exchange?: Exchange | null | undefined;
  /**
   * Used to record Fees that have been assessed to account and capture details related to the fee
   */
  fee?: EntryFee | null | undefined;
  /**
   * Object containing metadata for a Flip
   */
  flip?: Flip | null | undefined;
  /**
   * Used to record the movements of shares to/ from the fpsl memo location and details related to the fpsl memo
   */
  fpsl?: Fpsl | null | undefined;
  /**
   * The monetary value of an activity, exclusive of any fees (First money)
   */
  grossAmount?: EntryGrossAmount | null | undefined;
  /**
   * Used to record the payment of interest to accounts that have maintained a cash balance or the charging of interest to accounts that have used margin and details related to the interest
   */
  interest?: Interest | null | undefined;
  /**
   * Used to record the The payment of an obligation an issuer has agreed to make to holders of an interest-bearing security and details related to the interest payment. Usually, the payment is made in cash and on a scheduled basis
   */
  interestPayment?: InterestPayment | null | undefined;
  /**
   * Used to record the dismantling of a business by an issuer, paying off debts in order of priority and distributing the remaining assets in cash and/or securities to the owners of the securities and details related to the liquidation
   */
  liquidation?: Liquidation | null | undefined;
  /**
   * Used to record he final repayment, usually in cash, by an issuer for the entire issue, or remaining outstanding securities of a specific security on a specified date and details related to the maturity
   */
  maturity?: Maturity | null | undefined;
  /**
   * Used to record the exchange of one company's security for another company's security, cash, or a combination of cash and securities and details related to the merger
   */
  merger?: Merger | null | undefined;
  /**
   * accounts/{account_id}/entries/{entry_id}
   */
  name?: string | undefined;
  /**
   * Used to record changes in the name of a security/securities by the issuer which result in surrendering physical securities or the assigning of a new security identifier which result in new securities being issued and details related to the name changes
   */
  nameChange?: NameChange | null | undefined;
  /**
   * The original entry id; stable across reversals and corrections; use for maintaining lineage of entries through multiple corrections/reversals
   */
  originalId?: string | undefined;
  /**
   * The original entry process date; stable across reversals and corrections; use for maintaining lineage of entries through multiple corrections/reversals
   */
  originalProcessDate?: OriginalProcessDate | null | undefined;
  /**
   * Used to record payments on interest-bearing securities where the payment is made in additional securities rather than cash and details related to the payment
   */
  paymentInKind?: PaymentInKind | null | undefined;
  /**
   * The monetary value paid for a given security in a trade Required, except for currency movements
   */
  price?: EntryPrice | null | undefined;
  /**
   * The date that the entry was booked on
   */
  processDate?: EntryProcessDate | null | undefined;
  /**
   * The quantity of shares bought, sold, or moved. For entries/ activities involving Fixed Income assets, quantity is expressed as par value Required for trades and memos, optional for movements.
   */
  quantity?: EntryQuantity | null | undefined;
  /**
   * Object containing metadata for receive events
   */
  receive?: Receive | null | undefined;
  /**
   * Used to record the redemption of a security for cash in its entirety for which the holders receive the principal amount of the security and details related to the redemption
   */
  redemptionFull?: RedemptionFull | null | undefined;
  /**
   * Used when securities are redeemed by the issuer for cash, in part, before their scheduled maturity date and details related to the redemption. The outstanding amount of securities will be proportionally reduced based on a specific percentage of holding
   */
  redemptionPartial?: RedemptionPartial | null | undefined;
  /**
   * Used to record the exchange of a company's security for the same company's new security at a preset rate and details related to the reverse stock split
   */
  reverseStockSplit?: ReverseStockSplit | null | undefined;
  /**
   * The entry_id of the original entry; only populated on entries with a status of "Reversal"
   */
  reversedEntryId?: string | undefined;
  /**
   * Used to record distributions to common stock holders of a company that grant the option to purchase new or additional securities of the same company during a predetermined time period at a predetermined price and details related to the rights distribution
   */
  rightsDistribution?: RightsDistribution | null | undefined;
  /**
   * Used to record the purchase of new or additional securities and details related to the subscription. Rights are often tradable in a secondary market
   */
  rightsSubscription?: RightsSubscription | null | undefined;
  /**
   * Used to record rounding adjustments when the sum(price x quantity) of all entries for a given activity do not equal the price x quantity of the fully formed activity record
   */
  roundingAdjustment?: RoundingAdjustment | null | undefined;
  /**
   * Used to record payments made by the issuer to security holders when the security is subject to redemptions other than full and partial calls (e.g., early CD redemptions) and details related to the sale of rights
   */
  saleOfRights?: SaleOfRights | null | undefined;
  /**
   * The date a given entry/ activity will officially settle
   */
  settleDate?: SettleDate | null | undefined;
  /**
   * Denotes whether the trade is a buy or sell
   */
  side?: EntrySideOpen | undefined;
  /**
   * Indicates whether the trade is opening a new position or closing an existing position Should be populated if possible for trades; the side modifier for the trade
   */
  sideModifier?: EntrySideModifierOpen | undefined;
  /**
   * Used to record a distribution of subsidiary securities to the shareholders of the parent company without a surrender of securities or payment and details related to the spinoff. A spin-off represents a form of divestiture resulting in an independent company
   */
  spinOff?: SpinOff | null | undefined;
  /**
   * Set to be NEW for BookEntries, other statuses will be assigned via ModifyActivities; the state of the entry
   */
  state?: EntryStateOpen | undefined;
  /**
   * Used to record a dividend paid to shareholders in the form of shares of stock in either the issuing company or in another company and details related to the stock dividend
   */
  stockDividend?: StockDividend | null | undefined;
  /**
   * Used to record the increase in a company's number of outstanding shares of stock without any change in the shareholder's equity or the aggregate market value at the time of the split and details related to the stock split
   */
  stockSplit?: StockSplit | null | undefined;
  /**
   * String representation of the metadata object containing more information about an entry/activity
   */
  subtypeCategory?: string | undefined;
  /**
   * Used to record sweeps from a cash balance to an alternative asset or vice versa and details related to the sweep
   */
  sweep?: Sweep | null | undefined;
  /**
   * Used to record the sale of securities for a specified price due to an offer from the issuer or a third party and details related to the tender offer
   */
  tenderOffer?: TenderOffer | null | undefined;
  /**
   * Used to record the the execution of a buy or sell transaction resulting in the transfer of securities and corresponding payment and details related to the trade
   */
  trade?: EntryTrade | null | undefined;
  /**
   * Used to record more generic transfers of funds or securities and details related to the transfer. The transfer type and activity_description can be used to provide more specific context
   */
  transfer?: EntryTransfer | null | undefined;
  /**
   * The Type of the entry; determines the set of mandatory fields as well as informing downstream processes how to handle this record
   */
  type?: EntryTypeOpen | undefined;
  /**
   * Used to record increases in the number of units outstanding through the issuing of more units to current shareholders and details related to the unit split
   */
  unitSplit?: UnitSplit | null | undefined;
  /**
   * Used to record the exchange of warrants for shares and details related to the warrant exercise. The exercise will commonly require a payment based upon a pre-determined value and time and details related to the warrant exercise
   */
  warrantExercise?: WarrantExercise | null | undefined;
  /**
   * Used to record withdrawals of funds from an account and capture details related to the withdrawal
   */
  withdrawal?: Withdrawal | null | undefined;
  /**
   * Used to record the movement of funds to/ from the pending_withdrawal memo location
   */
  withdrawalPendingReview?: WithdrawalPendingReview | null | undefined;
  /**
   * Used to record tax withholdings and details related to the withholding
   */
  withholding?: EntryWithholding | null | undefined;
  /**
   * Used to record the removal of positions in a given security when the DTC has received formal notice that the security is worthless and details related to the worthless event
   */
  worthless?: Worthless | null | undefined;
};

/** @internal */
export const AcatsPendingOut$inboundSchema: z.ZodType<
  AcatsPendingOut,
  z.ZodTypeDef,
  unknown
> = z.object({
  acats_control_number: z.string().optional(),
  additional_instructions: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "acats_control_number": "acatsControlNumber",
    "additional_instructions": "additionalInstructions",
  });
});

/** @internal */
export type AcatsPendingOut$Outbound = {
  acats_control_number?: string | undefined;
  additional_instructions?: string | undefined;
};

/** @internal */
export const AcatsPendingOut$outboundSchema: z.ZodType<
  AcatsPendingOut$Outbound,
  z.ZodTypeDef,
  AcatsPendingOut
> = z.object({
  acatsControlNumber: z.string().optional(),
  additionalInstructions: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    acatsControlNumber: "acats_control_number",
    additionalInstructions: "additional_instructions",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AcatsPendingOut$ {
  /** @deprecated use `AcatsPendingOut$inboundSchema` instead. */
  export const inboundSchema = AcatsPendingOut$inboundSchema;
  /** @deprecated use `AcatsPendingOut$outboundSchema` instead. */
  export const outboundSchema = AcatsPendingOut$outboundSchema;
  /** @deprecated use `AcatsPendingOut$Outbound` instead. */
  export type Outbound = AcatsPendingOut$Outbound;
}

export function acatsPendingOutToJSON(
  acatsPendingOut: AcatsPendingOut,
): string {
  return JSON.stringify(AcatsPendingOut$outboundSchema.parse(acatsPendingOut));
}

export function acatsPendingOutFromJSON(
  jsonString: string,
): SafeParseResult<AcatsPendingOut, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AcatsPendingOut$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AcatsPendingOut' from JSON`,
  );
}

/** @internal */
export const AccountMemo$inboundSchema: z.ZodType<
  AccountMemoOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(AccountMemo),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const AccountMemo$outboundSchema: z.ZodType<
  AccountMemoOpen,
  z.ZodTypeDef,
  AccountMemoOpen
> = z.union([
  z.nativeEnum(AccountMemo),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AccountMemo$ {
  /** @deprecated use `AccountMemo$inboundSchema` instead. */
  export const inboundSchema = AccountMemo$inboundSchema;
  /** @deprecated use `AccountMemo$outboundSchema` instead. */
  export const outboundSchema = AccountMemo$outboundSchema;
}

/** @internal */
export const AccountTransferType$inboundSchema: z.ZodType<
  AccountTransferTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(AccountTransferType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const AccountTransferType$outboundSchema: z.ZodType<
  AccountTransferTypeOpen,
  z.ZodTypeDef,
  AccountTransferTypeOpen
> = z.union([
  z.nativeEnum(AccountTransferType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AccountTransferType$ {
  /** @deprecated use `AccountTransferType$inboundSchema` instead. */
  export const inboundSchema = AccountTransferType$inboundSchema;
  /** @deprecated use `AccountTransferType$outboundSchema` instead. */
  export const outboundSchema = AccountTransferType$outboundSchema;
}

/** @internal */
export const Action$inboundSchema: z.ZodType<
  ActionOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Action),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Action$outboundSchema: z.ZodType<
  ActionOpen,
  z.ZodTypeDef,
  ActionOpen
> = z.union([
  z.nativeEnum(Action),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Action$ {
  /** @deprecated use `Action$inboundSchema` instead. */
  export const inboundSchema = Action$inboundSchema;
  /** @deprecated use `Action$outboundSchema` instead. */
  export const outboundSchema = Action$outboundSchema;
}

/** @internal */
export const Method$inboundSchema: z.ZodType<
  MethodOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Method),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Method$outboundSchema: z.ZodType<
  MethodOpen,
  z.ZodTypeDef,
  MethodOpen
> = z.union([
  z.nativeEnum(Method),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Method$ {
  /** @deprecated use `Method$inboundSchema` instead. */
  export const inboundSchema = Method$inboundSchema;
  /** @deprecated use `Method$outboundSchema` instead. */
  export const outboundSchema = Method$outboundSchema;
}

/** @internal */
export const AccountTransfer$inboundSchema: z.ZodType<
  AccountTransfer,
  z.ZodTypeDef,
  unknown
> = z.object({
  acats_asset_sequence_number: z.string().optional(),
  acats_control_number: z.string().optional(),
  account_transfer_type: AccountTransferType$inboundSchema.optional(),
  action: Action$inboundSchema.optional(),
  additional_instructions: z.string().optional(),
  contra_party_account_number: z.string().optional(),
  contra_party_id: z.string().optional(),
  institution: z.string().optional(),
  method: Method$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "acats_asset_sequence_number": "acatsAssetSequenceNumber",
    "acats_control_number": "acatsControlNumber",
    "account_transfer_type": "accountTransferType",
    "additional_instructions": "additionalInstructions",
    "contra_party_account_number": "contraPartyAccountNumber",
    "contra_party_id": "contraPartyId",
  });
});

/** @internal */
export type AccountTransfer$Outbound = {
  acats_asset_sequence_number?: string | undefined;
  acats_control_number?: string | undefined;
  account_transfer_type?: string | undefined;
  action?: string | undefined;
  additional_instructions?: string | undefined;
  contra_party_account_number?: string | undefined;
  contra_party_id?: string | undefined;
  institution?: string | undefined;
  method?: string | undefined;
};

/** @internal */
export const AccountTransfer$outboundSchema: z.ZodType<
  AccountTransfer$Outbound,
  z.ZodTypeDef,
  AccountTransfer
> = z.object({
  acatsAssetSequenceNumber: z.string().optional(),
  acatsControlNumber: z.string().optional(),
  accountTransferType: AccountTransferType$outboundSchema.optional(),
  action: Action$outboundSchema.optional(),
  additionalInstructions: z.string().optional(),
  contraPartyAccountNumber: z.string().optional(),
  contraPartyId: z.string().optional(),
  institution: z.string().optional(),
  method: Method$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    acatsAssetSequenceNumber: "acats_asset_sequence_number",
    acatsControlNumber: "acats_control_number",
    accountTransferType: "account_transfer_type",
    additionalInstructions: "additional_instructions",
    contraPartyAccountNumber: "contra_party_account_number",
    contraPartyId: "contra_party_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AccountTransfer$ {
  /** @deprecated use `AccountTransfer$inboundSchema` instead. */
  export const inboundSchema = AccountTransfer$inboundSchema;
  /** @deprecated use `AccountTransfer$outboundSchema` instead. */
  export const outboundSchema = AccountTransfer$outboundSchema;
  /** @deprecated use `AccountTransfer$Outbound` instead. */
  export type Outbound = AccountTransfer$Outbound;
}

export function accountTransferToJSON(
  accountTransfer: AccountTransfer,
): string {
  return JSON.stringify(AccountTransfer$outboundSchema.parse(accountTransfer));
}

export function accountTransferFromJSON(
  jsonString: string,
): SafeParseResult<AccountTransfer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AccountTransfer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AccountTransfer' from JSON`,
  );
}

/** @internal */
export const EntryAccruedInterest$inboundSchema: z.ZodType<
  EntryAccruedInterest,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type EntryAccruedInterest$Outbound = {};

/** @internal */
export const EntryAccruedInterest$outboundSchema: z.ZodType<
  EntryAccruedInterest$Outbound,
  z.ZodTypeDef,
  EntryAccruedInterest
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryAccruedInterest$ {
  /** @deprecated use `EntryAccruedInterest$inboundSchema` instead. */
  export const inboundSchema = EntryAccruedInterest$inboundSchema;
  /** @deprecated use `EntryAccruedInterest$outboundSchema` instead. */
  export const outboundSchema = EntryAccruedInterest$outboundSchema;
  /** @deprecated use `EntryAccruedInterest$Outbound` instead. */
  export type Outbound = EntryAccruedInterest$Outbound;
}

export function entryAccruedInterestToJSON(
  entryAccruedInterest: EntryAccruedInterest,
): string {
  return JSON.stringify(
    EntryAccruedInterest$outboundSchema.parse(entryAccruedInterest),
  );
}

export function entryAccruedInterestFromJSON(
  jsonString: string,
): SafeParseResult<EntryAccruedInterest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryAccruedInterest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryAccruedInterest' from JSON`,
  );
}

/** @internal */
export const CorporateActionGeneralInformation$inboundSchema: z.ZodType<
  CorporateActionGeneralInformation,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_id: z.string().optional(),
  disbursed_asset_id: z.string().optional(),
  disbursed_cusip: z.string().optional(),
  disbursed_symbol_description: z.string().optional(),
  target_asset_id: z.string().optional(),
  target_cusip: z.string().optional(),
  target_symbol_description: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_id": "corporateActionId",
    "disbursed_asset_id": "disbursedAssetId",
    "disbursed_cusip": "disbursedCusip",
    "disbursed_symbol_description": "disbursedSymbolDescription",
    "target_asset_id": "targetAssetId",
    "target_cusip": "targetCusip",
    "target_symbol_description": "targetSymbolDescription",
  });
});

/** @internal */
export type CorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const CorporateActionGeneralInformation$outboundSchema: z.ZodType<
  CorporateActionGeneralInformation$Outbound,
  z.ZodTypeDef,
  CorporateActionGeneralInformation
> = z.object({
  corporateActionId: z.string().optional(),
  disbursedAssetId: z.string().optional(),
  disbursedCusip: z.string().optional(),
  disbursedSymbolDescription: z.string().optional(),
  targetAssetId: z.string().optional(),
  targetCusip: z.string().optional(),
  targetSymbolDescription: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionId: "corporate_action_id",
    disbursedAssetId: "disbursed_asset_id",
    disbursedCusip: "disbursed_cusip",
    disbursedSymbolDescription: "disbursed_symbol_description",
    targetAssetId: "target_asset_id",
    targetCusip: "target_cusip",
    targetSymbolDescription: "target_symbol_description",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorporateActionGeneralInformation$ {
  /** @deprecated use `CorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema = CorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `CorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    CorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `CorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound = CorporateActionGeneralInformation$Outbound;
}

export function corporateActionGeneralInformationToJSON(
  corporateActionGeneralInformation: CorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    CorporateActionGeneralInformation$outboundSchema.parse(
      corporateActionGeneralInformation,
    ),
  );
}

export function corporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<CorporateActionGeneralInformation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CorporateActionGeneralInformation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const Acquisition$inboundSchema: z.ZodType<
  Acquisition,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_general_information: z.nullable(
    z.lazy(() => CorporateActionGeneralInformation$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
  });
});

/** @internal */
export type Acquisition$Outbound = {
  corporate_action_general_information?:
    | CorporateActionGeneralInformation$Outbound
    | null
    | undefined;
};

/** @internal */
export const Acquisition$outboundSchema: z.ZodType<
  Acquisition$Outbound,
  z.ZodTypeDef,
  Acquisition
> = z.object({
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() => CorporateActionGeneralInformation$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Acquisition$ {
  /** @deprecated use `Acquisition$inboundSchema` instead. */
  export const inboundSchema = Acquisition$inboundSchema;
  /** @deprecated use `Acquisition$outboundSchema` instead. */
  export const outboundSchema = Acquisition$outboundSchema;
  /** @deprecated use `Acquisition$Outbound` instead. */
  export type Outbound = Acquisition$Outbound;
}

export function acquisitionToJSON(acquisition: Acquisition): string {
  return JSON.stringify(Acquisition$outboundSchema.parse(acquisition));
}

export function acquisitionFromJSON(
  jsonString: string,
): SafeParseResult<Acquisition, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Acquisition$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Acquisition' from JSON`,
  );
}

/** @internal */
export const ActivityDate$inboundSchema: z.ZodType<
  ActivityDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type ActivityDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const ActivityDate$outboundSchema: z.ZodType<
  ActivityDate$Outbound,
  z.ZodTypeDef,
  ActivityDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityDate$ {
  /** @deprecated use `ActivityDate$inboundSchema` instead. */
  export const inboundSchema = ActivityDate$inboundSchema;
  /** @deprecated use `ActivityDate$outboundSchema` instead. */
  export const outboundSchema = ActivityDate$outboundSchema;
  /** @deprecated use `ActivityDate$Outbound` instead. */
  export type Outbound = ActivityDate$Outbound;
}

export function activityDateToJSON(activityDate: ActivityDate): string {
  return JSON.stringify(ActivityDate$outboundSchema.parse(activityDate));
}

export function activityDateFromJSON(
  jsonString: string,
): SafeParseResult<ActivityDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityDate' from JSON`,
  );
}

/** @internal */
export const EntryBrokerCapacity$inboundSchema: z.ZodType<
  EntryBrokerCapacityOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryBrokerCapacity),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryBrokerCapacity$outboundSchema: z.ZodType<
  EntryBrokerCapacityOpen,
  z.ZodTypeDef,
  EntryBrokerCapacityOpen
> = z.union([
  z.nativeEnum(EntryBrokerCapacity),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryBrokerCapacity$ {
  /** @deprecated use `EntryBrokerCapacity$inboundSchema` instead. */
  export const inboundSchema = EntryBrokerCapacity$inboundSchema;
  /** @deprecated use `EntryBrokerCapacity$outboundSchema` instead. */
  export const outboundSchema = EntryBrokerCapacity$outboundSchema;
}

/** @internal */
export const EntryPrevailingMarketPrice$inboundSchema: z.ZodType<
  EntryPrevailingMarketPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryPrevailingMarketPrice$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryPrevailingMarketPrice$outboundSchema: z.ZodType<
  EntryPrevailingMarketPrice$Outbound,
  z.ZodTypeDef,
  EntryPrevailingMarketPrice
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPrevailingMarketPrice$ {
  /** @deprecated use `EntryPrevailingMarketPrice$inboundSchema` instead. */
  export const inboundSchema = EntryPrevailingMarketPrice$inboundSchema;
  /** @deprecated use `EntryPrevailingMarketPrice$outboundSchema` instead. */
  export const outboundSchema = EntryPrevailingMarketPrice$outboundSchema;
  /** @deprecated use `EntryPrevailingMarketPrice$Outbound` instead. */
  export type Outbound = EntryPrevailingMarketPrice$Outbound;
}

export function entryPrevailingMarketPriceToJSON(
  entryPrevailingMarketPrice: EntryPrevailingMarketPrice,
): string {
  return JSON.stringify(
    EntryPrevailingMarketPrice$outboundSchema.parse(entryPrevailingMarketPrice),
  );
}

export function entryPrevailingMarketPriceFromJSON(
  jsonString: string,
): SafeParseResult<EntryPrevailingMarketPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryPrevailingMarketPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryPrevailingMarketPrice' from JSON`,
  );
}

/** @internal */
export const EntryPriceAdjustmentAmount$inboundSchema: z.ZodType<
  EntryPriceAdjustmentAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryPriceAdjustmentAmount$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryPriceAdjustmentAmount$outboundSchema: z.ZodType<
  EntryPriceAdjustmentAmount$Outbound,
  z.ZodTypeDef,
  EntryPriceAdjustmentAmount
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPriceAdjustmentAmount$ {
  /** @deprecated use `EntryPriceAdjustmentAmount$inboundSchema` instead. */
  export const inboundSchema = EntryPriceAdjustmentAmount$inboundSchema;
  /** @deprecated use `EntryPriceAdjustmentAmount$outboundSchema` instead. */
  export const outboundSchema = EntryPriceAdjustmentAmount$outboundSchema;
  /** @deprecated use `EntryPriceAdjustmentAmount$Outbound` instead. */
  export type Outbound = EntryPriceAdjustmentAmount$Outbound;
}

export function entryPriceAdjustmentAmountToJSON(
  entryPriceAdjustmentAmount: EntryPriceAdjustmentAmount,
): string {
  return JSON.stringify(
    EntryPriceAdjustmentAmount$outboundSchema.parse(entryPriceAdjustmentAmount),
  );
}

export function entryPriceAdjustmentAmountFromJSON(
  jsonString: string,
): SafeParseResult<EntryPriceAdjustmentAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryPriceAdjustmentAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryPriceAdjustmentAmount' from JSON`,
  );
}

/** @internal */
export const PriceAdjustmentPercent$inboundSchema: z.ZodType<
  PriceAdjustmentPercent,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PriceAdjustmentPercent$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PriceAdjustmentPercent$outboundSchema: z.ZodType<
  PriceAdjustmentPercent$Outbound,
  z.ZodTypeDef,
  PriceAdjustmentPercent
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PriceAdjustmentPercent$ {
  /** @deprecated use `PriceAdjustmentPercent$inboundSchema` instead. */
  export const inboundSchema = PriceAdjustmentPercent$inboundSchema;
  /** @deprecated use `PriceAdjustmentPercent$outboundSchema` instead. */
  export const outboundSchema = PriceAdjustmentPercent$outboundSchema;
  /** @deprecated use `PriceAdjustmentPercent$Outbound` instead. */
  export type Outbound = PriceAdjustmentPercent$Outbound;
}

export function priceAdjustmentPercentToJSON(
  priceAdjustmentPercent: PriceAdjustmentPercent,
): string {
  return JSON.stringify(
    PriceAdjustmentPercent$outboundSchema.parse(priceAdjustmentPercent),
  );
}

export function priceAdjustmentPercentFromJSON(
  jsonString: string,
): SafeParseResult<PriceAdjustmentPercent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PriceAdjustmentPercent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PriceAdjustmentPercent' from JSON`,
  );
}

/** @internal */
export const EntryPriceAdjustmentType$inboundSchema: z.ZodType<
  EntryPriceAdjustmentTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryPriceAdjustmentType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryPriceAdjustmentType$outboundSchema: z.ZodType<
  EntryPriceAdjustmentTypeOpen,
  z.ZodTypeDef,
  EntryPriceAdjustmentTypeOpen
> = z.union([
  z.nativeEnum(EntryPriceAdjustmentType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPriceAdjustmentType$ {
  /** @deprecated use `EntryPriceAdjustmentType$inboundSchema` instead. */
  export const inboundSchema = EntryPriceAdjustmentType$inboundSchema;
  /** @deprecated use `EntryPriceAdjustmentType$outboundSchema` instead. */
  export const outboundSchema = EntryPriceAdjustmentType$outboundSchema;
}

/** @internal */
export const PriceAdjustmentRecord$inboundSchema: z.ZodType<
  PriceAdjustmentRecord,
  z.ZodTypeDef,
  unknown
> = z.object({
  price_adjustment_amount: z.nullable(
    z.lazy(() => EntryPriceAdjustmentAmount$inboundSchema),
  ).optional(),
  price_adjustment_percent: z.nullable(
    z.lazy(() => PriceAdjustmentPercent$inboundSchema),
  ).optional(),
  price_adjustment_type: EntryPriceAdjustmentType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "price_adjustment_amount": "priceAdjustmentAmount",
    "price_adjustment_percent": "priceAdjustmentPercent",
    "price_adjustment_type": "priceAdjustmentType",
  });
});

/** @internal */
export type PriceAdjustmentRecord$Outbound = {
  price_adjustment_amount?:
    | EntryPriceAdjustmentAmount$Outbound
    | null
    | undefined;
  price_adjustment_percent?: PriceAdjustmentPercent$Outbound | null | undefined;
  price_adjustment_type?: string | undefined;
};

/** @internal */
export const PriceAdjustmentRecord$outboundSchema: z.ZodType<
  PriceAdjustmentRecord$Outbound,
  z.ZodTypeDef,
  PriceAdjustmentRecord
> = z.object({
  priceAdjustmentAmount: z.nullable(
    z.lazy(() => EntryPriceAdjustmentAmount$outboundSchema),
  ).optional(),
  priceAdjustmentPercent: z.nullable(
    z.lazy(() => PriceAdjustmentPercent$outboundSchema),
  ).optional(),
  priceAdjustmentType: EntryPriceAdjustmentType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    priceAdjustmentAmount: "price_adjustment_amount",
    priceAdjustmentPercent: "price_adjustment_percent",
    priceAdjustmentType: "price_adjustment_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PriceAdjustmentRecord$ {
  /** @deprecated use `PriceAdjustmentRecord$inboundSchema` instead. */
  export const inboundSchema = PriceAdjustmentRecord$inboundSchema;
  /** @deprecated use `PriceAdjustmentRecord$outboundSchema` instead. */
  export const outboundSchema = PriceAdjustmentRecord$outboundSchema;
  /** @deprecated use `PriceAdjustmentRecord$Outbound` instead. */
  export type Outbound = PriceAdjustmentRecord$Outbound;
}

export function priceAdjustmentRecordToJSON(
  priceAdjustmentRecord: PriceAdjustmentRecord,
): string {
  return JSON.stringify(
    PriceAdjustmentRecord$outboundSchema.parse(priceAdjustmentRecord),
  );
}

export function priceAdjustmentRecordFromJSON(
  jsonString: string,
): SafeParseResult<PriceAdjustmentRecord, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PriceAdjustmentRecord$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PriceAdjustmentRecord' from JSON`,
  );
}

/** @internal */
export const Allocation$inboundSchema: z.ZodType<
  Allocation,
  z.ZodTypeDef,
  unknown
> = z.object({
  additional_instructions: z.array(z.string()).optional(),
  booking_api_trade_allocation_id: z.string().optional(),
  broker_capacity: EntryBrokerCapacity$inboundSchema.optional(),
  client_memo: z.string().optional(),
  client_order_id: z.string().optional(),
  external_id: z.string().optional(),
  gateway_client_order_id: z.string().optional(),
  internal_error: z.boolean().optional(),
  lots: z.array(Lot$inboundSchema).optional(),
  prevailing_market_price: z.nullable(
    z.lazy(() => EntryPrevailingMarketPrice$inboundSchema),
  ).optional(),
  price_adjustment_record: z.nullable(
    z.lazy(() => PriceAdjustmentRecord$inboundSchema),
  ).optional(),
  special_instructions: z.array(z.string()).optional(),
  yield_records: z.array(YieldRecord$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "additional_instructions": "additionalInstructions",
    "booking_api_trade_allocation_id": "bookingApiTradeAllocationId",
    "broker_capacity": "brokerCapacity",
    "client_memo": "clientMemo",
    "client_order_id": "clientOrderId",
    "external_id": "externalId",
    "gateway_client_order_id": "gatewayClientOrderId",
    "internal_error": "internalError",
    "prevailing_market_price": "prevailingMarketPrice",
    "price_adjustment_record": "priceAdjustmentRecord",
    "special_instructions": "specialInstructions",
    "yield_records": "yieldRecords",
  });
});

/** @internal */
export type Allocation$Outbound = {
  additional_instructions?: Array<string> | undefined;
  booking_api_trade_allocation_id?: string | undefined;
  broker_capacity?: string | undefined;
  client_memo?: string | undefined;
  client_order_id?: string | undefined;
  external_id?: string | undefined;
  gateway_client_order_id?: string | undefined;
  internal_error?: boolean | undefined;
  lots?: Array<Lot$Outbound> | undefined;
  prevailing_market_price?:
    | EntryPrevailingMarketPrice$Outbound
    | null
    | undefined;
  price_adjustment_record?: PriceAdjustmentRecord$Outbound | null | undefined;
  special_instructions?: Array<string> | undefined;
  yield_records?: Array<YieldRecord$Outbound> | undefined;
};

/** @internal */
export const Allocation$outboundSchema: z.ZodType<
  Allocation$Outbound,
  z.ZodTypeDef,
  Allocation
> = z.object({
  additionalInstructions: z.array(z.string()).optional(),
  bookingApiTradeAllocationId: z.string().optional(),
  brokerCapacity: EntryBrokerCapacity$outboundSchema.optional(),
  clientMemo: z.string().optional(),
  clientOrderId: z.string().optional(),
  externalId: z.string().optional(),
  gatewayClientOrderId: z.string().optional(),
  internalError: z.boolean().optional(),
  lots: z.array(Lot$outboundSchema).optional(),
  prevailingMarketPrice: z.nullable(
    z.lazy(() => EntryPrevailingMarketPrice$outboundSchema),
  ).optional(),
  priceAdjustmentRecord: z.nullable(
    z.lazy(() => PriceAdjustmentRecord$outboundSchema),
  ).optional(),
  specialInstructions: z.array(z.string()).optional(),
  yieldRecords: z.array(YieldRecord$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    additionalInstructions: "additional_instructions",
    bookingApiTradeAllocationId: "booking_api_trade_allocation_id",
    brokerCapacity: "broker_capacity",
    clientMemo: "client_memo",
    clientOrderId: "client_order_id",
    externalId: "external_id",
    gatewayClientOrderId: "gateway_client_order_id",
    internalError: "internal_error",
    prevailingMarketPrice: "prevailing_market_price",
    priceAdjustmentRecord: "price_adjustment_record",
    specialInstructions: "special_instructions",
    yieldRecords: "yield_records",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Allocation$ {
  /** @deprecated use `Allocation$inboundSchema` instead. */
  export const inboundSchema = Allocation$inboundSchema;
  /** @deprecated use `Allocation$outboundSchema` instead. */
  export const outboundSchema = Allocation$outboundSchema;
  /** @deprecated use `Allocation$Outbound` instead. */
  export type Outbound = Allocation$Outbound;
}

export function allocationToJSON(allocation: Allocation): string {
  return JSON.stringify(Allocation$outboundSchema.parse(allocation));
}

export function allocationFromJSON(
  jsonString: string,
): SafeParseResult<Allocation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Allocation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Allocation' from JSON`,
  );
}

/** @internal */
export const CashRate$inboundSchema: z.ZodType<
  CashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type CashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const CashRate$outboundSchema: z.ZodType<
  CashRate$Outbound,
  z.ZodTypeDef,
  CashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CashRate$ {
  /** @deprecated use `CashRate$inboundSchema` instead. */
  export const inboundSchema = CashRate$inboundSchema;
  /** @deprecated use `CashRate$outboundSchema` instead. */
  export const outboundSchema = CashRate$outboundSchema;
  /** @deprecated use `CashRate$Outbound` instead. */
  export type Outbound = CashRate$Outbound;
}

export function cashRateToJSON(cashRate: CashRate): string {
  return JSON.stringify(CashRate$outboundSchema.parse(cashRate));
}

export function cashRateFromJSON(
  jsonString: string,
): SafeParseResult<CashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CashRate' from JSON`,
  );
}

/** @internal */
export const EntryCorporateActionGeneralInformation$inboundSchema: z.ZodType<
  EntryCorporateActionGeneralInformation,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_id: z.string().optional(),
  disbursed_asset_id: z.string().optional(),
  disbursed_cusip: z.string().optional(),
  disbursed_symbol_description: z.string().optional(),
  target_asset_id: z.string().optional(),
  target_cusip: z.string().optional(),
  target_symbol_description: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_id": "corporateActionId",
    "disbursed_asset_id": "disbursedAssetId",
    "disbursed_cusip": "disbursedCusip",
    "disbursed_symbol_description": "disbursedSymbolDescription",
    "target_asset_id": "targetAssetId",
    "target_cusip": "targetCusip",
    "target_symbol_description": "targetSymbolDescription",
  });
});

/** @internal */
export type EntryCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryCorporateActionGeneralInformation$outboundSchema: z.ZodType<
  EntryCorporateActionGeneralInformation$Outbound,
  z.ZodTypeDef,
  EntryCorporateActionGeneralInformation
> = z.object({
  corporateActionId: z.string().optional(),
  disbursedAssetId: z.string().optional(),
  disbursedCusip: z.string().optional(),
  disbursedSymbolDescription: z.string().optional(),
  targetAssetId: z.string().optional(),
  targetCusip: z.string().optional(),
  targetSymbolDescription: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionId: "corporate_action_id",
    disbursedAssetId: "disbursed_asset_id",
    disbursedCusip: "disbursed_cusip",
    disbursedSymbolDescription: "disbursed_symbol_description",
    targetAssetId: "target_asset_id",
    targetCusip: "target_cusip",
    targetSymbolDescription: "target_symbol_description",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound = EntryCorporateActionGeneralInformation$Outbound;
}

export function entryCorporateActionGeneralInformationToJSON(
  entryCorporateActionGeneralInformation:
    EntryCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryCorporateActionGeneralInformation$outboundSchema.parse(
      entryCorporateActionGeneralInformation,
    ),
  );
}

export function entryCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<EntryCorporateActionGeneralInformation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      EntryCorporateActionGeneralInformation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const PaymentDate$inboundSchema: z.ZodType<
  PaymentDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type PaymentDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const PaymentDate$outboundSchema: z.ZodType<
  PaymentDate$Outbound,
  z.ZodTypeDef,
  PaymentDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentDate$ {
  /** @deprecated use `PaymentDate$inboundSchema` instead. */
  export const inboundSchema = PaymentDate$inboundSchema;
  /** @deprecated use `PaymentDate$outboundSchema` instead. */
  export const outboundSchema = PaymentDate$outboundSchema;
  /** @deprecated use `PaymentDate$Outbound` instead. */
  export type Outbound = PaymentDate$Outbound;
}

export function paymentDateToJSON(paymentDate: PaymentDate): string {
  return JSON.stringify(PaymentDate$outboundSchema.parse(paymentDate));
}

export function paymentDateFromJSON(
  jsonString: string,
): SafeParseResult<PaymentDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentDate' from JSON`,
  );
}

/** @internal */
export const EntryBondDefaultQuantity$inboundSchema: z.ZodType<
  EntryBondDefaultQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryBondDefaultQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryBondDefaultQuantity$outboundSchema: z.ZodType<
  EntryBondDefaultQuantity$Outbound,
  z.ZodTypeDef,
  EntryBondDefaultQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryBondDefaultQuantity$ {
  /** @deprecated use `EntryBondDefaultQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryBondDefaultQuantity$inboundSchema;
  /** @deprecated use `EntryBondDefaultQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryBondDefaultQuantity$outboundSchema;
  /** @deprecated use `EntryBondDefaultQuantity$Outbound` instead. */
  export type Outbound = EntryBondDefaultQuantity$Outbound;
}

export function entryBondDefaultQuantityToJSON(
  entryBondDefaultQuantity: EntryBondDefaultQuantity,
): string {
  return JSON.stringify(
    EntryBondDefaultQuantity$outboundSchema.parse(entryBondDefaultQuantity),
  );
}

export function entryBondDefaultQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryBondDefaultQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryBondDefaultQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryBondDefaultQuantity' from JSON`,
  );
}

/** @internal */
export const BondDefault$inboundSchema: z.ZodType<
  BondDefault,
  z.ZodTypeDef,
  unknown
> = z.object({
  cash_rate: z.nullable(z.lazy(() => CashRate$inboundSchema)).optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() => EntryCorporateActionGeneralInformation$inboundSchema),
  ).optional(),
  payment_date: z.nullable(z.lazy(() => PaymentDate$inboundSchema)).optional(),
  quantity: z.nullable(z.lazy(() => EntryBondDefaultQuantity$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "cash_rate": "cashRate",
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "payment_date": "paymentDate",
  });
});

/** @internal */
export type BondDefault$Outbound = {
  cash_rate?: CashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntryCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  payment_date?: PaymentDate$Outbound | null | undefined;
  quantity?: EntryBondDefaultQuantity$Outbound | null | undefined;
};

/** @internal */
export const BondDefault$outboundSchema: z.ZodType<
  BondDefault$Outbound,
  z.ZodTypeDef,
  BondDefault
> = z.object({
  cashRate: z.nullable(z.lazy(() => CashRate$outboundSchema)).optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() => EntryCorporateActionGeneralInformation$outboundSchema),
  ).optional(),
  paymentDate: z.nullable(z.lazy(() => PaymentDate$outboundSchema)).optional(),
  quantity: z.nullable(z.lazy(() => EntryBondDefaultQuantity$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    paymentDate: "payment_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BondDefault$ {
  /** @deprecated use `BondDefault$inboundSchema` instead. */
  export const inboundSchema = BondDefault$inboundSchema;
  /** @deprecated use `BondDefault$outboundSchema` instead. */
  export const outboundSchema = BondDefault$outboundSchema;
  /** @deprecated use `BondDefault$Outbound` instead. */
  export type Outbound = BondDefault$Outbound;
}

export function bondDefaultToJSON(bondDefault: BondDefault): string {
  return JSON.stringify(BondDefault$outboundSchema.parse(bondDefault));
}

export function bondDefaultFromJSON(
  jsonString: string,
): SafeParseResult<BondDefault, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BondDefault$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BondDefault' from JSON`,
  );
}

/** @internal */
export const EntryCashRate$inboundSchema: z.ZodType<
  EntryCashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryCashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryCashRate$outboundSchema: z.ZodType<
  EntryCashRate$Outbound,
  z.ZodTypeDef,
  EntryCashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryCashRate$ {
  /** @deprecated use `EntryCashRate$inboundSchema` instead. */
  export const inboundSchema = EntryCashRate$inboundSchema;
  /** @deprecated use `EntryCashRate$outboundSchema` instead. */
  export const outboundSchema = EntryCashRate$outboundSchema;
  /** @deprecated use `EntryCashRate$Outbound` instead. */
  export type Outbound = EntryCashRate$Outbound;
}

export function entryCashRateToJSON(entryCashRate: EntryCashRate): string {
  return JSON.stringify(EntryCashRate$outboundSchema.parse(entryCashRate));
}

export function entryCashRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryCashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryCashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryCashRate' from JSON`,
  );
}

/** @internal */
export const EntryCapitalGainsCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryCapitalGainsCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryCapitalGainsCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryCapitalGainsCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryCapitalGainsCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryCapitalGainsCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryCapitalGainsCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryCapitalGainsCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryCapitalGainsCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryCapitalGainsCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryCapitalGainsCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryCapitalGainsCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryCapitalGainsCorporateActionGeneralInformation$Outbound;
}

export function entryCapitalGainsCorporateActionGeneralInformationToJSON(
  entryCapitalGainsCorporateActionGeneralInformation:
    EntryCapitalGainsCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryCapitalGainsCorporateActionGeneralInformation$outboundSchema.parse(
      entryCapitalGainsCorporateActionGeneralInformation,
    ),
  );
}

export function entryCapitalGainsCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryCapitalGainsCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryCapitalGainsCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryCapitalGainsCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryPaymentDate$inboundSchema: z.ZodType<
  EntryPaymentDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryPaymentDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryPaymentDate$outboundSchema: z.ZodType<
  EntryPaymentDate$Outbound,
  z.ZodTypeDef,
  EntryPaymentDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPaymentDate$ {
  /** @deprecated use `EntryPaymentDate$inboundSchema` instead. */
  export const inboundSchema = EntryPaymentDate$inboundSchema;
  /** @deprecated use `EntryPaymentDate$outboundSchema` instead. */
  export const outboundSchema = EntryPaymentDate$outboundSchema;
  /** @deprecated use `EntryPaymentDate$Outbound` instead. */
  export type Outbound = EntryPaymentDate$Outbound;
}

export function entryPaymentDateToJSON(
  entryPaymentDate: EntryPaymentDate,
): string {
  return JSON.stringify(
    EntryPaymentDate$outboundSchema.parse(entryPaymentDate),
  );
}

export function entryPaymentDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryPaymentDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryPaymentDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryPaymentDate' from JSON`,
  );
}

/** @internal */
export const EntryCapitalGainsQuantity$inboundSchema: z.ZodType<
  EntryCapitalGainsQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryCapitalGainsQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryCapitalGainsQuantity$outboundSchema: z.ZodType<
  EntryCapitalGainsQuantity$Outbound,
  z.ZodTypeDef,
  EntryCapitalGainsQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryCapitalGainsQuantity$ {
  /** @deprecated use `EntryCapitalGainsQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryCapitalGainsQuantity$inboundSchema;
  /** @deprecated use `EntryCapitalGainsQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryCapitalGainsQuantity$outboundSchema;
  /** @deprecated use `EntryCapitalGainsQuantity$Outbound` instead. */
  export type Outbound = EntryCapitalGainsQuantity$Outbound;
}

export function entryCapitalGainsQuantityToJSON(
  entryCapitalGainsQuantity: EntryCapitalGainsQuantity,
): string {
  return JSON.stringify(
    EntryCapitalGainsQuantity$outboundSchema.parse(entryCapitalGainsQuantity),
  );
}

export function entryCapitalGainsQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryCapitalGainsQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryCapitalGainsQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryCapitalGainsQuantity' from JSON`,
  );
}

/** @internal */
export const RecordDate$inboundSchema: z.ZodType<
  RecordDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type RecordDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const RecordDate$outboundSchema: z.ZodType<
  RecordDate$Outbound,
  z.ZodTypeDef,
  RecordDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecordDate$ {
  /** @deprecated use `RecordDate$inboundSchema` instead. */
  export const inboundSchema = RecordDate$inboundSchema;
  /** @deprecated use `RecordDate$outboundSchema` instead. */
  export const outboundSchema = RecordDate$outboundSchema;
  /** @deprecated use `RecordDate$Outbound` instead. */
  export type Outbound = RecordDate$Outbound;
}

export function recordDateToJSON(recordDate: RecordDate): string {
  return JSON.stringify(RecordDate$outboundSchema.parse(recordDate));
}

export function recordDateFromJSON(
  jsonString: string,
): SafeParseResult<RecordDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RecordDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RecordDate' from JSON`,
  );
}

/** @internal */
export const CapitalGains$inboundSchema: z.ZodType<
  CapitalGains,
  z.ZodTypeDef,
  unknown
> = z.object({
  cash_rate: z.nullable(z.lazy(() => EntryCashRate$inboundSchema)).optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryCapitalGainsCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  long_term_gain: z.boolean().optional(),
  payment_date: z.nullable(z.lazy(() => EntryPaymentDate$inboundSchema))
    .optional(),
  qualified: z.boolean().optional(),
  quantity: z.nullable(z.lazy(() => EntryCapitalGainsQuantity$inboundSchema))
    .optional(),
  record_date: z.nullable(z.lazy(() => RecordDate$inboundSchema)).optional(),
  reinvested: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "cash_rate": "cashRate",
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "long_term_gain": "longTermGain",
    "payment_date": "paymentDate",
    "record_date": "recordDate",
  });
});

/** @internal */
export type CapitalGains$Outbound = {
  cash_rate?: EntryCashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntryCapitalGainsCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  long_term_gain?: boolean | undefined;
  payment_date?: EntryPaymentDate$Outbound | null | undefined;
  qualified?: boolean | undefined;
  quantity?: EntryCapitalGainsQuantity$Outbound | null | undefined;
  record_date?: RecordDate$Outbound | null | undefined;
  reinvested?: boolean | undefined;
};

/** @internal */
export const CapitalGains$outboundSchema: z.ZodType<
  CapitalGains$Outbound,
  z.ZodTypeDef,
  CapitalGains
> = z.object({
  cashRate: z.nullable(z.lazy(() => EntryCashRate$outboundSchema)).optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryCapitalGainsCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  longTermGain: z.boolean().optional(),
  paymentDate: z.nullable(z.lazy(() => EntryPaymentDate$outboundSchema))
    .optional(),
  qualified: z.boolean().optional(),
  quantity: z.nullable(z.lazy(() => EntryCapitalGainsQuantity$outboundSchema))
    .optional(),
  recordDate: z.nullable(z.lazy(() => RecordDate$outboundSchema)).optional(),
  reinvested: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    longTermGain: "long_term_gain",
    paymentDate: "payment_date",
    recordDate: "record_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CapitalGains$ {
  /** @deprecated use `CapitalGains$inboundSchema` instead. */
  export const inboundSchema = CapitalGains$inboundSchema;
  /** @deprecated use `CapitalGains$outboundSchema` instead. */
  export const outboundSchema = CapitalGains$outboundSchema;
  /** @deprecated use `CapitalGains$Outbound` instead. */
  export type Outbound = CapitalGains$Outbound;
}

export function capitalGainsToJSON(capitalGains: CapitalGains): string {
  return JSON.stringify(CapitalGains$outboundSchema.parse(capitalGains));
}

export function capitalGainsFromJSON(
  jsonString: string,
): SafeParseResult<CapitalGains, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CapitalGains$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CapitalGains' from JSON`,
  );
}

/** @internal */
export const EntryCashDividendCashRate$inboundSchema: z.ZodType<
  EntryCashDividendCashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryCashDividendCashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryCashDividendCashRate$outboundSchema: z.ZodType<
  EntryCashDividendCashRate$Outbound,
  z.ZodTypeDef,
  EntryCashDividendCashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryCashDividendCashRate$ {
  /** @deprecated use `EntryCashDividendCashRate$inboundSchema` instead. */
  export const inboundSchema = EntryCashDividendCashRate$inboundSchema;
  /** @deprecated use `EntryCashDividendCashRate$outboundSchema` instead. */
  export const outboundSchema = EntryCashDividendCashRate$outboundSchema;
  /** @deprecated use `EntryCashDividendCashRate$Outbound` instead. */
  export type Outbound = EntryCashDividendCashRate$Outbound;
}

export function entryCashDividendCashRateToJSON(
  entryCashDividendCashRate: EntryCashDividendCashRate,
): string {
  return JSON.stringify(
    EntryCashDividendCashRate$outboundSchema.parse(entryCashDividendCashRate),
  );
}

export function entryCashDividendCashRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryCashDividendCashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryCashDividendCashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryCashDividendCashRate' from JSON`,
  );
}

/** @internal */
export const EntryCashDividendCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryCashDividendCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryCashDividendCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryCashDividendCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryCashDividendCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryCashDividendCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryCashDividendCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryCashDividendCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryCashDividendCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryCashDividendCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryCashDividendCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryCashDividendCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryCashDividendCorporateActionGeneralInformation$Outbound;
}

export function entryCashDividendCorporateActionGeneralInformationToJSON(
  entryCashDividendCorporateActionGeneralInformation:
    EntryCashDividendCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryCashDividendCorporateActionGeneralInformation$outboundSchema.parse(
      entryCashDividendCorporateActionGeneralInformation,
    ),
  );
}

export function entryCashDividendCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryCashDividendCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryCashDividendCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryCashDividendCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryFpsl$inboundSchema: z.ZodType<
  EntryFpsl,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryFpsl$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryFpsl$outboundSchema: z.ZodType<
  EntryFpsl$Outbound,
  z.ZodTypeDef,
  EntryFpsl
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFpsl$ {
  /** @deprecated use `EntryFpsl$inboundSchema` instead. */
  export const inboundSchema = EntryFpsl$inboundSchema;
  /** @deprecated use `EntryFpsl$outboundSchema` instead. */
  export const outboundSchema = EntryFpsl$outboundSchema;
  /** @deprecated use `EntryFpsl$Outbound` instead. */
  export type Outbound = EntryFpsl$Outbound;
}

export function entryFpslToJSON(entryFpsl: EntryFpsl): string {
  return JSON.stringify(EntryFpsl$outboundSchema.parse(entryFpsl));
}

export function entryFpslFromJSON(
  jsonString: string,
): SafeParseResult<EntryFpsl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryFpsl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryFpsl' from JSON`,
  );
}

/** @internal */
export const EntryFree$inboundSchema: z.ZodType<
  EntryFree,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryFree$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryFree$outboundSchema: z.ZodType<
  EntryFree$Outbound,
  z.ZodTypeDef,
  EntryFree
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFree$ {
  /** @deprecated use `EntryFree$inboundSchema` instead. */
  export const inboundSchema = EntryFree$inboundSchema;
  /** @deprecated use `EntryFree$outboundSchema` instead. */
  export const outboundSchema = EntryFree$outboundSchema;
  /** @deprecated use `EntryFree$Outbound` instead. */
  export type Outbound = EntryFree$Outbound;
}

export function entryFreeToJSON(entryFree: EntryFree): string {
  return JSON.stringify(EntryFree$outboundSchema.parse(entryFree));
}

export function entryFreeFromJSON(
  jsonString: string,
): SafeParseResult<EntryFree, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryFree$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryFree' from JSON`,
  );
}

/** @internal */
export const EntryCashDividendPaymentDate$inboundSchema: z.ZodType<
  EntryCashDividendPaymentDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryCashDividendPaymentDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryCashDividendPaymentDate$outboundSchema: z.ZodType<
  EntryCashDividendPaymentDate$Outbound,
  z.ZodTypeDef,
  EntryCashDividendPaymentDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryCashDividendPaymentDate$ {
  /** @deprecated use `EntryCashDividendPaymentDate$inboundSchema` instead. */
  export const inboundSchema = EntryCashDividendPaymentDate$inboundSchema;
  /** @deprecated use `EntryCashDividendPaymentDate$outboundSchema` instead. */
  export const outboundSchema = EntryCashDividendPaymentDate$outboundSchema;
  /** @deprecated use `EntryCashDividendPaymentDate$Outbound` instead. */
  export type Outbound = EntryCashDividendPaymentDate$Outbound;
}

export function entryCashDividendPaymentDateToJSON(
  entryCashDividendPaymentDate: EntryCashDividendPaymentDate,
): string {
  return JSON.stringify(
    EntryCashDividendPaymentDate$outboundSchema.parse(
      entryCashDividendPaymentDate,
    ),
  );
}

export function entryCashDividendPaymentDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryCashDividendPaymentDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryCashDividendPaymentDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryCashDividendPaymentDate' from JSON`,
  );
}

/** @internal */
export const EntryCashDividendQuantity$inboundSchema: z.ZodType<
  EntryCashDividendQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryCashDividendQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryCashDividendQuantity$outboundSchema: z.ZodType<
  EntryCashDividendQuantity$Outbound,
  z.ZodTypeDef,
  EntryCashDividendQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryCashDividendQuantity$ {
  /** @deprecated use `EntryCashDividendQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryCashDividendQuantity$inboundSchema;
  /** @deprecated use `EntryCashDividendQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryCashDividendQuantity$outboundSchema;
  /** @deprecated use `EntryCashDividendQuantity$Outbound` instead. */
  export type Outbound = EntryCashDividendQuantity$Outbound;
}

export function entryCashDividendQuantityToJSON(
  entryCashDividendQuantity: EntryCashDividendQuantity,
): string {
  return JSON.stringify(
    EntryCashDividendQuantity$outboundSchema.parse(entryCashDividendQuantity),
  );
}

export function entryCashDividendQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryCashDividendQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryCashDividendQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryCashDividendQuantity' from JSON`,
  );
}

/** @internal */
export const EntryRecordDate$inboundSchema: z.ZodType<
  EntryRecordDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryRecordDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryRecordDate$outboundSchema: z.ZodType<
  EntryRecordDate$Outbound,
  z.ZodTypeDef,
  EntryRecordDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRecordDate$ {
  /** @deprecated use `EntryRecordDate$inboundSchema` instead. */
  export const inboundSchema = EntryRecordDate$inboundSchema;
  /** @deprecated use `EntryRecordDate$outboundSchema` instead. */
  export const outboundSchema = EntryRecordDate$outboundSchema;
  /** @deprecated use `EntryRecordDate$Outbound` instead. */
  export type Outbound = EntryRecordDate$Outbound;
}

export function entryRecordDateToJSON(
  entryRecordDate: EntryRecordDate,
): string {
  return JSON.stringify(EntryRecordDate$outboundSchema.parse(entryRecordDate));
}

export function entryRecordDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryRecordDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryRecordDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryRecordDate' from JSON`,
  );
}

/** @internal */
export const EntryCashDividendSettled$inboundSchema: z.ZodType<
  EntryCashDividendSettled,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryCashDividendSettled$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryCashDividendSettled$outboundSchema: z.ZodType<
  EntryCashDividendSettled$Outbound,
  z.ZodTypeDef,
  EntryCashDividendSettled
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryCashDividendSettled$ {
  /** @deprecated use `EntryCashDividendSettled$inboundSchema` instead. */
  export const inboundSchema = EntryCashDividendSettled$inboundSchema;
  /** @deprecated use `EntryCashDividendSettled$outboundSchema` instead. */
  export const outboundSchema = EntryCashDividendSettled$outboundSchema;
  /** @deprecated use `EntryCashDividendSettled$Outbound` instead. */
  export type Outbound = EntryCashDividendSettled$Outbound;
}

export function entryCashDividendSettledToJSON(
  entryCashDividendSettled: EntryCashDividendSettled,
): string {
  return JSON.stringify(
    EntryCashDividendSettled$outboundSchema.parse(entryCashDividendSettled),
  );
}

export function entryCashDividendSettledFromJSON(
  jsonString: string,
): SafeParseResult<EntryCashDividendSettled, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryCashDividendSettled$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryCashDividendSettled' from JSON`,
  );
}

/** @internal */
export const Subtype$inboundSchema: z.ZodType<
  SubtypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Subtype),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Subtype$outboundSchema: z.ZodType<
  SubtypeOpen,
  z.ZodTypeDef,
  SubtypeOpen
> = z.union([
  z.nativeEnum(Subtype),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Subtype$ {
  /** @deprecated use `Subtype$inboundSchema` instead. */
  export const inboundSchema = Subtype$inboundSchema;
  /** @deprecated use `Subtype$outboundSchema` instead. */
  export const outboundSchema = Subtype$outboundSchema;
}

/** @internal */
export const CashDividend$inboundSchema: z.ZodType<
  CashDividend,
  z.ZodTypeDef,
  unknown
> = z.object({
  cash_rate: z.nullable(z.lazy(() => EntryCashDividendCashRate$inboundSchema))
    .optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryCashDividendCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  fpsl: z.nullable(z.lazy(() => EntryFpsl$inboundSchema)).optional(),
  free: z.nullable(z.lazy(() => EntryFree$inboundSchema)).optional(),
  long_term_gain: z.boolean().optional(),
  payment_date: z.nullable(
    z.lazy(() => EntryCashDividendPaymentDate$inboundSchema),
  ).optional(),
  qualified: z.boolean().optional(),
  quantity: z.nullable(z.lazy(() => EntryCashDividendQuantity$inboundSchema))
    .optional(),
  record_date: z.nullable(z.lazy(() => EntryRecordDate$inboundSchema))
    .optional(),
  reinvested: z.boolean().optional(),
  settled: z.nullable(z.lazy(() => EntryCashDividendSettled$inboundSchema))
    .optional(),
  substitute_payment: z.boolean().optional(),
  subtype: Subtype$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "cash_rate": "cashRate",
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "long_term_gain": "longTermGain",
    "payment_date": "paymentDate",
    "record_date": "recordDate",
    "substitute_payment": "substitutePayment",
  });
});

/** @internal */
export type CashDividend$Outbound = {
  cash_rate?: EntryCashDividendCashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntryCashDividendCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  fpsl?: EntryFpsl$Outbound | null | undefined;
  free?: EntryFree$Outbound | null | undefined;
  long_term_gain?: boolean | undefined;
  payment_date?: EntryCashDividendPaymentDate$Outbound | null | undefined;
  qualified?: boolean | undefined;
  quantity?: EntryCashDividendQuantity$Outbound | null | undefined;
  record_date?: EntryRecordDate$Outbound | null | undefined;
  reinvested?: boolean | undefined;
  settled?: EntryCashDividendSettled$Outbound | null | undefined;
  substitute_payment?: boolean | undefined;
  subtype?: string | undefined;
};

/** @internal */
export const CashDividend$outboundSchema: z.ZodType<
  CashDividend$Outbound,
  z.ZodTypeDef,
  CashDividend
> = z.object({
  cashRate: z.nullable(z.lazy(() => EntryCashDividendCashRate$outboundSchema))
    .optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryCashDividendCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  fpsl: z.nullable(z.lazy(() => EntryFpsl$outboundSchema)).optional(),
  free: z.nullable(z.lazy(() => EntryFree$outboundSchema)).optional(),
  longTermGain: z.boolean().optional(),
  paymentDate: z.nullable(
    z.lazy(() => EntryCashDividendPaymentDate$outboundSchema),
  ).optional(),
  qualified: z.boolean().optional(),
  quantity: z.nullable(z.lazy(() => EntryCashDividendQuantity$outboundSchema))
    .optional(),
  recordDate: z.nullable(z.lazy(() => EntryRecordDate$outboundSchema))
    .optional(),
  reinvested: z.boolean().optional(),
  settled: z.nullable(z.lazy(() => EntryCashDividendSettled$outboundSchema))
    .optional(),
  substitutePayment: z.boolean().optional(),
  subtype: Subtype$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    longTermGain: "long_term_gain",
    paymentDate: "payment_date",
    recordDate: "record_date",
    substitutePayment: "substitute_payment",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CashDividend$ {
  /** @deprecated use `CashDividend$inboundSchema` instead. */
  export const inboundSchema = CashDividend$inboundSchema;
  /** @deprecated use `CashDividend$outboundSchema` instead. */
  export const outboundSchema = CashDividend$outboundSchema;
  /** @deprecated use `CashDividend$Outbound` instead. */
  export type Outbound = CashDividend$Outbound;
}

export function cashDividendToJSON(cashDividend: CashDividend): string {
  return JSON.stringify(CashDividend$outboundSchema.parse(cashDividend));
}

export function cashDividendFromJSON(
  jsonString: string,
): SafeParseResult<CashDividend, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CashDividend$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CashDividend' from JSON`,
  );
}

/** @internal */
export const EntryCashInLieuCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryCashInLieuCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryCashInLieuCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryCashInLieuCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryCashInLieuCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryCashInLieuCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryCashInLieuCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryCashInLieuCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryCashInLieuCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryCashInLieuCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryCashInLieuCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryCashInLieuCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryCashInLieuCorporateActionGeneralInformation$Outbound;
}

export function entryCashInLieuCorporateActionGeneralInformationToJSON(
  entryCashInLieuCorporateActionGeneralInformation:
    EntryCashInLieuCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryCashInLieuCorporateActionGeneralInformation$outboundSchema.parse(
      entryCashInLieuCorporateActionGeneralInformation,
    ),
  );
}

export function entryCashInLieuCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryCashInLieuCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryCashInLieuCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryCashInLieuCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const CashInLieu$inboundSchema: z.ZodType<
  CashInLieu,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryCashInLieuCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
  });
});

/** @internal */
export type CashInLieu$Outbound = {
  corporate_action_general_information?:
    | EntryCashInLieuCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
};

/** @internal */
export const CashInLieu$outboundSchema: z.ZodType<
  CashInLieu$Outbound,
  z.ZodTypeDef,
  CashInLieu
> = z.object({
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryCashInLieuCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CashInLieu$ {
  /** @deprecated use `CashInLieu$inboundSchema` instead. */
  export const inboundSchema = CashInLieu$inboundSchema;
  /** @deprecated use `CashInLieu$outboundSchema` instead. */
  export const outboundSchema = CashInLieu$outboundSchema;
  /** @deprecated use `CashInLieu$Outbound` instead. */
  export type Outbound = CashInLieu$Outbound;
}

export function cashInLieuToJSON(cashInLieu: CashInLieu): string {
  return JSON.stringify(CashInLieu$outboundSchema.parse(cashInLieu));
}

export function cashInLieuFromJSON(
  jsonString: string,
): SafeParseResult<CashInLieu, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CashInLieu$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CashInLieu' from JSON`,
  );
}

/** @internal */
export const EntryCommission$inboundSchema: z.ZodType<
  EntryCommission,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type EntryCommission$Outbound = {};

/** @internal */
export const EntryCommission$outboundSchema: z.ZodType<
  EntryCommission$Outbound,
  z.ZodTypeDef,
  EntryCommission
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryCommission$ {
  /** @deprecated use `EntryCommission$inboundSchema` instead. */
  export const inboundSchema = EntryCommission$inboundSchema;
  /** @deprecated use `EntryCommission$outboundSchema` instead. */
  export const outboundSchema = EntryCommission$outboundSchema;
  /** @deprecated use `EntryCommission$Outbound` instead. */
  export type Outbound = EntryCommission$Outbound;
}

export function entryCommissionToJSON(
  entryCommission: EntryCommission,
): string {
  return JSON.stringify(EntryCommission$outboundSchema.parse(entryCommission));
}

export function entryCommissionFromJSON(
  jsonString: string,
): SafeParseResult<EntryCommission, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryCommission$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryCommission' from JSON`,
  );
}

/** @internal */
export const EntryConversionCashRate$inboundSchema: z.ZodType<
  EntryConversionCashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryConversionCashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryConversionCashRate$outboundSchema: z.ZodType<
  EntryConversionCashRate$Outbound,
  z.ZodTypeDef,
  EntryConversionCashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryConversionCashRate$ {
  /** @deprecated use `EntryConversionCashRate$inboundSchema` instead. */
  export const inboundSchema = EntryConversionCashRate$inboundSchema;
  /** @deprecated use `EntryConversionCashRate$outboundSchema` instead. */
  export const outboundSchema = EntryConversionCashRate$outboundSchema;
  /** @deprecated use `EntryConversionCashRate$Outbound` instead. */
  export type Outbound = EntryConversionCashRate$Outbound;
}

export function entryConversionCashRateToJSON(
  entryConversionCashRate: EntryConversionCashRate,
): string {
  return JSON.stringify(
    EntryConversionCashRate$outboundSchema.parse(entryConversionCashRate),
  );
}

export function entryConversionCashRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryConversionCashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryConversionCashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryConversionCashRate' from JSON`,
  );
}

/** @internal */
export const EntryConversionCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryConversionCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryConversionCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryConversionCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryConversionCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryConversionCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryConversionCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryConversionCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryConversionCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryConversionCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryConversionCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryConversionCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryConversionCorporateActionGeneralInformation$Outbound;
}

export function entryConversionCorporateActionGeneralInformationToJSON(
  entryConversionCorporateActionGeneralInformation:
    EntryConversionCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryConversionCorporateActionGeneralInformation$outboundSchema.parse(
      entryConversionCorporateActionGeneralInformation,
    ),
  );
}

export function entryConversionCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryConversionCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryConversionCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryConversionCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const StockRate$inboundSchema: z.ZodType<
  StockRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type StockRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const StockRate$outboundSchema: z.ZodType<
  StockRate$Outbound,
  z.ZodTypeDef,
  StockRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StockRate$ {
  /** @deprecated use `StockRate$inboundSchema` instead. */
  export const inboundSchema = StockRate$inboundSchema;
  /** @deprecated use `StockRate$outboundSchema` instead. */
  export const outboundSchema = StockRate$outboundSchema;
  /** @deprecated use `StockRate$Outbound` instead. */
  export type Outbound = StockRate$Outbound;
}

export function stockRateToJSON(stockRate: StockRate): string {
  return JSON.stringify(StockRate$outboundSchema.parse(stockRate));
}

export function stockRateFromJSON(
  jsonString: string,
): SafeParseResult<StockRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StockRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StockRate' from JSON`,
  );
}

/** @internal */
export const EntryConversionType$inboundSchema: z.ZodType<
  EntryConversionTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryConversionType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryConversionType$outboundSchema: z.ZodType<
  EntryConversionTypeOpen,
  z.ZodTypeDef,
  EntryConversionTypeOpen
> = z.union([
  z.nativeEnum(EntryConversionType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryConversionType$ {
  /** @deprecated use `EntryConversionType$inboundSchema` instead. */
  export const inboundSchema = EntryConversionType$inboundSchema;
  /** @deprecated use `EntryConversionType$outboundSchema` instead. */
  export const outboundSchema = EntryConversionType$outboundSchema;
}

/** @internal */
export const Conversion$inboundSchema: z.ZodType<
  Conversion,
  z.ZodTypeDef,
  unknown
> = z.object({
  cash_rate: z.nullable(z.lazy(() => EntryConversionCashRate$inboundSchema))
    .optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryConversionCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  stock_rate: z.nullable(z.lazy(() => StockRate$inboundSchema)).optional(),
  type: EntryConversionType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "cash_rate": "cashRate",
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "stock_rate": "stockRate",
  });
});

/** @internal */
export type Conversion$Outbound = {
  cash_rate?: EntryConversionCashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntryConversionCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  stock_rate?: StockRate$Outbound | null | undefined;
  type?: string | undefined;
};

/** @internal */
export const Conversion$outboundSchema: z.ZodType<
  Conversion$Outbound,
  z.ZodTypeDef,
  Conversion
> = z.object({
  cashRate: z.nullable(z.lazy(() => EntryConversionCashRate$outboundSchema))
    .optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryConversionCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  stockRate: z.nullable(z.lazy(() => StockRate$outboundSchema)).optional(),
  type: EntryConversionType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    stockRate: "stock_rate",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Conversion$ {
  /** @deprecated use `Conversion$inboundSchema` instead. */
  export const inboundSchema = Conversion$inboundSchema;
  /** @deprecated use `Conversion$outboundSchema` instead. */
  export const outboundSchema = Conversion$outboundSchema;
  /** @deprecated use `Conversion$Outbound` instead. */
  export type Outbound = Conversion$Outbound;
}

export function conversionToJSON(conversion: Conversion): string {
  return JSON.stringify(Conversion$outboundSchema.parse(conversion));
}

export function conversionFromJSON(
  jsonString: string,
): SafeParseResult<Conversion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Conversion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Conversion' from JSON`,
  );
}

/** @internal */
export const CorporateActionMemoAdjustment$inboundSchema: z.ZodType<
  CorporateActionMemoAdjustment,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_id: z.string().optional(),
  corporate_action_type: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_id": "corporateActionId",
    "corporate_action_type": "corporateActionType",
  });
});

/** @internal */
export type CorporateActionMemoAdjustment$Outbound = {
  corporate_action_id?: string | undefined;
  corporate_action_type?: string | undefined;
};

/** @internal */
export const CorporateActionMemoAdjustment$outboundSchema: z.ZodType<
  CorporateActionMemoAdjustment$Outbound,
  z.ZodTypeDef,
  CorporateActionMemoAdjustment
> = z.object({
  corporateActionId: z.string().optional(),
  corporateActionType: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionId: "corporate_action_id",
    corporateActionType: "corporate_action_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CorporateActionMemoAdjustment$ {
  /** @deprecated use `CorporateActionMemoAdjustment$inboundSchema` instead. */
  export const inboundSchema = CorporateActionMemoAdjustment$inboundSchema;
  /** @deprecated use `CorporateActionMemoAdjustment$outboundSchema` instead. */
  export const outboundSchema = CorporateActionMemoAdjustment$outboundSchema;
  /** @deprecated use `CorporateActionMemoAdjustment$Outbound` instead. */
  export type Outbound = CorporateActionMemoAdjustment$Outbound;
}

export function corporateActionMemoAdjustmentToJSON(
  corporateActionMemoAdjustment: CorporateActionMemoAdjustment,
): string {
  return JSON.stringify(
    CorporateActionMemoAdjustment$outboundSchema.parse(
      corporateActionMemoAdjustment,
    ),
  );
}

export function corporateActionMemoAdjustmentFromJSON(
  jsonString: string,
): SafeParseResult<CorporateActionMemoAdjustment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CorporateActionMemoAdjustment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CorporateActionMemoAdjustment' from JSON`,
  );
}

/** @internal */
export const CreditType$inboundSchema: z.ZodType<
  CreditTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CreditType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CreditType$outboundSchema: z.ZodType<
  CreditTypeOpen,
  z.ZodTypeDef,
  CreditTypeOpen
> = z.union([
  z.nativeEnum(CreditType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreditType$ {
  /** @deprecated use `CreditType$inboundSchema` instead. */
  export const inboundSchema = CreditType$inboundSchema;
  /** @deprecated use `CreditType$outboundSchema` instead. */
  export const outboundSchema = CreditType$outboundSchema;
}

/** @internal */
export const Credit$inboundSchema: z.ZodType<Credit, z.ZodTypeDef, unknown> = z
  .object({
    additional_instructions: z.string().optional(),
    credit_type: CreditType$inboundSchema.optional(),
    taxable: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "additional_instructions": "additionalInstructions",
      "credit_type": "creditType",
    });
  });

/** @internal */
export type Credit$Outbound = {
  additional_instructions?: string | undefined;
  credit_type?: string | undefined;
  taxable?: boolean | undefined;
};

/** @internal */
export const Credit$outboundSchema: z.ZodType<
  Credit$Outbound,
  z.ZodTypeDef,
  Credit
> = z.object({
  additionalInstructions: z.string().optional(),
  creditType: CreditType$outboundSchema.optional(),
  taxable: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    additionalInstructions: "additional_instructions",
    creditType: "credit_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Credit$ {
  /** @deprecated use `Credit$inboundSchema` instead. */
  export const inboundSchema = Credit$inboundSchema;
  /** @deprecated use `Credit$outboundSchema` instead. */
  export const outboundSchema = Credit$outboundSchema;
  /** @deprecated use `Credit$Outbound` instead. */
  export type Outbound = Credit$Outbound;
}

export function creditToJSON(credit: Credit): string {
  return JSON.stringify(Credit$outboundSchema.parse(credit));
}

export function creditFromJSON(
  jsonString: string,
): SafeParseResult<Credit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Credit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Credit' from JSON`,
  );
}

/** @internal */
export const EntryDeliveryCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryDeliveryCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryDeliveryCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryDeliveryCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryDeliveryCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryDeliveryCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryDeliveryCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryDeliveryCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryDeliveryCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryDeliveryCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryDeliveryCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryDeliveryCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryDeliveryCorporateActionGeneralInformation$Outbound;
}

export function entryDeliveryCorporateActionGeneralInformationToJSON(
  entryDeliveryCorporateActionGeneralInformation:
    EntryDeliveryCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryDeliveryCorporateActionGeneralInformation$outboundSchema.parse(
      entryDeliveryCorporateActionGeneralInformation,
    ),
  );
}

export function entryDeliveryCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryDeliveryCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryDeliveryCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryDeliveryCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const Delivery$inboundSchema: z.ZodType<
  Delivery,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_general_information: z.nullable(
    z.lazy(() => EntryDeliveryCorporateActionGeneralInformation$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
  });
});

/** @internal */
export type Delivery$Outbound = {
  corporate_action_general_information?:
    | EntryDeliveryCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
};

/** @internal */
export const Delivery$outboundSchema: z.ZodType<
  Delivery$Outbound,
  z.ZodTypeDef,
  Delivery
> = z.object({
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() => EntryDeliveryCorporateActionGeneralInformation$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Delivery$ {
  /** @deprecated use `Delivery$inboundSchema` instead. */
  export const inboundSchema = Delivery$inboundSchema;
  /** @deprecated use `Delivery$outboundSchema` instead. */
  export const outboundSchema = Delivery$outboundSchema;
  /** @deprecated use `Delivery$Outbound` instead. */
  export type Outbound = Delivery$Outbound;
}

export function deliveryToJSON(delivery: Delivery): string {
  return JSON.stringify(Delivery$outboundSchema.parse(delivery));
}

export function deliveryFromJSON(
  jsonString: string,
): SafeParseResult<Delivery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Delivery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Delivery' from JSON`,
  );
}

/** @internal */
export const ContributionType$inboundSchema: z.ZodType<
  ContributionTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ContributionType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ContributionType$outboundSchema: z.ZodType<
  ContributionTypeOpen,
  z.ZodTypeDef,
  ContributionTypeOpen
> = z.union([
  z.nativeEnum(ContributionType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContributionType$ {
  /** @deprecated use `ContributionType$inboundSchema` instead. */
  export const inboundSchema = ContributionType$inboundSchema;
  /** @deprecated use `ContributionType$outboundSchema` instead. */
  export const outboundSchema = ContributionType$outboundSchema;
}

/** @internal */
export const EntryDepositType$inboundSchema: z.ZodType<
  EntryDepositTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryDepositType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryDepositType$outboundSchema: z.ZodType<
  EntryDepositTypeOpen,
  z.ZodTypeDef,
  EntryDepositTypeOpen
> = z.union([
  z.nativeEnum(EntryDepositType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryDepositType$ {
  /** @deprecated use `EntryDepositType$inboundSchema` instead. */
  export const inboundSchema = EntryDepositType$inboundSchema;
  /** @deprecated use `EntryDepositType$outboundSchema` instead. */
  export const outboundSchema = EntryDepositType$outboundSchema;
}

/** @internal */
export const Deposit$inboundSchema: z.ZodType<Deposit, z.ZodTypeDef, unknown> =
  z.object({
    additional_instructions: z.string().optional(),
    contribution_type: ContributionType$inboundSchema.optional(),
    contribution_year: z.number().int().optional(),
    fed_reference_number: z.string().optional(),
    originating_account_number: z.string().optional(),
    type: EntryDepositType$inboundSchema.optional(),
  }).transform((v) => {
    return remap$(v, {
      "additional_instructions": "additionalInstructions",
      "contribution_type": "contributionType",
      "contribution_year": "contributionYear",
      "fed_reference_number": "fedReferenceNumber",
      "originating_account_number": "originatingAccountNumber",
    });
  });

/** @internal */
export type Deposit$Outbound = {
  additional_instructions?: string | undefined;
  contribution_type?: string | undefined;
  contribution_year?: number | undefined;
  fed_reference_number?: string | undefined;
  originating_account_number?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const Deposit$outboundSchema: z.ZodType<
  Deposit$Outbound,
  z.ZodTypeDef,
  Deposit
> = z.object({
  additionalInstructions: z.string().optional(),
  contributionType: ContributionType$outboundSchema.optional(),
  contributionYear: z.number().int().optional(),
  fedReferenceNumber: z.string().optional(),
  originatingAccountNumber: z.string().optional(),
  type: EntryDepositType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    additionalInstructions: "additional_instructions",
    contributionType: "contribution_type",
    contributionYear: "contribution_year",
    fedReferenceNumber: "fed_reference_number",
    originatingAccountNumber: "originating_account_number",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deposit$ {
  /** @deprecated use `Deposit$inboundSchema` instead. */
  export const inboundSchema = Deposit$inboundSchema;
  /** @deprecated use `Deposit$outboundSchema` instead. */
  export const outboundSchema = Deposit$outboundSchema;
  /** @deprecated use `Deposit$Outbound` instead. */
  export type Outbound = Deposit$Outbound;
}

export function depositToJSON(deposit: Deposit): string {
  return JSON.stringify(Deposit$outboundSchema.parse(deposit));
}

export function depositFromJSON(
  jsonString: string,
): SafeParseResult<Deposit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deposit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deposit' from JSON`,
  );
}

/** @internal */
export const EntryAction$inboundSchema: z.ZodType<
  EntryActionOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryAction),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryAction$outboundSchema: z.ZodType<
  EntryActionOpen,
  z.ZodTypeDef,
  EntryActionOpen
> = z.union([
  z.nativeEnum(EntryAction),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryAction$ {
  /** @deprecated use `EntryAction$inboundSchema` instead. */
  export const inboundSchema = EntryAction$inboundSchema;
  /** @deprecated use `EntryAction$outboundSchema` instead. */
  export const outboundSchema = EntryAction$outboundSchema;
}

/** @internal */
export const Drip$inboundSchema: z.ZodType<Drip, z.ZodTypeDef, unknown> = z
  .object({
    action: EntryAction$inboundSchema.optional(),
  });

/** @internal */
export type Drip$Outbound = {
  action?: string | undefined;
};

/** @internal */
export const Drip$outboundSchema: z.ZodType<Drip$Outbound, z.ZodTypeDef, Drip> =
  z.object({
    action: EntryAction$outboundSchema.optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Drip$ {
  /** @deprecated use `Drip$inboundSchema` instead. */
  export const inboundSchema = Drip$inboundSchema;
  /** @deprecated use `Drip$outboundSchema` instead. */
  export const outboundSchema = Drip$outboundSchema;
  /** @deprecated use `Drip$Outbound` instead. */
  export type Outbound = Drip$Outbound;
}

export function dripToJSON(drip: Drip): string {
  return JSON.stringify(Drip$outboundSchema.parse(drip));
}

export function dripFromJSON(
  jsonString: string,
): SafeParseResult<Drip, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Drip$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Drip' from JSON`,
  );
}

/** @internal */
export const EntryExchangeCashRate$inboundSchema: z.ZodType<
  EntryExchangeCashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryExchangeCashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryExchangeCashRate$outboundSchema: z.ZodType<
  EntryExchangeCashRate$Outbound,
  z.ZodTypeDef,
  EntryExchangeCashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryExchangeCashRate$ {
  /** @deprecated use `EntryExchangeCashRate$inboundSchema` instead. */
  export const inboundSchema = EntryExchangeCashRate$inboundSchema;
  /** @deprecated use `EntryExchangeCashRate$outboundSchema` instead. */
  export const outboundSchema = EntryExchangeCashRate$outboundSchema;
  /** @deprecated use `EntryExchangeCashRate$Outbound` instead. */
  export type Outbound = EntryExchangeCashRate$Outbound;
}

export function entryExchangeCashRateToJSON(
  entryExchangeCashRate: EntryExchangeCashRate,
): string {
  return JSON.stringify(
    EntryExchangeCashRate$outboundSchema.parse(entryExchangeCashRate),
  );
}

export function entryExchangeCashRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryExchangeCashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryExchangeCashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryExchangeCashRate' from JSON`,
  );
}

/** @internal */
export const EntryExchangeCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryExchangeCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryExchangeCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryExchangeCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryExchangeCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryExchangeCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryExchangeCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryExchangeCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryExchangeCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryExchangeCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryExchangeCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryExchangeCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryExchangeCorporateActionGeneralInformation$Outbound;
}

export function entryExchangeCorporateActionGeneralInformationToJSON(
  entryExchangeCorporateActionGeneralInformation:
    EntryExchangeCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryExchangeCorporateActionGeneralInformation$outboundSchema.parse(
      entryExchangeCorporateActionGeneralInformation,
    ),
  );
}

export function entryExchangeCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryExchangeCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryExchangeCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryExchangeCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryStockRate$inboundSchema: z.ZodType<
  EntryStockRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryStockRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryStockRate$outboundSchema: z.ZodType<
  EntryStockRate$Outbound,
  z.ZodTypeDef,
  EntryStockRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryStockRate$ {
  /** @deprecated use `EntryStockRate$inboundSchema` instead. */
  export const inboundSchema = EntryStockRate$inboundSchema;
  /** @deprecated use `EntryStockRate$outboundSchema` instead. */
  export const outboundSchema = EntryStockRate$outboundSchema;
  /** @deprecated use `EntryStockRate$Outbound` instead. */
  export type Outbound = EntryStockRate$Outbound;
}

export function entryStockRateToJSON(entryStockRate: EntryStockRate): string {
  return JSON.stringify(EntryStockRate$outboundSchema.parse(entryStockRate));
}

export function entryStockRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryStockRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryStockRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryStockRate' from JSON`,
  );
}

/** @internal */
export const EntryExchangeType$inboundSchema: z.ZodType<
  EntryExchangeTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryExchangeType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryExchangeType$outboundSchema: z.ZodType<
  EntryExchangeTypeOpen,
  z.ZodTypeDef,
  EntryExchangeTypeOpen
> = z.union([
  z.nativeEnum(EntryExchangeType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryExchangeType$ {
  /** @deprecated use `EntryExchangeType$inboundSchema` instead. */
  export const inboundSchema = EntryExchangeType$inboundSchema;
  /** @deprecated use `EntryExchangeType$outboundSchema` instead. */
  export const outboundSchema = EntryExchangeType$outboundSchema;
}

/** @internal */
export const Exchange$inboundSchema: z.ZodType<
  Exchange,
  z.ZodTypeDef,
  unknown
> = z.object({
  cash_rate: z.nullable(z.lazy(() => EntryExchangeCashRate$inboundSchema))
    .optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() => EntryExchangeCorporateActionGeneralInformation$inboundSchema),
  ).optional(),
  stock_rate: z.nullable(z.lazy(() => EntryStockRate$inboundSchema)).optional(),
  type: EntryExchangeType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "cash_rate": "cashRate",
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "stock_rate": "stockRate",
  });
});

/** @internal */
export type Exchange$Outbound = {
  cash_rate?: EntryExchangeCashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntryExchangeCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  stock_rate?: EntryStockRate$Outbound | null | undefined;
  type?: string | undefined;
};

/** @internal */
export const Exchange$outboundSchema: z.ZodType<
  Exchange$Outbound,
  z.ZodTypeDef,
  Exchange
> = z.object({
  cashRate: z.nullable(z.lazy(() => EntryExchangeCashRate$outboundSchema))
    .optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() => EntryExchangeCorporateActionGeneralInformation$outboundSchema),
  ).optional(),
  stockRate: z.nullable(z.lazy(() => EntryStockRate$outboundSchema)).optional(),
  type: EntryExchangeType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    stockRate: "stock_rate",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Exchange$ {
  /** @deprecated use `Exchange$inboundSchema` instead. */
  export const inboundSchema = Exchange$inboundSchema;
  /** @deprecated use `Exchange$outboundSchema` instead. */
  export const outboundSchema = Exchange$outboundSchema;
  /** @deprecated use `Exchange$Outbound` instead. */
  export type Outbound = Exchange$Outbound;
}

export function exchangeToJSON(exchange: Exchange): string {
  return JSON.stringify(Exchange$outboundSchema.parse(exchange));
}

export function exchangeFromJSON(
  jsonString: string,
): SafeParseResult<Exchange, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Exchange$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Exchange' from JSON`,
  );
}

/** @internal */
export const EntryFeeType$inboundSchema: z.ZodType<
  EntryFeeTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryFeeType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryFeeType$outboundSchema: z.ZodType<
  EntryFeeTypeOpen,
  z.ZodTypeDef,
  EntryFeeTypeOpen
> = z.union([
  z.nativeEnum(EntryFeeType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFeeType$ {
  /** @deprecated use `EntryFeeType$inboundSchema` instead. */
  export const inboundSchema = EntryFeeType$inboundSchema;
  /** @deprecated use `EntryFeeType$outboundSchema` instead. */
  export const outboundSchema = EntryFeeType$outboundSchema;
}

/** @internal */
export const EntryFee$inboundSchema: z.ZodType<
  EntryFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  additional_instructions: z.string().optional(),
  type: EntryFeeType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "additional_instructions": "additionalInstructions",
  });
});

/** @internal */
export type EntryFee$Outbound = {
  additional_instructions?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const EntryFee$outboundSchema: z.ZodType<
  EntryFee$Outbound,
  z.ZodTypeDef,
  EntryFee
> = z.object({
  additionalInstructions: z.string().optional(),
  type: EntryFeeType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    additionalInstructions: "additional_instructions",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFee$ {
  /** @deprecated use `EntryFee$inboundSchema` instead. */
  export const inboundSchema = EntryFee$inboundSchema;
  /** @deprecated use `EntryFee$outboundSchema` instead. */
  export const outboundSchema = EntryFee$outboundSchema;
  /** @deprecated use `EntryFee$Outbound` instead. */
  export type Outbound = EntryFee$Outbound;
}

export function entryFeeToJSON(entryFee: EntryFee): string {
  return JSON.stringify(EntryFee$outboundSchema.parse(entryFee));
}

export function entryFeeFromJSON(
  jsonString: string,
): SafeParseResult<EntryFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryFee' from JSON`,
  );
}

/** @internal */
export const EntryFlipBrokerCapacity$inboundSchema: z.ZodType<
  EntryFlipBrokerCapacityOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryFlipBrokerCapacity),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryFlipBrokerCapacity$outboundSchema: z.ZodType<
  EntryFlipBrokerCapacityOpen,
  z.ZodTypeDef,
  EntryFlipBrokerCapacityOpen
> = z.union([
  z.nativeEnum(EntryFlipBrokerCapacity),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFlipBrokerCapacity$ {
  /** @deprecated use `EntryFlipBrokerCapacity$inboundSchema` instead. */
  export const inboundSchema = EntryFlipBrokerCapacity$inboundSchema;
  /** @deprecated use `EntryFlipBrokerCapacity$outboundSchema` instead. */
  export const outboundSchema = EntryFlipBrokerCapacity$outboundSchema;
}

/** @internal */
export const EntryFlipPrevailingMarketPrice$inboundSchema: z.ZodType<
  EntryFlipPrevailingMarketPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryFlipPrevailingMarketPrice$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryFlipPrevailingMarketPrice$outboundSchema: z.ZodType<
  EntryFlipPrevailingMarketPrice$Outbound,
  z.ZodTypeDef,
  EntryFlipPrevailingMarketPrice
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFlipPrevailingMarketPrice$ {
  /** @deprecated use `EntryFlipPrevailingMarketPrice$inboundSchema` instead. */
  export const inboundSchema = EntryFlipPrevailingMarketPrice$inboundSchema;
  /** @deprecated use `EntryFlipPrevailingMarketPrice$outboundSchema` instead. */
  export const outboundSchema = EntryFlipPrevailingMarketPrice$outboundSchema;
  /** @deprecated use `EntryFlipPrevailingMarketPrice$Outbound` instead. */
  export type Outbound = EntryFlipPrevailingMarketPrice$Outbound;
}

export function entryFlipPrevailingMarketPriceToJSON(
  entryFlipPrevailingMarketPrice: EntryFlipPrevailingMarketPrice,
): string {
  return JSON.stringify(
    EntryFlipPrevailingMarketPrice$outboundSchema.parse(
      entryFlipPrevailingMarketPrice,
    ),
  );
}

export function entryFlipPrevailingMarketPriceFromJSON(
  jsonString: string,
): SafeParseResult<EntryFlipPrevailingMarketPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryFlipPrevailingMarketPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryFlipPrevailingMarketPrice' from JSON`,
  );
}

/** @internal */
export const EntryFlipPriceAdjustmentAmount$inboundSchema: z.ZodType<
  EntryFlipPriceAdjustmentAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryFlipPriceAdjustmentAmount$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryFlipPriceAdjustmentAmount$outboundSchema: z.ZodType<
  EntryFlipPriceAdjustmentAmount$Outbound,
  z.ZodTypeDef,
  EntryFlipPriceAdjustmentAmount
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFlipPriceAdjustmentAmount$ {
  /** @deprecated use `EntryFlipPriceAdjustmentAmount$inboundSchema` instead. */
  export const inboundSchema = EntryFlipPriceAdjustmentAmount$inboundSchema;
  /** @deprecated use `EntryFlipPriceAdjustmentAmount$outboundSchema` instead. */
  export const outboundSchema = EntryFlipPriceAdjustmentAmount$outboundSchema;
  /** @deprecated use `EntryFlipPriceAdjustmentAmount$Outbound` instead. */
  export type Outbound = EntryFlipPriceAdjustmentAmount$Outbound;
}

export function entryFlipPriceAdjustmentAmountToJSON(
  entryFlipPriceAdjustmentAmount: EntryFlipPriceAdjustmentAmount,
): string {
  return JSON.stringify(
    EntryFlipPriceAdjustmentAmount$outboundSchema.parse(
      entryFlipPriceAdjustmentAmount,
    ),
  );
}

export function entryFlipPriceAdjustmentAmountFromJSON(
  jsonString: string,
): SafeParseResult<EntryFlipPriceAdjustmentAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryFlipPriceAdjustmentAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryFlipPriceAdjustmentAmount' from JSON`,
  );
}

/** @internal */
export const EntryFlipPriceAdjustmentPercent$inboundSchema: z.ZodType<
  EntryFlipPriceAdjustmentPercent,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryFlipPriceAdjustmentPercent$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryFlipPriceAdjustmentPercent$outboundSchema: z.ZodType<
  EntryFlipPriceAdjustmentPercent$Outbound,
  z.ZodTypeDef,
  EntryFlipPriceAdjustmentPercent
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFlipPriceAdjustmentPercent$ {
  /** @deprecated use `EntryFlipPriceAdjustmentPercent$inboundSchema` instead. */
  export const inboundSchema = EntryFlipPriceAdjustmentPercent$inboundSchema;
  /** @deprecated use `EntryFlipPriceAdjustmentPercent$outboundSchema` instead. */
  export const outboundSchema = EntryFlipPriceAdjustmentPercent$outboundSchema;
  /** @deprecated use `EntryFlipPriceAdjustmentPercent$Outbound` instead. */
  export type Outbound = EntryFlipPriceAdjustmentPercent$Outbound;
}

export function entryFlipPriceAdjustmentPercentToJSON(
  entryFlipPriceAdjustmentPercent: EntryFlipPriceAdjustmentPercent,
): string {
  return JSON.stringify(
    EntryFlipPriceAdjustmentPercent$outboundSchema.parse(
      entryFlipPriceAdjustmentPercent,
    ),
  );
}

export function entryFlipPriceAdjustmentPercentFromJSON(
  jsonString: string,
): SafeParseResult<EntryFlipPriceAdjustmentPercent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryFlipPriceAdjustmentPercent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryFlipPriceAdjustmentPercent' from JSON`,
  );
}

/** @internal */
export const EntryFlipPriceAdjustmentType$inboundSchema: z.ZodType<
  EntryFlipPriceAdjustmentTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryFlipPriceAdjustmentType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryFlipPriceAdjustmentType$outboundSchema: z.ZodType<
  EntryFlipPriceAdjustmentTypeOpen,
  z.ZodTypeDef,
  EntryFlipPriceAdjustmentTypeOpen
> = z.union([
  z.nativeEnum(EntryFlipPriceAdjustmentType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFlipPriceAdjustmentType$ {
  /** @deprecated use `EntryFlipPriceAdjustmentType$inboundSchema` instead. */
  export const inboundSchema = EntryFlipPriceAdjustmentType$inboundSchema;
  /** @deprecated use `EntryFlipPriceAdjustmentType$outboundSchema` instead. */
  export const outboundSchema = EntryFlipPriceAdjustmentType$outboundSchema;
}

/** @internal */
export const EntryFlipPriceAdjustmentRecord$inboundSchema: z.ZodType<
  EntryFlipPriceAdjustmentRecord,
  z.ZodTypeDef,
  unknown
> = z.object({
  price_adjustment_amount: z.nullable(
    z.lazy(() => EntryFlipPriceAdjustmentAmount$inboundSchema),
  ).optional(),
  price_adjustment_percent: z.nullable(
    z.lazy(() => EntryFlipPriceAdjustmentPercent$inboundSchema),
  ).optional(),
  price_adjustment_type: EntryFlipPriceAdjustmentType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "price_adjustment_amount": "priceAdjustmentAmount",
    "price_adjustment_percent": "priceAdjustmentPercent",
    "price_adjustment_type": "priceAdjustmentType",
  });
});

/** @internal */
export type EntryFlipPriceAdjustmentRecord$Outbound = {
  price_adjustment_amount?:
    | EntryFlipPriceAdjustmentAmount$Outbound
    | null
    | undefined;
  price_adjustment_percent?:
    | EntryFlipPriceAdjustmentPercent$Outbound
    | null
    | undefined;
  price_adjustment_type?: string | undefined;
};

/** @internal */
export const EntryFlipPriceAdjustmentRecord$outboundSchema: z.ZodType<
  EntryFlipPriceAdjustmentRecord$Outbound,
  z.ZodTypeDef,
  EntryFlipPriceAdjustmentRecord
> = z.object({
  priceAdjustmentAmount: z.nullable(
    z.lazy(() => EntryFlipPriceAdjustmentAmount$outboundSchema),
  ).optional(),
  priceAdjustmentPercent: z.nullable(
    z.lazy(() => EntryFlipPriceAdjustmentPercent$outboundSchema),
  ).optional(),
  priceAdjustmentType: EntryFlipPriceAdjustmentType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    priceAdjustmentAmount: "price_adjustment_amount",
    priceAdjustmentPercent: "price_adjustment_percent",
    priceAdjustmentType: "price_adjustment_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFlipPriceAdjustmentRecord$ {
  /** @deprecated use `EntryFlipPriceAdjustmentRecord$inboundSchema` instead. */
  export const inboundSchema = EntryFlipPriceAdjustmentRecord$inboundSchema;
  /** @deprecated use `EntryFlipPriceAdjustmentRecord$outboundSchema` instead. */
  export const outboundSchema = EntryFlipPriceAdjustmentRecord$outboundSchema;
  /** @deprecated use `EntryFlipPriceAdjustmentRecord$Outbound` instead. */
  export type Outbound = EntryFlipPriceAdjustmentRecord$Outbound;
}

export function entryFlipPriceAdjustmentRecordToJSON(
  entryFlipPriceAdjustmentRecord: EntryFlipPriceAdjustmentRecord,
): string {
  return JSON.stringify(
    EntryFlipPriceAdjustmentRecord$outboundSchema.parse(
      entryFlipPriceAdjustmentRecord,
    ),
  );
}

export function entryFlipPriceAdjustmentRecordFromJSON(
  jsonString: string,
): SafeParseResult<EntryFlipPriceAdjustmentRecord, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryFlipPriceAdjustmentRecord$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryFlipPriceAdjustmentRecord' from JSON`,
  );
}

/** @internal */
export const Detail$inboundSchema: z.ZodType<Detail, z.ZodTypeDef, unknown> = z
  .object({
    additional_instructions: z.array(z.string()).optional(),
    alternate_order_id: z.string().optional(),
    booking_api_booking_execution_id: z.string().optional(),
    booking_api_trade_allocation_id: z.string().optional(),
    booking_api_trade_id: z.string().optional(),
    broker: z.string().optional(),
    broker_capacity: EntryFlipBrokerCapacity$inboundSchema.optional(),
    client_memo: z.string().optional(),
    client_order_id: z.string().optional(),
    exchange: z.string().optional(),
    execution_id: z.string().optional(),
    execution_only: z.boolean().optional(),
    external_id: z.string().optional(),
    fund_confirmation_number: z.string().optional(),
    gateway_client_order_id: z.string().optional(),
    internal_error: z.boolean().optional(),
    is_writeoff: z.boolean().optional(),
    lots: z.array(Lot$inboundSchema).optional(),
    market: z.string().optional(),
    order_id: z.string().optional(),
    prevailing_market_price: z.nullable(
      z.lazy(() => EntryFlipPrevailingMarketPrice$inboundSchema),
    ).optional(),
    price_adjustment_record: z.nullable(
      z.lazy(() => EntryFlipPriceAdjustmentRecord$inboundSchema),
    ).optional(),
    route: z.string().optional(),
    special_instructions: z.array(z.string()).optional(),
    when_issued: z.boolean().optional(),
    yield_records: z.array(YieldRecord$inboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      "additional_instructions": "additionalInstructions",
      "alternate_order_id": "alternateOrderId",
      "booking_api_booking_execution_id": "bookingApiBookingExecutionId",
      "booking_api_trade_allocation_id": "bookingApiTradeAllocationId",
      "booking_api_trade_id": "bookingApiTradeId",
      "broker_capacity": "brokerCapacity",
      "client_memo": "clientMemo",
      "client_order_id": "clientOrderId",
      "execution_id": "executionId",
      "execution_only": "executionOnly",
      "external_id": "externalId",
      "fund_confirmation_number": "fundConfirmationNumber",
      "gateway_client_order_id": "gatewayClientOrderId",
      "internal_error": "internalError",
      "is_writeoff": "isWriteoff",
      "order_id": "orderId",
      "prevailing_market_price": "prevailingMarketPrice",
      "price_adjustment_record": "priceAdjustmentRecord",
      "special_instructions": "specialInstructions",
      "when_issued": "whenIssued",
      "yield_records": "yieldRecords",
    });
  });

/** @internal */
export type Detail$Outbound = {
  additional_instructions?: Array<string> | undefined;
  alternate_order_id?: string | undefined;
  booking_api_booking_execution_id?: string | undefined;
  booking_api_trade_allocation_id?: string | undefined;
  booking_api_trade_id?: string | undefined;
  broker?: string | undefined;
  broker_capacity?: string | undefined;
  client_memo?: string | undefined;
  client_order_id?: string | undefined;
  exchange?: string | undefined;
  execution_id?: string | undefined;
  execution_only?: boolean | undefined;
  external_id?: string | undefined;
  fund_confirmation_number?: string | undefined;
  gateway_client_order_id?: string | undefined;
  internal_error?: boolean | undefined;
  is_writeoff?: boolean | undefined;
  lots?: Array<Lot$Outbound> | undefined;
  market?: string | undefined;
  order_id?: string | undefined;
  prevailing_market_price?:
    | EntryFlipPrevailingMarketPrice$Outbound
    | null
    | undefined;
  price_adjustment_record?:
    | EntryFlipPriceAdjustmentRecord$Outbound
    | null
    | undefined;
  route?: string | undefined;
  special_instructions?: Array<string> | undefined;
  when_issued?: boolean | undefined;
  yield_records?: Array<YieldRecord$Outbound> | undefined;
};

/** @internal */
export const Detail$outboundSchema: z.ZodType<
  Detail$Outbound,
  z.ZodTypeDef,
  Detail
> = z.object({
  additionalInstructions: z.array(z.string()).optional(),
  alternateOrderId: z.string().optional(),
  bookingApiBookingExecutionId: z.string().optional(),
  bookingApiTradeAllocationId: z.string().optional(),
  bookingApiTradeId: z.string().optional(),
  broker: z.string().optional(),
  brokerCapacity: EntryFlipBrokerCapacity$outboundSchema.optional(),
  clientMemo: z.string().optional(),
  clientOrderId: z.string().optional(),
  exchange: z.string().optional(),
  executionId: z.string().optional(),
  executionOnly: z.boolean().optional(),
  externalId: z.string().optional(),
  fundConfirmationNumber: z.string().optional(),
  gatewayClientOrderId: z.string().optional(),
  internalError: z.boolean().optional(),
  isWriteoff: z.boolean().optional(),
  lots: z.array(Lot$outboundSchema).optional(),
  market: z.string().optional(),
  orderId: z.string().optional(),
  prevailingMarketPrice: z.nullable(
    z.lazy(() => EntryFlipPrevailingMarketPrice$outboundSchema),
  ).optional(),
  priceAdjustmentRecord: z.nullable(
    z.lazy(() => EntryFlipPriceAdjustmentRecord$outboundSchema),
  ).optional(),
  route: z.string().optional(),
  specialInstructions: z.array(z.string()).optional(),
  whenIssued: z.boolean().optional(),
  yieldRecords: z.array(YieldRecord$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    additionalInstructions: "additional_instructions",
    alternateOrderId: "alternate_order_id",
    bookingApiBookingExecutionId: "booking_api_booking_execution_id",
    bookingApiTradeAllocationId: "booking_api_trade_allocation_id",
    bookingApiTradeId: "booking_api_trade_id",
    brokerCapacity: "broker_capacity",
    clientMemo: "client_memo",
    clientOrderId: "client_order_id",
    executionId: "execution_id",
    executionOnly: "execution_only",
    externalId: "external_id",
    fundConfirmationNumber: "fund_confirmation_number",
    gatewayClientOrderId: "gateway_client_order_id",
    internalError: "internal_error",
    isWriteoff: "is_writeoff",
    orderId: "order_id",
    prevailingMarketPrice: "prevailing_market_price",
    priceAdjustmentRecord: "price_adjustment_record",
    specialInstructions: "special_instructions",
    whenIssued: "when_issued",
    yieldRecords: "yield_records",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Detail$ {
  /** @deprecated use `Detail$inboundSchema` instead. */
  export const inboundSchema = Detail$inboundSchema;
  /** @deprecated use `Detail$outboundSchema` instead. */
  export const outboundSchema = Detail$outboundSchema;
  /** @deprecated use `Detail$Outbound` instead. */
  export type Outbound = Detail$Outbound;
}

export function detailToJSON(detail: Detail): string {
  return JSON.stringify(Detail$outboundSchema.parse(detail));
}

export function detailFromJSON(
  jsonString: string,
): SafeParseResult<Detail, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Detail$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Detail' from JSON`,
  );
}

/** @internal */
export const Flip$inboundSchema: z.ZodType<Flip, z.ZodTypeDef, unknown> = z
  .object({
    detail: z.nullable(z.lazy(() => Detail$inboundSchema)).optional(),
  });

/** @internal */
export type Flip$Outbound = {
  detail?: Detail$Outbound | null | undefined;
};

/** @internal */
export const Flip$outboundSchema: z.ZodType<Flip$Outbound, z.ZodTypeDef, Flip> =
  z.object({
    detail: z.nullable(z.lazy(() => Detail$outboundSchema)).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Flip$ {
  /** @deprecated use `Flip$inboundSchema` instead. */
  export const inboundSchema = Flip$inboundSchema;
  /** @deprecated use `Flip$outboundSchema` instead. */
  export const outboundSchema = Flip$outboundSchema;
  /** @deprecated use `Flip$Outbound` instead. */
  export type Outbound = Flip$Outbound;
}

export function flipToJSON(flip: Flip): string {
  return JSON.stringify(Flip$outboundSchema.parse(flip));
}

export function flipFromJSON(
  jsonString: string,
): SafeParseResult<Flip, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Flip$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Flip' from JSON`,
  );
}

/** @internal */
export const EntryFpslAction$inboundSchema: z.ZodType<
  EntryFpslActionOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryFpslAction),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryFpslAction$outboundSchema: z.ZodType<
  EntryFpslActionOpen,
  z.ZodTypeDef,
  EntryFpslActionOpen
> = z.union([
  z.nativeEnum(EntryFpslAction),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFpslAction$ {
  /** @deprecated use `EntryFpslAction$inboundSchema` instead. */
  export const inboundSchema = EntryFpslAction$inboundSchema;
  /** @deprecated use `EntryFpslAction$outboundSchema` instead. */
  export const outboundSchema = EntryFpslAction$outboundSchema;
}

/** @internal */
export const Fpsl$inboundSchema: z.ZodType<Fpsl, z.ZodTypeDef, unknown> = z
  .object({
    action: EntryFpslAction$inboundSchema.optional(),
  });

/** @internal */
export type Fpsl$Outbound = {
  action?: string | undefined;
};

/** @internal */
export const Fpsl$outboundSchema: z.ZodType<Fpsl$Outbound, z.ZodTypeDef, Fpsl> =
  z.object({
    action: EntryFpslAction$outboundSchema.optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Fpsl$ {
  /** @deprecated use `Fpsl$inboundSchema` instead. */
  export const inboundSchema = Fpsl$inboundSchema;
  /** @deprecated use `Fpsl$outboundSchema` instead. */
  export const outboundSchema = Fpsl$outboundSchema;
  /** @deprecated use `Fpsl$Outbound` instead. */
  export type Outbound = Fpsl$Outbound;
}

export function fpslToJSON(fpsl: Fpsl): string {
  return JSON.stringify(Fpsl$outboundSchema.parse(fpsl));
}

export function fpslFromJSON(
  jsonString: string,
): SafeParseResult<Fpsl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Fpsl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Fpsl' from JSON`,
  );
}

/** @internal */
export const EntryGrossAmount$inboundSchema: z.ZodType<
  EntryGrossAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryGrossAmount$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryGrossAmount$outboundSchema: z.ZodType<
  EntryGrossAmount$Outbound,
  z.ZodTypeDef,
  EntryGrossAmount
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryGrossAmount$ {
  /** @deprecated use `EntryGrossAmount$inboundSchema` instead. */
  export const inboundSchema = EntryGrossAmount$inboundSchema;
  /** @deprecated use `EntryGrossAmount$outboundSchema` instead. */
  export const outboundSchema = EntryGrossAmount$outboundSchema;
  /** @deprecated use `EntryGrossAmount$Outbound` instead. */
  export type Outbound = EntryGrossAmount$Outbound;
}

export function entryGrossAmountToJSON(
  entryGrossAmount: EntryGrossAmount,
): string {
  return JSON.stringify(
    EntryGrossAmount$outboundSchema.parse(entryGrossAmount),
  );
}

export function entryGrossAmountFromJSON(
  jsonString: string,
): SafeParseResult<EntryGrossAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryGrossAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryGrossAmount' from JSON`,
  );
}

/** @internal */
export const InterestAccrualEndDate$inboundSchema: z.ZodType<
  InterestAccrualEndDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type InterestAccrualEndDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const InterestAccrualEndDate$outboundSchema: z.ZodType<
  InterestAccrualEndDate$Outbound,
  z.ZodTypeDef,
  InterestAccrualEndDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InterestAccrualEndDate$ {
  /** @deprecated use `InterestAccrualEndDate$inboundSchema` instead. */
  export const inboundSchema = InterestAccrualEndDate$inboundSchema;
  /** @deprecated use `InterestAccrualEndDate$outboundSchema` instead. */
  export const outboundSchema = InterestAccrualEndDate$outboundSchema;
  /** @deprecated use `InterestAccrualEndDate$Outbound` instead. */
  export type Outbound = InterestAccrualEndDate$Outbound;
}

export function interestAccrualEndDateToJSON(
  interestAccrualEndDate: InterestAccrualEndDate,
): string {
  return JSON.stringify(
    InterestAccrualEndDate$outboundSchema.parse(interestAccrualEndDate),
  );
}

export function interestAccrualEndDateFromJSON(
  jsonString: string,
): SafeParseResult<InterestAccrualEndDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InterestAccrualEndDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InterestAccrualEndDate' from JSON`,
  );
}

/** @internal */
export const InterestAccrualStartDate$inboundSchema: z.ZodType<
  InterestAccrualStartDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type InterestAccrualStartDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const InterestAccrualStartDate$outboundSchema: z.ZodType<
  InterestAccrualStartDate$Outbound,
  z.ZodTypeDef,
  InterestAccrualStartDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InterestAccrualStartDate$ {
  /** @deprecated use `InterestAccrualStartDate$inboundSchema` instead. */
  export const inboundSchema = InterestAccrualStartDate$inboundSchema;
  /** @deprecated use `InterestAccrualStartDate$outboundSchema` instead. */
  export const outboundSchema = InterestAccrualStartDate$outboundSchema;
  /** @deprecated use `InterestAccrualStartDate$Outbound` instead. */
  export type Outbound = InterestAccrualStartDate$Outbound;
}

export function interestAccrualStartDateToJSON(
  interestAccrualStartDate: InterestAccrualStartDate,
): string {
  return JSON.stringify(
    InterestAccrualStartDate$outboundSchema.parse(interestAccrualStartDate),
  );
}

export function interestAccrualStartDateFromJSON(
  jsonString: string,
): SafeParseResult<InterestAccrualStartDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InterestAccrualStartDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InterestAccrualStartDate' from JSON`,
  );
}

/** @internal */
export const InterestType$inboundSchema: z.ZodType<
  InterestTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InterestType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InterestType$outboundSchema: z.ZodType<
  InterestTypeOpen,
  z.ZodTypeDef,
  InterestTypeOpen
> = z.union([
  z.nativeEnum(InterestType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InterestType$ {
  /** @deprecated use `InterestType$inboundSchema` instead. */
  export const inboundSchema = InterestType$inboundSchema;
  /** @deprecated use `InterestType$outboundSchema` instead. */
  export const outboundSchema = InterestType$outboundSchema;
}

/** @internal */
export const Interest$inboundSchema: z.ZodType<
  Interest,
  z.ZodTypeDef,
  unknown
> = z.object({
  interest_accrual_end_date: z.nullable(
    z.lazy(() => InterestAccrualEndDate$inboundSchema),
  ).optional(),
  interest_accrual_start_date: z.nullable(
    z.lazy(() => InterestAccrualStartDate$inboundSchema),
  ).optional(),
  interest_type: InterestType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "interest_accrual_end_date": "interestAccrualEndDate",
    "interest_accrual_start_date": "interestAccrualStartDate",
    "interest_type": "interestType",
  });
});

/** @internal */
export type Interest$Outbound = {
  interest_accrual_end_date?:
    | InterestAccrualEndDate$Outbound
    | null
    | undefined;
  interest_accrual_start_date?:
    | InterestAccrualStartDate$Outbound
    | null
    | undefined;
  interest_type?: string | undefined;
};

/** @internal */
export const Interest$outboundSchema: z.ZodType<
  Interest$Outbound,
  z.ZodTypeDef,
  Interest
> = z.object({
  interestAccrualEndDate: z.nullable(
    z.lazy(() => InterestAccrualEndDate$outboundSchema),
  ).optional(),
  interestAccrualStartDate: z.nullable(
    z.lazy(() => InterestAccrualStartDate$outboundSchema),
  ).optional(),
  interestType: InterestType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    interestAccrualEndDate: "interest_accrual_end_date",
    interestAccrualStartDate: "interest_accrual_start_date",
    interestType: "interest_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Interest$ {
  /** @deprecated use `Interest$inboundSchema` instead. */
  export const inboundSchema = Interest$inboundSchema;
  /** @deprecated use `Interest$outboundSchema` instead. */
  export const outboundSchema = Interest$outboundSchema;
  /** @deprecated use `Interest$Outbound` instead. */
  export type Outbound = Interest$Outbound;
}

export function interestToJSON(interest: Interest): string {
  return JSON.stringify(Interest$outboundSchema.parse(interest));
}

export function interestFromJSON(
  jsonString: string,
): SafeParseResult<Interest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Interest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Interest' from JSON`,
  );
}

/** @internal */
export const EntryInterestPaymentCashRate$inboundSchema: z.ZodType<
  EntryInterestPaymentCashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryInterestPaymentCashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryInterestPaymentCashRate$outboundSchema: z.ZodType<
  EntryInterestPaymentCashRate$Outbound,
  z.ZodTypeDef,
  EntryInterestPaymentCashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryInterestPaymentCashRate$ {
  /** @deprecated use `EntryInterestPaymentCashRate$inboundSchema` instead. */
  export const inboundSchema = EntryInterestPaymentCashRate$inboundSchema;
  /** @deprecated use `EntryInterestPaymentCashRate$outboundSchema` instead. */
  export const outboundSchema = EntryInterestPaymentCashRate$outboundSchema;
  /** @deprecated use `EntryInterestPaymentCashRate$Outbound` instead. */
  export type Outbound = EntryInterestPaymentCashRate$Outbound;
}

export function entryInterestPaymentCashRateToJSON(
  entryInterestPaymentCashRate: EntryInterestPaymentCashRate,
): string {
  return JSON.stringify(
    EntryInterestPaymentCashRate$outboundSchema.parse(
      entryInterestPaymentCashRate,
    ),
  );
}

export function entryInterestPaymentCashRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryInterestPaymentCashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryInterestPaymentCashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryInterestPaymentCashRate' from JSON`,
  );
}

/** @internal */
export const EntryInterestPaymentCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryInterestPaymentCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryInterestPaymentCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryInterestPaymentCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryInterestPaymentCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryInterestPaymentCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryInterestPaymentCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryInterestPaymentCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryInterestPaymentCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryInterestPaymentCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryInterestPaymentCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryInterestPaymentCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryInterestPaymentCorporateActionGeneralInformation$Outbound;
}

export function entryInterestPaymentCorporateActionGeneralInformationToJSON(
  entryInterestPaymentCorporateActionGeneralInformation:
    EntryInterestPaymentCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryInterestPaymentCorporateActionGeneralInformation$outboundSchema.parse(
      entryInterestPaymentCorporateActionGeneralInformation,
    ),
  );
}

export function entryInterestPaymentCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryInterestPaymentCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryInterestPaymentCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryInterestPaymentCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryInterestPaymentPaymentDate$inboundSchema: z.ZodType<
  EntryInterestPaymentPaymentDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryInterestPaymentPaymentDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryInterestPaymentPaymentDate$outboundSchema: z.ZodType<
  EntryInterestPaymentPaymentDate$Outbound,
  z.ZodTypeDef,
  EntryInterestPaymentPaymentDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryInterestPaymentPaymentDate$ {
  /** @deprecated use `EntryInterestPaymentPaymentDate$inboundSchema` instead. */
  export const inboundSchema = EntryInterestPaymentPaymentDate$inboundSchema;
  /** @deprecated use `EntryInterestPaymentPaymentDate$outboundSchema` instead. */
  export const outboundSchema = EntryInterestPaymentPaymentDate$outboundSchema;
  /** @deprecated use `EntryInterestPaymentPaymentDate$Outbound` instead. */
  export type Outbound = EntryInterestPaymentPaymentDate$Outbound;
}

export function entryInterestPaymentPaymentDateToJSON(
  entryInterestPaymentPaymentDate: EntryInterestPaymentPaymentDate,
): string {
  return JSON.stringify(
    EntryInterestPaymentPaymentDate$outboundSchema.parse(
      entryInterestPaymentPaymentDate,
    ),
  );
}

export function entryInterestPaymentPaymentDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryInterestPaymentPaymentDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryInterestPaymentPaymentDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryInterestPaymentPaymentDate' from JSON`,
  );
}

/** @internal */
export const EntryInterestPaymentRecordDate$inboundSchema: z.ZodType<
  EntryInterestPaymentRecordDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryInterestPaymentRecordDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryInterestPaymentRecordDate$outboundSchema: z.ZodType<
  EntryInterestPaymentRecordDate$Outbound,
  z.ZodTypeDef,
  EntryInterestPaymentRecordDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryInterestPaymentRecordDate$ {
  /** @deprecated use `EntryInterestPaymentRecordDate$inboundSchema` instead. */
  export const inboundSchema = EntryInterestPaymentRecordDate$inboundSchema;
  /** @deprecated use `EntryInterestPaymentRecordDate$outboundSchema` instead. */
  export const outboundSchema = EntryInterestPaymentRecordDate$outboundSchema;
  /** @deprecated use `EntryInterestPaymentRecordDate$Outbound` instead. */
  export type Outbound = EntryInterestPaymentRecordDate$Outbound;
}

export function entryInterestPaymentRecordDateToJSON(
  entryInterestPaymentRecordDate: EntryInterestPaymentRecordDate,
): string {
  return JSON.stringify(
    EntryInterestPaymentRecordDate$outboundSchema.parse(
      entryInterestPaymentRecordDate,
    ),
  );
}

export function entryInterestPaymentRecordDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryInterestPaymentRecordDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryInterestPaymentRecordDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryInterestPaymentRecordDate' from JSON`,
  );
}

/** @internal */
export const EntrySettled$inboundSchema: z.ZodType<
  EntrySettled,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntrySettled$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntrySettled$outboundSchema: z.ZodType<
  EntrySettled$Outbound,
  z.ZodTypeDef,
  EntrySettled
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySettled$ {
  /** @deprecated use `EntrySettled$inboundSchema` instead. */
  export const inboundSchema = EntrySettled$inboundSchema;
  /** @deprecated use `EntrySettled$outboundSchema` instead. */
  export const outboundSchema = EntrySettled$outboundSchema;
  /** @deprecated use `EntrySettled$Outbound` instead. */
  export type Outbound = EntrySettled$Outbound;
}

export function entrySettledToJSON(entrySettled: EntrySettled): string {
  return JSON.stringify(EntrySettled$outboundSchema.parse(entrySettled));
}

export function entrySettledFromJSON(
  jsonString: string,
): SafeParseResult<EntrySettled, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntrySettled$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntrySettled' from JSON`,
  );
}

/** @internal */
export const InterestPayment$inboundSchema: z.ZodType<
  InterestPayment,
  z.ZodTypeDef,
  unknown
> = z.object({
  cash_rate: z.nullable(
    z.lazy(() => EntryInterestPaymentCashRate$inboundSchema),
  ).optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryInterestPaymentCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  payment_date: z.nullable(
    z.lazy(() => EntryInterestPaymentPaymentDate$inboundSchema),
  ).optional(),
  record_date: z.nullable(
    z.lazy(() => EntryInterestPaymentRecordDate$inboundSchema),
  ).optional(),
  settled: z.nullable(z.lazy(() => EntrySettled$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "cash_rate": "cashRate",
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "payment_date": "paymentDate",
    "record_date": "recordDate",
  });
});

/** @internal */
export type InterestPayment$Outbound = {
  cash_rate?: EntryInterestPaymentCashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntryInterestPaymentCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  payment_date?: EntryInterestPaymentPaymentDate$Outbound | null | undefined;
  record_date?: EntryInterestPaymentRecordDate$Outbound | null | undefined;
  settled?: EntrySettled$Outbound | null | undefined;
};

/** @internal */
export const InterestPayment$outboundSchema: z.ZodType<
  InterestPayment$Outbound,
  z.ZodTypeDef,
  InterestPayment
> = z.object({
  cashRate: z.nullable(
    z.lazy(() => EntryInterestPaymentCashRate$outboundSchema),
  ).optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryInterestPaymentCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  paymentDate: z.nullable(
    z.lazy(() => EntryInterestPaymentPaymentDate$outboundSchema),
  ).optional(),
  recordDate: z.nullable(
    z.lazy(() => EntryInterestPaymentRecordDate$outboundSchema),
  ).optional(),
  settled: z.nullable(z.lazy(() => EntrySettled$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    paymentDate: "payment_date",
    recordDate: "record_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InterestPayment$ {
  /** @deprecated use `InterestPayment$inboundSchema` instead. */
  export const inboundSchema = InterestPayment$inboundSchema;
  /** @deprecated use `InterestPayment$outboundSchema` instead. */
  export const outboundSchema = InterestPayment$outboundSchema;
  /** @deprecated use `InterestPayment$Outbound` instead. */
  export type Outbound = InterestPayment$Outbound;
}

export function interestPaymentToJSON(
  interestPayment: InterestPayment,
): string {
  return JSON.stringify(InterestPayment$outboundSchema.parse(interestPayment));
}

export function interestPaymentFromJSON(
  jsonString: string,
): SafeParseResult<InterestPayment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InterestPayment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InterestPayment' from JSON`,
  );
}

/** @internal */
export const EntryLiquidationAction$inboundSchema: z.ZodType<
  EntryLiquidationActionOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryLiquidationAction),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryLiquidationAction$outboundSchema: z.ZodType<
  EntryLiquidationActionOpen,
  z.ZodTypeDef,
  EntryLiquidationActionOpen
> = z.union([
  z.nativeEnum(EntryLiquidationAction),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryLiquidationAction$ {
  /** @deprecated use `EntryLiquidationAction$inboundSchema` instead. */
  export const inboundSchema = EntryLiquidationAction$inboundSchema;
  /** @deprecated use `EntryLiquidationAction$outboundSchema` instead. */
  export const outboundSchema = EntryLiquidationAction$outboundSchema;
}

/** @internal */
export const EntryLiquidationCashRate$inboundSchema: z.ZodType<
  EntryLiquidationCashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryLiquidationCashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryLiquidationCashRate$outboundSchema: z.ZodType<
  EntryLiquidationCashRate$Outbound,
  z.ZodTypeDef,
  EntryLiquidationCashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryLiquidationCashRate$ {
  /** @deprecated use `EntryLiquidationCashRate$inboundSchema` instead. */
  export const inboundSchema = EntryLiquidationCashRate$inboundSchema;
  /** @deprecated use `EntryLiquidationCashRate$outboundSchema` instead. */
  export const outboundSchema = EntryLiquidationCashRate$outboundSchema;
  /** @deprecated use `EntryLiquidationCashRate$Outbound` instead. */
  export type Outbound = EntryLiquidationCashRate$Outbound;
}

export function entryLiquidationCashRateToJSON(
  entryLiquidationCashRate: EntryLiquidationCashRate,
): string {
  return JSON.stringify(
    EntryLiquidationCashRate$outboundSchema.parse(entryLiquidationCashRate),
  );
}

export function entryLiquidationCashRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryLiquidationCashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryLiquidationCashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryLiquidationCashRate' from JSON`,
  );
}

/** @internal */
export const EntryLiquidationCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryLiquidationCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryLiquidationCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryLiquidationCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryLiquidationCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryLiquidationCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryLiquidationCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryLiquidationCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryLiquidationCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryLiquidationCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryLiquidationCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryLiquidationCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryLiquidationCorporateActionGeneralInformation$Outbound;
}

export function entryLiquidationCorporateActionGeneralInformationToJSON(
  entryLiquidationCorporateActionGeneralInformation:
    EntryLiquidationCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryLiquidationCorporateActionGeneralInformation$outboundSchema.parse(
      entryLiquidationCorporateActionGeneralInformation,
    ),
  );
}

export function entryLiquidationCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryLiquidationCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryLiquidationCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryLiquidationCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryEffectiveDate$inboundSchema: z.ZodType<
  EntryEffectiveDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryEffectiveDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryEffectiveDate$outboundSchema: z.ZodType<
  EntryEffectiveDate$Outbound,
  z.ZodTypeDef,
  EntryEffectiveDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryEffectiveDate$ {
  /** @deprecated use `EntryEffectiveDate$inboundSchema` instead. */
  export const inboundSchema = EntryEffectiveDate$inboundSchema;
  /** @deprecated use `EntryEffectiveDate$outboundSchema` instead. */
  export const outboundSchema = EntryEffectiveDate$outboundSchema;
  /** @deprecated use `EntryEffectiveDate$Outbound` instead. */
  export type Outbound = EntryEffectiveDate$Outbound;
}

export function entryEffectiveDateToJSON(
  entryEffectiveDate: EntryEffectiveDate,
): string {
  return JSON.stringify(
    EntryEffectiveDate$outboundSchema.parse(entryEffectiveDate),
  );
}

export function entryEffectiveDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryEffectiveDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryEffectiveDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryEffectiveDate' from JSON`,
  );
}

/** @internal */
export const EntryLiquidationPaymentDate$inboundSchema: z.ZodType<
  EntryLiquidationPaymentDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryLiquidationPaymentDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryLiquidationPaymentDate$outboundSchema: z.ZodType<
  EntryLiquidationPaymentDate$Outbound,
  z.ZodTypeDef,
  EntryLiquidationPaymentDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryLiquidationPaymentDate$ {
  /** @deprecated use `EntryLiquidationPaymentDate$inboundSchema` instead. */
  export const inboundSchema = EntryLiquidationPaymentDate$inboundSchema;
  /** @deprecated use `EntryLiquidationPaymentDate$outboundSchema` instead. */
  export const outboundSchema = EntryLiquidationPaymentDate$outboundSchema;
  /** @deprecated use `EntryLiquidationPaymentDate$Outbound` instead. */
  export type Outbound = EntryLiquidationPaymentDate$Outbound;
}

export function entryLiquidationPaymentDateToJSON(
  entryLiquidationPaymentDate: EntryLiquidationPaymentDate,
): string {
  return JSON.stringify(
    EntryLiquidationPaymentDate$outboundSchema.parse(
      entryLiquidationPaymentDate,
    ),
  );
}

export function entryLiquidationPaymentDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryLiquidationPaymentDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryLiquidationPaymentDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryLiquidationPaymentDate' from JSON`,
  );
}

/** @internal */
export const EntryLiquidationQuantity$inboundSchema: z.ZodType<
  EntryLiquidationQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryLiquidationQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryLiquidationQuantity$outboundSchema: z.ZodType<
  EntryLiquidationQuantity$Outbound,
  z.ZodTypeDef,
  EntryLiquidationQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryLiquidationQuantity$ {
  /** @deprecated use `EntryLiquidationQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryLiquidationQuantity$inboundSchema;
  /** @deprecated use `EntryLiquidationQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryLiquidationQuantity$outboundSchema;
  /** @deprecated use `EntryLiquidationQuantity$Outbound` instead. */
  export type Outbound = EntryLiquidationQuantity$Outbound;
}

export function entryLiquidationQuantityToJSON(
  entryLiquidationQuantity: EntryLiquidationQuantity,
): string {
  return JSON.stringify(
    EntryLiquidationQuantity$outboundSchema.parse(entryLiquidationQuantity),
  );
}

export function entryLiquidationQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryLiquidationQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryLiquidationQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryLiquidationQuantity' from JSON`,
  );
}

/** @internal */
export const EntryLiquidationRecordDate$inboundSchema: z.ZodType<
  EntryLiquidationRecordDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryLiquidationRecordDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryLiquidationRecordDate$outboundSchema: z.ZodType<
  EntryLiquidationRecordDate$Outbound,
  z.ZodTypeDef,
  EntryLiquidationRecordDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryLiquidationRecordDate$ {
  /** @deprecated use `EntryLiquidationRecordDate$inboundSchema` instead. */
  export const inboundSchema = EntryLiquidationRecordDate$inboundSchema;
  /** @deprecated use `EntryLiquidationRecordDate$outboundSchema` instead. */
  export const outboundSchema = EntryLiquidationRecordDate$outboundSchema;
  /** @deprecated use `EntryLiquidationRecordDate$Outbound` instead. */
  export type Outbound = EntryLiquidationRecordDate$Outbound;
}

export function entryLiquidationRecordDateToJSON(
  entryLiquidationRecordDate: EntryLiquidationRecordDate,
): string {
  return JSON.stringify(
    EntryLiquidationRecordDate$outboundSchema.parse(entryLiquidationRecordDate),
  );
}

export function entryLiquidationRecordDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryLiquidationRecordDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryLiquidationRecordDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryLiquidationRecordDate' from JSON`,
  );
}

/** @internal */
export const EntryLiquidationSettled$inboundSchema: z.ZodType<
  EntryLiquidationSettled,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryLiquidationSettled$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryLiquidationSettled$outboundSchema: z.ZodType<
  EntryLiquidationSettled$Outbound,
  z.ZodTypeDef,
  EntryLiquidationSettled
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryLiquidationSettled$ {
  /** @deprecated use `EntryLiquidationSettled$inboundSchema` instead. */
  export const inboundSchema = EntryLiquidationSettled$inboundSchema;
  /** @deprecated use `EntryLiquidationSettled$outboundSchema` instead. */
  export const outboundSchema = EntryLiquidationSettled$outboundSchema;
  /** @deprecated use `EntryLiquidationSettled$Outbound` instead. */
  export type Outbound = EntryLiquidationSettled$Outbound;
}

export function entryLiquidationSettledToJSON(
  entryLiquidationSettled: EntryLiquidationSettled,
): string {
  return JSON.stringify(
    EntryLiquidationSettled$outboundSchema.parse(entryLiquidationSettled),
  );
}

export function entryLiquidationSettledFromJSON(
  jsonString: string,
): SafeParseResult<EntryLiquidationSettled, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryLiquidationSettled$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryLiquidationSettled' from JSON`,
  );
}

/** @internal */
export const EntrySubtype$inboundSchema: z.ZodType<
  EntrySubtypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntrySubtype),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntrySubtype$outboundSchema: z.ZodType<
  EntrySubtypeOpen,
  z.ZodTypeDef,
  EntrySubtypeOpen
> = z.union([
  z.nativeEnum(EntrySubtype),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySubtype$ {
  /** @deprecated use `EntrySubtype$inboundSchema` instead. */
  export const inboundSchema = EntrySubtype$inboundSchema;
  /** @deprecated use `EntrySubtype$outboundSchema` instead. */
  export const outboundSchema = EntrySubtype$outboundSchema;
}

/** @internal */
export const Liquidation$inboundSchema: z.ZodType<
  Liquidation,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: EntryLiquidationAction$inboundSchema.optional(),
  cash_rate: z.nullable(z.lazy(() => EntryLiquidationCashRate$inboundSchema))
    .optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryLiquidationCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  effective_date: z.nullable(z.lazy(() => EntryEffectiveDate$inboundSchema))
    .optional(),
  payment_date: z.nullable(
    z.lazy(() => EntryLiquidationPaymentDate$inboundSchema),
  ).optional(),
  quantity: z.nullable(z.lazy(() => EntryLiquidationQuantity$inboundSchema))
    .optional(),
  record_date: z.nullable(
    z.lazy(() => EntryLiquidationRecordDate$inboundSchema),
  ).optional(),
  settled: z.nullable(z.lazy(() => EntryLiquidationSettled$inboundSchema))
    .optional(),
  subtype: EntrySubtype$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "cash_rate": "cashRate",
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "effective_date": "effectiveDate",
    "payment_date": "paymentDate",
    "record_date": "recordDate",
  });
});

/** @internal */
export type Liquidation$Outbound = {
  action?: string | undefined;
  cash_rate?: EntryLiquidationCashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntryLiquidationCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  effective_date?: EntryEffectiveDate$Outbound | null | undefined;
  payment_date?: EntryLiquidationPaymentDate$Outbound | null | undefined;
  quantity?: EntryLiquidationQuantity$Outbound | null | undefined;
  record_date?: EntryLiquidationRecordDate$Outbound | null | undefined;
  settled?: EntryLiquidationSettled$Outbound | null | undefined;
  subtype?: string | undefined;
};

/** @internal */
export const Liquidation$outboundSchema: z.ZodType<
  Liquidation$Outbound,
  z.ZodTypeDef,
  Liquidation
> = z.object({
  action: EntryLiquidationAction$outboundSchema.optional(),
  cashRate: z.nullable(z.lazy(() => EntryLiquidationCashRate$outboundSchema))
    .optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryLiquidationCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  effectiveDate: z.nullable(z.lazy(() => EntryEffectiveDate$outboundSchema))
    .optional(),
  paymentDate: z.nullable(
    z.lazy(() => EntryLiquidationPaymentDate$outboundSchema),
  ).optional(),
  quantity: z.nullable(z.lazy(() => EntryLiquidationQuantity$outboundSchema))
    .optional(),
  recordDate: z.nullable(
    z.lazy(() => EntryLiquidationRecordDate$outboundSchema),
  ).optional(),
  settled: z.nullable(z.lazy(() => EntryLiquidationSettled$outboundSchema))
    .optional(),
  subtype: EntrySubtype$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    effectiveDate: "effective_date",
    paymentDate: "payment_date",
    recordDate: "record_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Liquidation$ {
  /** @deprecated use `Liquidation$inboundSchema` instead. */
  export const inboundSchema = Liquidation$inboundSchema;
  /** @deprecated use `Liquidation$outboundSchema` instead. */
  export const outboundSchema = Liquidation$outboundSchema;
  /** @deprecated use `Liquidation$Outbound` instead. */
  export type Outbound = Liquidation$Outbound;
}

export function liquidationToJSON(liquidation: Liquidation): string {
  return JSON.stringify(Liquidation$outboundSchema.parse(liquidation));
}

export function liquidationFromJSON(
  jsonString: string,
): SafeParseResult<Liquidation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Liquidation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Liquidation' from JSON`,
  );
}

/** @internal */
export const EntryMaturityCashRate$inboundSchema: z.ZodType<
  EntryMaturityCashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryMaturityCashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryMaturityCashRate$outboundSchema: z.ZodType<
  EntryMaturityCashRate$Outbound,
  z.ZodTypeDef,
  EntryMaturityCashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryMaturityCashRate$ {
  /** @deprecated use `EntryMaturityCashRate$inboundSchema` instead. */
  export const inboundSchema = EntryMaturityCashRate$inboundSchema;
  /** @deprecated use `EntryMaturityCashRate$outboundSchema` instead. */
  export const outboundSchema = EntryMaturityCashRate$outboundSchema;
  /** @deprecated use `EntryMaturityCashRate$Outbound` instead. */
  export type Outbound = EntryMaturityCashRate$Outbound;
}

export function entryMaturityCashRateToJSON(
  entryMaturityCashRate: EntryMaturityCashRate,
): string {
  return JSON.stringify(
    EntryMaturityCashRate$outboundSchema.parse(entryMaturityCashRate),
  );
}

export function entryMaturityCashRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryMaturityCashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryMaturityCashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryMaturityCashRate' from JSON`,
  );
}

/** @internal */
export const EntryMaturityCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryMaturityCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryMaturityCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryMaturityCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryMaturityCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryMaturityCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryMaturityCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryMaturityCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryMaturityCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryMaturityCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryMaturityCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryMaturityCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryMaturityCorporateActionGeneralInformation$Outbound;
}

export function entryMaturityCorporateActionGeneralInformationToJSON(
  entryMaturityCorporateActionGeneralInformation:
    EntryMaturityCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryMaturityCorporateActionGeneralInformation$outboundSchema.parse(
      entryMaturityCorporateActionGeneralInformation,
    ),
  );
}

export function entryMaturityCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryMaturityCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryMaturityCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryMaturityCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryMaturityPaymentDate$inboundSchema: z.ZodType<
  EntryMaturityPaymentDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryMaturityPaymentDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryMaturityPaymentDate$outboundSchema: z.ZodType<
  EntryMaturityPaymentDate$Outbound,
  z.ZodTypeDef,
  EntryMaturityPaymentDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryMaturityPaymentDate$ {
  /** @deprecated use `EntryMaturityPaymentDate$inboundSchema` instead. */
  export const inboundSchema = EntryMaturityPaymentDate$inboundSchema;
  /** @deprecated use `EntryMaturityPaymentDate$outboundSchema` instead. */
  export const outboundSchema = EntryMaturityPaymentDate$outboundSchema;
  /** @deprecated use `EntryMaturityPaymentDate$Outbound` instead. */
  export type Outbound = EntryMaturityPaymentDate$Outbound;
}

export function entryMaturityPaymentDateToJSON(
  entryMaturityPaymentDate: EntryMaturityPaymentDate,
): string {
  return JSON.stringify(
    EntryMaturityPaymentDate$outboundSchema.parse(entryMaturityPaymentDate),
  );
}

export function entryMaturityPaymentDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryMaturityPaymentDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryMaturityPaymentDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryMaturityPaymentDate' from JSON`,
  );
}

/** @internal */
export const EntryMaturityQuantity$inboundSchema: z.ZodType<
  EntryMaturityQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryMaturityQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryMaturityQuantity$outboundSchema: z.ZodType<
  EntryMaturityQuantity$Outbound,
  z.ZodTypeDef,
  EntryMaturityQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryMaturityQuantity$ {
  /** @deprecated use `EntryMaturityQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryMaturityQuantity$inboundSchema;
  /** @deprecated use `EntryMaturityQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryMaturityQuantity$outboundSchema;
  /** @deprecated use `EntryMaturityQuantity$Outbound` instead. */
  export type Outbound = EntryMaturityQuantity$Outbound;
}

export function entryMaturityQuantityToJSON(
  entryMaturityQuantity: EntryMaturityQuantity,
): string {
  return JSON.stringify(
    EntryMaturityQuantity$outboundSchema.parse(entryMaturityQuantity),
  );
}

export function entryMaturityQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryMaturityQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryMaturityQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryMaturityQuantity' from JSON`,
  );
}

/** @internal */
export const Maturity$inboundSchema: z.ZodType<
  Maturity,
  z.ZodTypeDef,
  unknown
> = z.object({
  cash_rate: z.nullable(z.lazy(() => EntryMaturityCashRate$inboundSchema))
    .optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() => EntryMaturityCorporateActionGeneralInformation$inboundSchema),
  ).optional(),
  payment_date: z.nullable(z.lazy(() => EntryMaturityPaymentDate$inboundSchema))
    .optional(),
  quantity: z.nullable(z.lazy(() => EntryMaturityQuantity$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "cash_rate": "cashRate",
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "payment_date": "paymentDate",
  });
});

/** @internal */
export type Maturity$Outbound = {
  cash_rate?: EntryMaturityCashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntryMaturityCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  payment_date?: EntryMaturityPaymentDate$Outbound | null | undefined;
  quantity?: EntryMaturityQuantity$Outbound | null | undefined;
};

/** @internal */
export const Maturity$outboundSchema: z.ZodType<
  Maturity$Outbound,
  z.ZodTypeDef,
  Maturity
> = z.object({
  cashRate: z.nullable(z.lazy(() => EntryMaturityCashRate$outboundSchema))
    .optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() => EntryMaturityCorporateActionGeneralInformation$outboundSchema),
  ).optional(),
  paymentDate: z.nullable(z.lazy(() => EntryMaturityPaymentDate$outboundSchema))
    .optional(),
  quantity: z.nullable(z.lazy(() => EntryMaturityQuantity$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    paymentDate: "payment_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Maturity$ {
  /** @deprecated use `Maturity$inboundSchema` instead. */
  export const inboundSchema = Maturity$inboundSchema;
  /** @deprecated use `Maturity$outboundSchema` instead. */
  export const outboundSchema = Maturity$outboundSchema;
  /** @deprecated use `Maturity$Outbound` instead. */
  export type Outbound = Maturity$Outbound;
}

export function maturityToJSON(maturity: Maturity): string {
  return JSON.stringify(Maturity$outboundSchema.parse(maturity));
}

export function maturityFromJSON(
  jsonString: string,
): SafeParseResult<Maturity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Maturity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Maturity' from JSON`,
  );
}

/** @internal */
export const EntryMergerAction$inboundSchema: z.ZodType<
  EntryMergerActionOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryMergerAction),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryMergerAction$outboundSchema: z.ZodType<
  EntryMergerActionOpen,
  z.ZodTypeDef,
  EntryMergerActionOpen
> = z.union([
  z.nativeEnum(EntryMergerAction),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryMergerAction$ {
  /** @deprecated use `EntryMergerAction$inboundSchema` instead. */
  export const inboundSchema = EntryMergerAction$inboundSchema;
  /** @deprecated use `EntryMergerAction$outboundSchema` instead. */
  export const outboundSchema = EntryMergerAction$outboundSchema;
}

/** @internal */
export const EntryMergerCashRate$inboundSchema: z.ZodType<
  EntryMergerCashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryMergerCashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryMergerCashRate$outboundSchema: z.ZodType<
  EntryMergerCashRate$Outbound,
  z.ZodTypeDef,
  EntryMergerCashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryMergerCashRate$ {
  /** @deprecated use `EntryMergerCashRate$inboundSchema` instead. */
  export const inboundSchema = EntryMergerCashRate$inboundSchema;
  /** @deprecated use `EntryMergerCashRate$outboundSchema` instead. */
  export const outboundSchema = EntryMergerCashRate$outboundSchema;
  /** @deprecated use `EntryMergerCashRate$Outbound` instead. */
  export type Outbound = EntryMergerCashRate$Outbound;
}

export function entryMergerCashRateToJSON(
  entryMergerCashRate: EntryMergerCashRate,
): string {
  return JSON.stringify(
    EntryMergerCashRate$outboundSchema.parse(entryMergerCashRate),
  );
}

export function entryMergerCashRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryMergerCashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryMergerCashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryMergerCashRate' from JSON`,
  );
}

/** @internal */
export const EntryMergerCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryMergerCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryMergerCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryMergerCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryMergerCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryMergerCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryMergerCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryMergerCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryMergerCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryMergerCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryMergerCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryMergerCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound = EntryMergerCorporateActionGeneralInformation$Outbound;
}

export function entryMergerCorporateActionGeneralInformationToJSON(
  entryMergerCorporateActionGeneralInformation:
    EntryMergerCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryMergerCorporateActionGeneralInformation$outboundSchema.parse(
      entryMergerCorporateActionGeneralInformation,
    ),
  );
}

export function entryMergerCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryMergerCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryMergerCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryMergerCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryMergerEffectiveDate$inboundSchema: z.ZodType<
  EntryMergerEffectiveDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryMergerEffectiveDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryMergerEffectiveDate$outboundSchema: z.ZodType<
  EntryMergerEffectiveDate$Outbound,
  z.ZodTypeDef,
  EntryMergerEffectiveDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryMergerEffectiveDate$ {
  /** @deprecated use `EntryMergerEffectiveDate$inboundSchema` instead. */
  export const inboundSchema = EntryMergerEffectiveDate$inboundSchema;
  /** @deprecated use `EntryMergerEffectiveDate$outboundSchema` instead. */
  export const outboundSchema = EntryMergerEffectiveDate$outboundSchema;
  /** @deprecated use `EntryMergerEffectiveDate$Outbound` instead. */
  export type Outbound = EntryMergerEffectiveDate$Outbound;
}

export function entryMergerEffectiveDateToJSON(
  entryMergerEffectiveDate: EntryMergerEffectiveDate,
): string {
  return JSON.stringify(
    EntryMergerEffectiveDate$outboundSchema.parse(entryMergerEffectiveDate),
  );
}

export function entryMergerEffectiveDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryMergerEffectiveDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryMergerEffectiveDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryMergerEffectiveDate' from JSON`,
  );
}

/** @internal */
export const EntryMergerQuantity$inboundSchema: z.ZodType<
  EntryMergerQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryMergerQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryMergerQuantity$outboundSchema: z.ZodType<
  EntryMergerQuantity$Outbound,
  z.ZodTypeDef,
  EntryMergerQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryMergerQuantity$ {
  /** @deprecated use `EntryMergerQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryMergerQuantity$inboundSchema;
  /** @deprecated use `EntryMergerQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryMergerQuantity$outboundSchema;
  /** @deprecated use `EntryMergerQuantity$Outbound` instead. */
  export type Outbound = EntryMergerQuantity$Outbound;
}

export function entryMergerQuantityToJSON(
  entryMergerQuantity: EntryMergerQuantity,
): string {
  return JSON.stringify(
    EntryMergerQuantity$outboundSchema.parse(entryMergerQuantity),
  );
}

export function entryMergerQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryMergerQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryMergerQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryMergerQuantity' from JSON`,
  );
}

/** @internal */
export const EntryMergerStockRate$inboundSchema: z.ZodType<
  EntryMergerStockRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryMergerStockRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryMergerStockRate$outboundSchema: z.ZodType<
  EntryMergerStockRate$Outbound,
  z.ZodTypeDef,
  EntryMergerStockRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryMergerStockRate$ {
  /** @deprecated use `EntryMergerStockRate$inboundSchema` instead. */
  export const inboundSchema = EntryMergerStockRate$inboundSchema;
  /** @deprecated use `EntryMergerStockRate$outboundSchema` instead. */
  export const outboundSchema = EntryMergerStockRate$outboundSchema;
  /** @deprecated use `EntryMergerStockRate$Outbound` instead. */
  export type Outbound = EntryMergerStockRate$Outbound;
}

export function entryMergerStockRateToJSON(
  entryMergerStockRate: EntryMergerStockRate,
): string {
  return JSON.stringify(
    EntryMergerStockRate$outboundSchema.parse(entryMergerStockRate),
  );
}

export function entryMergerStockRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryMergerStockRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryMergerStockRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryMergerStockRate' from JSON`,
  );
}

/** @internal */
export const EntryMergerType$inboundSchema: z.ZodType<
  EntryMergerTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryMergerType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryMergerType$outboundSchema: z.ZodType<
  EntryMergerTypeOpen,
  z.ZodTypeDef,
  EntryMergerTypeOpen
> = z.union([
  z.nativeEnum(EntryMergerType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryMergerType$ {
  /** @deprecated use `EntryMergerType$inboundSchema` instead. */
  export const inboundSchema = EntryMergerType$inboundSchema;
  /** @deprecated use `EntryMergerType$outboundSchema` instead. */
  export const outboundSchema = EntryMergerType$outboundSchema;
}

/** @internal */
export const Merger$inboundSchema: z.ZodType<Merger, z.ZodTypeDef, unknown> = z
  .object({
    action: EntryMergerAction$inboundSchema.optional(),
    cash_rate: z.nullable(z.lazy(() => EntryMergerCashRate$inboundSchema))
      .optional(),
    corporate_action_general_information: z.nullable(
      z.lazy(() => EntryMergerCorporateActionGeneralInformation$inboundSchema),
    ).optional(),
    effective_date: z.nullable(
      z.lazy(() => EntryMergerEffectiveDate$inboundSchema),
    ).optional(),
    quantity: z.nullable(z.lazy(() => EntryMergerQuantity$inboundSchema))
      .optional(),
    stock_rate: z.nullable(z.lazy(() => EntryMergerStockRate$inboundSchema))
      .optional(),
    type: EntryMergerType$inboundSchema.optional(),
  }).transform((v) => {
    return remap$(v, {
      "cash_rate": "cashRate",
      "corporate_action_general_information":
        "corporateActionGeneralInformation",
      "effective_date": "effectiveDate",
      "stock_rate": "stockRate",
    });
  });

/** @internal */
export type Merger$Outbound = {
  action?: string | undefined;
  cash_rate?: EntryMergerCashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntryMergerCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  effective_date?: EntryMergerEffectiveDate$Outbound | null | undefined;
  quantity?: EntryMergerQuantity$Outbound | null | undefined;
  stock_rate?: EntryMergerStockRate$Outbound | null | undefined;
  type?: string | undefined;
};

/** @internal */
export const Merger$outboundSchema: z.ZodType<
  Merger$Outbound,
  z.ZodTypeDef,
  Merger
> = z.object({
  action: EntryMergerAction$outboundSchema.optional(),
  cashRate: z.nullable(z.lazy(() => EntryMergerCashRate$outboundSchema))
    .optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() => EntryMergerCorporateActionGeneralInformation$outboundSchema),
  ).optional(),
  effectiveDate: z.nullable(
    z.lazy(() => EntryMergerEffectiveDate$outboundSchema),
  ).optional(),
  quantity: z.nullable(z.lazy(() => EntryMergerQuantity$outboundSchema))
    .optional(),
  stockRate: z.nullable(z.lazy(() => EntryMergerStockRate$outboundSchema))
    .optional(),
  type: EntryMergerType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    effectiveDate: "effective_date",
    stockRate: "stock_rate",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Merger$ {
  /** @deprecated use `Merger$inboundSchema` instead. */
  export const inboundSchema = Merger$inboundSchema;
  /** @deprecated use `Merger$outboundSchema` instead. */
  export const outboundSchema = Merger$outboundSchema;
  /** @deprecated use `Merger$Outbound` instead. */
  export type Outbound = Merger$Outbound;
}

export function mergerToJSON(merger: Merger): string {
  return JSON.stringify(Merger$outboundSchema.parse(merger));
}

export function mergerFromJSON(
  jsonString: string,
): SafeParseResult<Merger, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Merger$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Merger' from JSON`,
  );
}

/** @internal */
export const EntryNameChangeAction$inboundSchema: z.ZodType<
  EntryNameChangeActionOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryNameChangeAction),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryNameChangeAction$outboundSchema: z.ZodType<
  EntryNameChangeActionOpen,
  z.ZodTypeDef,
  EntryNameChangeActionOpen
> = z.union([
  z.nativeEnum(EntryNameChangeAction),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryNameChangeAction$ {
  /** @deprecated use `EntryNameChangeAction$inboundSchema` instead. */
  export const inboundSchema = EntryNameChangeAction$inboundSchema;
  /** @deprecated use `EntryNameChangeAction$outboundSchema` instead. */
  export const outboundSchema = EntryNameChangeAction$outboundSchema;
}

/** @internal */
export const EntryNameChangeCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryNameChangeCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryNameChangeCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryNameChangeCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryNameChangeCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryNameChangeCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryNameChangeCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryNameChangeCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryNameChangeCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryNameChangeCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryNameChangeCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryNameChangeCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryNameChangeCorporateActionGeneralInformation$Outbound;
}

export function entryNameChangeCorporateActionGeneralInformationToJSON(
  entryNameChangeCorporateActionGeneralInformation:
    EntryNameChangeCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryNameChangeCorporateActionGeneralInformation$outboundSchema.parse(
      entryNameChangeCorporateActionGeneralInformation,
    ),
  );
}

export function entryNameChangeCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryNameChangeCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryNameChangeCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryNameChangeCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryNameChangeEffectiveDate$inboundSchema: z.ZodType<
  EntryNameChangeEffectiveDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryNameChangeEffectiveDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryNameChangeEffectiveDate$outboundSchema: z.ZodType<
  EntryNameChangeEffectiveDate$Outbound,
  z.ZodTypeDef,
  EntryNameChangeEffectiveDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryNameChangeEffectiveDate$ {
  /** @deprecated use `EntryNameChangeEffectiveDate$inboundSchema` instead. */
  export const inboundSchema = EntryNameChangeEffectiveDate$inboundSchema;
  /** @deprecated use `EntryNameChangeEffectiveDate$outboundSchema` instead. */
  export const outboundSchema = EntryNameChangeEffectiveDate$outboundSchema;
  /** @deprecated use `EntryNameChangeEffectiveDate$Outbound` instead. */
  export type Outbound = EntryNameChangeEffectiveDate$Outbound;
}

export function entryNameChangeEffectiveDateToJSON(
  entryNameChangeEffectiveDate: EntryNameChangeEffectiveDate,
): string {
  return JSON.stringify(
    EntryNameChangeEffectiveDate$outboundSchema.parse(
      entryNameChangeEffectiveDate,
    ),
  );
}

export function entryNameChangeEffectiveDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryNameChangeEffectiveDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryNameChangeEffectiveDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryNameChangeEffectiveDate' from JSON`,
  );
}

/** @internal */
export const EntryNameChangeQuantity$inboundSchema: z.ZodType<
  EntryNameChangeQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryNameChangeQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryNameChangeQuantity$outboundSchema: z.ZodType<
  EntryNameChangeQuantity$Outbound,
  z.ZodTypeDef,
  EntryNameChangeQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryNameChangeQuantity$ {
  /** @deprecated use `EntryNameChangeQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryNameChangeQuantity$inboundSchema;
  /** @deprecated use `EntryNameChangeQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryNameChangeQuantity$outboundSchema;
  /** @deprecated use `EntryNameChangeQuantity$Outbound` instead. */
  export type Outbound = EntryNameChangeQuantity$Outbound;
}

export function entryNameChangeQuantityToJSON(
  entryNameChangeQuantity: EntryNameChangeQuantity,
): string {
  return JSON.stringify(
    EntryNameChangeQuantity$outboundSchema.parse(entryNameChangeQuantity),
  );
}

export function entryNameChangeQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryNameChangeQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryNameChangeQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryNameChangeQuantity' from JSON`,
  );
}

/** @internal */
export const NameChange$inboundSchema: z.ZodType<
  NameChange,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: EntryNameChangeAction$inboundSchema.optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryNameChangeCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  effective_date: z.nullable(
    z.lazy(() => EntryNameChangeEffectiveDate$inboundSchema),
  ).optional(),
  quantity: z.nullable(z.lazy(() => EntryNameChangeQuantity$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "effective_date": "effectiveDate",
  });
});

/** @internal */
export type NameChange$Outbound = {
  action?: string | undefined;
  corporate_action_general_information?:
    | EntryNameChangeCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  effective_date?: EntryNameChangeEffectiveDate$Outbound | null | undefined;
  quantity?: EntryNameChangeQuantity$Outbound | null | undefined;
};

/** @internal */
export const NameChange$outboundSchema: z.ZodType<
  NameChange$Outbound,
  z.ZodTypeDef,
  NameChange
> = z.object({
  action: EntryNameChangeAction$outboundSchema.optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryNameChangeCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  effectiveDate: z.nullable(
    z.lazy(() => EntryNameChangeEffectiveDate$outboundSchema),
  ).optional(),
  quantity: z.nullable(z.lazy(() => EntryNameChangeQuantity$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
    effectiveDate: "effective_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NameChange$ {
  /** @deprecated use `NameChange$inboundSchema` instead. */
  export const inboundSchema = NameChange$inboundSchema;
  /** @deprecated use `NameChange$outboundSchema` instead. */
  export const outboundSchema = NameChange$outboundSchema;
  /** @deprecated use `NameChange$Outbound` instead. */
  export type Outbound = NameChange$Outbound;
}

export function nameChangeToJSON(nameChange: NameChange): string {
  return JSON.stringify(NameChange$outboundSchema.parse(nameChange));
}

export function nameChangeFromJSON(
  jsonString: string,
): SafeParseResult<NameChange, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NameChange$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NameChange' from JSON`,
  );
}

/** @internal */
export const OriginalProcessDate$inboundSchema: z.ZodType<
  OriginalProcessDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type OriginalProcessDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const OriginalProcessDate$outboundSchema: z.ZodType<
  OriginalProcessDate$Outbound,
  z.ZodTypeDef,
  OriginalProcessDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OriginalProcessDate$ {
  /** @deprecated use `OriginalProcessDate$inboundSchema` instead. */
  export const inboundSchema = OriginalProcessDate$inboundSchema;
  /** @deprecated use `OriginalProcessDate$outboundSchema` instead. */
  export const outboundSchema = OriginalProcessDate$outboundSchema;
  /** @deprecated use `OriginalProcessDate$Outbound` instead. */
  export type Outbound = OriginalProcessDate$Outbound;
}

export function originalProcessDateToJSON(
  originalProcessDate: OriginalProcessDate,
): string {
  return JSON.stringify(
    OriginalProcessDate$outboundSchema.parse(originalProcessDate),
  );
}

export function originalProcessDateFromJSON(
  jsonString: string,
): SafeParseResult<OriginalProcessDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OriginalProcessDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OriginalProcessDate' from JSON`,
  );
}

/** @internal */
export const EntryPaymentInKindCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryPaymentInKindCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryPaymentInKindCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryPaymentInKindCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryPaymentInKindCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryPaymentInKindCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPaymentInKindCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryPaymentInKindCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryPaymentInKindCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryPaymentInKindCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryPaymentInKindCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryPaymentInKindCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryPaymentInKindCorporateActionGeneralInformation$Outbound;
}

export function entryPaymentInKindCorporateActionGeneralInformationToJSON(
  entryPaymentInKindCorporateActionGeneralInformation:
    EntryPaymentInKindCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryPaymentInKindCorporateActionGeneralInformation$outboundSchema.parse(
      entryPaymentInKindCorporateActionGeneralInformation,
    ),
  );
}

export function entryPaymentInKindCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryPaymentInKindCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryPaymentInKindCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryPaymentInKindCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryPaymentInKindPaymentDate$inboundSchema: z.ZodType<
  EntryPaymentInKindPaymentDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryPaymentInKindPaymentDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryPaymentInKindPaymentDate$outboundSchema: z.ZodType<
  EntryPaymentInKindPaymentDate$Outbound,
  z.ZodTypeDef,
  EntryPaymentInKindPaymentDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPaymentInKindPaymentDate$ {
  /** @deprecated use `EntryPaymentInKindPaymentDate$inboundSchema` instead. */
  export const inboundSchema = EntryPaymentInKindPaymentDate$inboundSchema;
  /** @deprecated use `EntryPaymentInKindPaymentDate$outboundSchema` instead. */
  export const outboundSchema = EntryPaymentInKindPaymentDate$outboundSchema;
  /** @deprecated use `EntryPaymentInKindPaymentDate$Outbound` instead. */
  export type Outbound = EntryPaymentInKindPaymentDate$Outbound;
}

export function entryPaymentInKindPaymentDateToJSON(
  entryPaymentInKindPaymentDate: EntryPaymentInKindPaymentDate,
): string {
  return JSON.stringify(
    EntryPaymentInKindPaymentDate$outboundSchema.parse(
      entryPaymentInKindPaymentDate,
    ),
  );
}

export function entryPaymentInKindPaymentDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryPaymentInKindPaymentDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryPaymentInKindPaymentDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryPaymentInKindPaymentDate' from JSON`,
  );
}

/** @internal */
export const EntryPaymentInKindRecordDate$inboundSchema: z.ZodType<
  EntryPaymentInKindRecordDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryPaymentInKindRecordDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryPaymentInKindRecordDate$outboundSchema: z.ZodType<
  EntryPaymentInKindRecordDate$Outbound,
  z.ZodTypeDef,
  EntryPaymentInKindRecordDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPaymentInKindRecordDate$ {
  /** @deprecated use `EntryPaymentInKindRecordDate$inboundSchema` instead. */
  export const inboundSchema = EntryPaymentInKindRecordDate$inboundSchema;
  /** @deprecated use `EntryPaymentInKindRecordDate$outboundSchema` instead. */
  export const outboundSchema = EntryPaymentInKindRecordDate$outboundSchema;
  /** @deprecated use `EntryPaymentInKindRecordDate$Outbound` instead. */
  export type Outbound = EntryPaymentInKindRecordDate$Outbound;
}

export function entryPaymentInKindRecordDateToJSON(
  entryPaymentInKindRecordDate: EntryPaymentInKindRecordDate,
): string {
  return JSON.stringify(
    EntryPaymentInKindRecordDate$outboundSchema.parse(
      entryPaymentInKindRecordDate,
    ),
  );
}

export function entryPaymentInKindRecordDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryPaymentInKindRecordDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryPaymentInKindRecordDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryPaymentInKindRecordDate' from JSON`,
  );
}

/** @internal */
export const EntryPaymentInKindSettled$inboundSchema: z.ZodType<
  EntryPaymentInKindSettled,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryPaymentInKindSettled$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryPaymentInKindSettled$outboundSchema: z.ZodType<
  EntryPaymentInKindSettled$Outbound,
  z.ZodTypeDef,
  EntryPaymentInKindSettled
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPaymentInKindSettled$ {
  /** @deprecated use `EntryPaymentInKindSettled$inboundSchema` instead. */
  export const inboundSchema = EntryPaymentInKindSettled$inboundSchema;
  /** @deprecated use `EntryPaymentInKindSettled$outboundSchema` instead. */
  export const outboundSchema = EntryPaymentInKindSettled$outboundSchema;
  /** @deprecated use `EntryPaymentInKindSettled$Outbound` instead. */
  export type Outbound = EntryPaymentInKindSettled$Outbound;
}

export function entryPaymentInKindSettledToJSON(
  entryPaymentInKindSettled: EntryPaymentInKindSettled,
): string {
  return JSON.stringify(
    EntryPaymentInKindSettled$outboundSchema.parse(entryPaymentInKindSettled),
  );
}

export function entryPaymentInKindSettledFromJSON(
  jsonString: string,
): SafeParseResult<EntryPaymentInKindSettled, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryPaymentInKindSettled$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryPaymentInKindSettled' from JSON`,
  );
}

/** @internal */
export const EntryPaymentInKindStockRate$inboundSchema: z.ZodType<
  EntryPaymentInKindStockRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryPaymentInKindStockRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryPaymentInKindStockRate$outboundSchema: z.ZodType<
  EntryPaymentInKindStockRate$Outbound,
  z.ZodTypeDef,
  EntryPaymentInKindStockRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPaymentInKindStockRate$ {
  /** @deprecated use `EntryPaymentInKindStockRate$inboundSchema` instead. */
  export const inboundSchema = EntryPaymentInKindStockRate$inboundSchema;
  /** @deprecated use `EntryPaymentInKindStockRate$outboundSchema` instead. */
  export const outboundSchema = EntryPaymentInKindStockRate$outboundSchema;
  /** @deprecated use `EntryPaymentInKindStockRate$Outbound` instead. */
  export type Outbound = EntryPaymentInKindStockRate$Outbound;
}

export function entryPaymentInKindStockRateToJSON(
  entryPaymentInKindStockRate: EntryPaymentInKindStockRate,
): string {
  return JSON.stringify(
    EntryPaymentInKindStockRate$outboundSchema.parse(
      entryPaymentInKindStockRate,
    ),
  );
}

export function entryPaymentInKindStockRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryPaymentInKindStockRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryPaymentInKindStockRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryPaymentInKindStockRate' from JSON`,
  );
}

/** @internal */
export const PaymentInKind$inboundSchema: z.ZodType<
  PaymentInKind,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryPaymentInKindCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  payment_date: z.nullable(
    z.lazy(() => EntryPaymentInKindPaymentDate$inboundSchema),
  ).optional(),
  record_date: z.nullable(
    z.lazy(() => EntryPaymentInKindRecordDate$inboundSchema),
  ).optional(),
  settled: z.nullable(z.lazy(() => EntryPaymentInKindSettled$inboundSchema))
    .optional(),
  stock_rate: z.nullable(
    z.lazy(() => EntryPaymentInKindStockRate$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "payment_date": "paymentDate",
    "record_date": "recordDate",
    "stock_rate": "stockRate",
  });
});

/** @internal */
export type PaymentInKind$Outbound = {
  corporate_action_general_information?:
    | EntryPaymentInKindCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  payment_date?: EntryPaymentInKindPaymentDate$Outbound | null | undefined;
  record_date?: EntryPaymentInKindRecordDate$Outbound | null | undefined;
  settled?: EntryPaymentInKindSettled$Outbound | null | undefined;
  stock_rate?: EntryPaymentInKindStockRate$Outbound | null | undefined;
};

/** @internal */
export const PaymentInKind$outboundSchema: z.ZodType<
  PaymentInKind$Outbound,
  z.ZodTypeDef,
  PaymentInKind
> = z.object({
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryPaymentInKindCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  paymentDate: z.nullable(
    z.lazy(() => EntryPaymentInKindPaymentDate$outboundSchema),
  ).optional(),
  recordDate: z.nullable(
    z.lazy(() => EntryPaymentInKindRecordDate$outboundSchema),
  ).optional(),
  settled: z.nullable(z.lazy(() => EntryPaymentInKindSettled$outboundSchema))
    .optional(),
  stockRate: z.nullable(
    z.lazy(() => EntryPaymentInKindStockRate$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
    paymentDate: "payment_date",
    recordDate: "record_date",
    stockRate: "stock_rate",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentInKind$ {
  /** @deprecated use `PaymentInKind$inboundSchema` instead. */
  export const inboundSchema = PaymentInKind$inboundSchema;
  /** @deprecated use `PaymentInKind$outboundSchema` instead. */
  export const outboundSchema = PaymentInKind$outboundSchema;
  /** @deprecated use `PaymentInKind$Outbound` instead. */
  export type Outbound = PaymentInKind$Outbound;
}

export function paymentInKindToJSON(paymentInKind: PaymentInKind): string {
  return JSON.stringify(PaymentInKind$outboundSchema.parse(paymentInKind));
}

export function paymentInKindFromJSON(
  jsonString: string,
): SafeParseResult<PaymentInKind, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaymentInKind$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaymentInKind' from JSON`,
  );
}

/** @internal */
export const EntryPrice$inboundSchema: z.ZodType<
  EntryPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryPrice$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryPrice$outboundSchema: z.ZodType<
  EntryPrice$Outbound,
  z.ZodTypeDef,
  EntryPrice
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPrice$ {
  /** @deprecated use `EntryPrice$inboundSchema` instead. */
  export const inboundSchema = EntryPrice$inboundSchema;
  /** @deprecated use `EntryPrice$outboundSchema` instead. */
  export const outboundSchema = EntryPrice$outboundSchema;
  /** @deprecated use `EntryPrice$Outbound` instead. */
  export type Outbound = EntryPrice$Outbound;
}

export function entryPriceToJSON(entryPrice: EntryPrice): string {
  return JSON.stringify(EntryPrice$outboundSchema.parse(entryPrice));
}

export function entryPriceFromJSON(
  jsonString: string,
): SafeParseResult<EntryPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryPrice' from JSON`,
  );
}

/** @internal */
export const EntryProcessDate$inboundSchema: z.ZodType<
  EntryProcessDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryProcessDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryProcessDate$outboundSchema: z.ZodType<
  EntryProcessDate$Outbound,
  z.ZodTypeDef,
  EntryProcessDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryProcessDate$ {
  /** @deprecated use `EntryProcessDate$inboundSchema` instead. */
  export const inboundSchema = EntryProcessDate$inboundSchema;
  /** @deprecated use `EntryProcessDate$outboundSchema` instead. */
  export const outboundSchema = EntryProcessDate$outboundSchema;
  /** @deprecated use `EntryProcessDate$Outbound` instead. */
  export type Outbound = EntryProcessDate$Outbound;
}

export function entryProcessDateToJSON(
  entryProcessDate: EntryProcessDate,
): string {
  return JSON.stringify(
    EntryProcessDate$outboundSchema.parse(entryProcessDate),
  );
}

export function entryProcessDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryProcessDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryProcessDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryProcessDate' from JSON`,
  );
}

/** @internal */
export const EntryQuantity$inboundSchema: z.ZodType<
  EntryQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryQuantity$outboundSchema: z.ZodType<
  EntryQuantity$Outbound,
  z.ZodTypeDef,
  EntryQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryQuantity$ {
  /** @deprecated use `EntryQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryQuantity$inboundSchema;
  /** @deprecated use `EntryQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryQuantity$outboundSchema;
  /** @deprecated use `EntryQuantity$Outbound` instead. */
  export type Outbound = EntryQuantity$Outbound;
}

export function entryQuantityToJSON(entryQuantity: EntryQuantity): string {
  return JSON.stringify(EntryQuantity$outboundSchema.parse(entryQuantity));
}

export function entryQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryQuantity' from JSON`,
  );
}

/** @internal */
export const Receive$inboundSchema: z.ZodType<Receive, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type Receive$Outbound = {};

/** @internal */
export const Receive$outboundSchema: z.ZodType<
  Receive$Outbound,
  z.ZodTypeDef,
  Receive
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Receive$ {
  /** @deprecated use `Receive$inboundSchema` instead. */
  export const inboundSchema = Receive$inboundSchema;
  /** @deprecated use `Receive$outboundSchema` instead. */
  export const outboundSchema = Receive$outboundSchema;
  /** @deprecated use `Receive$Outbound` instead. */
  export type Outbound = Receive$Outbound;
}

export function receiveToJSON(receive: Receive): string {
  return JSON.stringify(Receive$outboundSchema.parse(receive));
}

export function receiveFromJSON(
  jsonString: string,
): SafeParseResult<Receive, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Receive$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Receive' from JSON`,
  );
}

/** @internal */
export const EntryRedemptionFullAction$inboundSchema: z.ZodType<
  EntryRedemptionFullActionOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryRedemptionFullAction),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryRedemptionFullAction$outboundSchema: z.ZodType<
  EntryRedemptionFullActionOpen,
  z.ZodTypeDef,
  EntryRedemptionFullActionOpen
> = z.union([
  z.nativeEnum(EntryRedemptionFullAction),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRedemptionFullAction$ {
  /** @deprecated use `EntryRedemptionFullAction$inboundSchema` instead. */
  export const inboundSchema = EntryRedemptionFullAction$inboundSchema;
  /** @deprecated use `EntryRedemptionFullAction$outboundSchema` instead. */
  export const outboundSchema = EntryRedemptionFullAction$outboundSchema;
}

/** @internal */
export const EntryRedemptionFullCashRate$inboundSchema: z.ZodType<
  EntryRedemptionFullCashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryRedemptionFullCashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryRedemptionFullCashRate$outboundSchema: z.ZodType<
  EntryRedemptionFullCashRate$Outbound,
  z.ZodTypeDef,
  EntryRedemptionFullCashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRedemptionFullCashRate$ {
  /** @deprecated use `EntryRedemptionFullCashRate$inboundSchema` instead. */
  export const inboundSchema = EntryRedemptionFullCashRate$inboundSchema;
  /** @deprecated use `EntryRedemptionFullCashRate$outboundSchema` instead. */
  export const outboundSchema = EntryRedemptionFullCashRate$outboundSchema;
  /** @deprecated use `EntryRedemptionFullCashRate$Outbound` instead. */
  export type Outbound = EntryRedemptionFullCashRate$Outbound;
}

export function entryRedemptionFullCashRateToJSON(
  entryRedemptionFullCashRate: EntryRedemptionFullCashRate,
): string {
  return JSON.stringify(
    EntryRedemptionFullCashRate$outboundSchema.parse(
      entryRedemptionFullCashRate,
    ),
  );
}

export function entryRedemptionFullCashRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryRedemptionFullCashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryRedemptionFullCashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryRedemptionFullCashRate' from JSON`,
  );
}

/** @internal */
export const EntryRedemptionFullCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryRedemptionFullCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryRedemptionFullCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryRedemptionFullCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryRedemptionFullCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryRedemptionFullCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRedemptionFullCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryRedemptionFullCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryRedemptionFullCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryRedemptionFullCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryRedemptionFullCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryRedemptionFullCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryRedemptionFullCorporateActionGeneralInformation$Outbound;
}

export function entryRedemptionFullCorporateActionGeneralInformationToJSON(
  entryRedemptionFullCorporateActionGeneralInformation:
    EntryRedemptionFullCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryRedemptionFullCorporateActionGeneralInformation$outboundSchema.parse(
      entryRedemptionFullCorporateActionGeneralInformation,
    ),
  );
}

export function entryRedemptionFullCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryRedemptionFullCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryRedemptionFullCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryRedemptionFullCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryRedemptionFullPaymentDate$inboundSchema: z.ZodType<
  EntryRedemptionFullPaymentDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryRedemptionFullPaymentDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryRedemptionFullPaymentDate$outboundSchema: z.ZodType<
  EntryRedemptionFullPaymentDate$Outbound,
  z.ZodTypeDef,
  EntryRedemptionFullPaymentDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRedemptionFullPaymentDate$ {
  /** @deprecated use `EntryRedemptionFullPaymentDate$inboundSchema` instead. */
  export const inboundSchema = EntryRedemptionFullPaymentDate$inboundSchema;
  /** @deprecated use `EntryRedemptionFullPaymentDate$outboundSchema` instead. */
  export const outboundSchema = EntryRedemptionFullPaymentDate$outboundSchema;
  /** @deprecated use `EntryRedemptionFullPaymentDate$Outbound` instead. */
  export type Outbound = EntryRedemptionFullPaymentDate$Outbound;
}

export function entryRedemptionFullPaymentDateToJSON(
  entryRedemptionFullPaymentDate: EntryRedemptionFullPaymentDate,
): string {
  return JSON.stringify(
    EntryRedemptionFullPaymentDate$outboundSchema.parse(
      entryRedemptionFullPaymentDate,
    ),
  );
}

export function entryRedemptionFullPaymentDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryRedemptionFullPaymentDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryRedemptionFullPaymentDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryRedemptionFullPaymentDate' from JSON`,
  );
}

/** @internal */
export const EntryRedemptionFullQuantity$inboundSchema: z.ZodType<
  EntryRedemptionFullQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryRedemptionFullQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryRedemptionFullQuantity$outboundSchema: z.ZodType<
  EntryRedemptionFullQuantity$Outbound,
  z.ZodTypeDef,
  EntryRedemptionFullQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRedemptionFullQuantity$ {
  /** @deprecated use `EntryRedemptionFullQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryRedemptionFullQuantity$inboundSchema;
  /** @deprecated use `EntryRedemptionFullQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryRedemptionFullQuantity$outboundSchema;
  /** @deprecated use `EntryRedemptionFullQuantity$Outbound` instead. */
  export type Outbound = EntryRedemptionFullQuantity$Outbound;
}

export function entryRedemptionFullQuantityToJSON(
  entryRedemptionFullQuantity: EntryRedemptionFullQuantity,
): string {
  return JSON.stringify(
    EntryRedemptionFullQuantity$outboundSchema.parse(
      entryRedemptionFullQuantity,
    ),
  );
}

export function entryRedemptionFullQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryRedemptionFullQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryRedemptionFullQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryRedemptionFullQuantity' from JSON`,
  );
}

/** @internal */
export const EntryRedemptionFullSubtype$inboundSchema: z.ZodType<
  EntryRedemptionFullSubtypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryRedemptionFullSubtype),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryRedemptionFullSubtype$outboundSchema: z.ZodType<
  EntryRedemptionFullSubtypeOpen,
  z.ZodTypeDef,
  EntryRedemptionFullSubtypeOpen
> = z.union([
  z.nativeEnum(EntryRedemptionFullSubtype),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRedemptionFullSubtype$ {
  /** @deprecated use `EntryRedemptionFullSubtype$inboundSchema` instead. */
  export const inboundSchema = EntryRedemptionFullSubtype$inboundSchema;
  /** @deprecated use `EntryRedemptionFullSubtype$outboundSchema` instead. */
  export const outboundSchema = EntryRedemptionFullSubtype$outboundSchema;
}

/** @internal */
export const RedemptionFull$inboundSchema: z.ZodType<
  RedemptionFull,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: EntryRedemptionFullAction$inboundSchema.optional(),
  cash_rate: z.nullable(z.lazy(() => EntryRedemptionFullCashRate$inboundSchema))
    .optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryRedemptionFullCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  payment_date: z.nullable(
    z.lazy(() => EntryRedemptionFullPaymentDate$inboundSchema),
  ).optional(),
  quantity: z.nullable(z.lazy(() => EntryRedemptionFullQuantity$inboundSchema))
    .optional(),
  subtype: EntryRedemptionFullSubtype$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "cash_rate": "cashRate",
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "payment_date": "paymentDate",
  });
});

/** @internal */
export type RedemptionFull$Outbound = {
  action?: string | undefined;
  cash_rate?: EntryRedemptionFullCashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntryRedemptionFullCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  payment_date?: EntryRedemptionFullPaymentDate$Outbound | null | undefined;
  quantity?: EntryRedemptionFullQuantity$Outbound | null | undefined;
  subtype?: string | undefined;
};

/** @internal */
export const RedemptionFull$outboundSchema: z.ZodType<
  RedemptionFull$Outbound,
  z.ZodTypeDef,
  RedemptionFull
> = z.object({
  action: EntryRedemptionFullAction$outboundSchema.optional(),
  cashRate: z.nullable(z.lazy(() => EntryRedemptionFullCashRate$outboundSchema))
    .optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryRedemptionFullCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  paymentDate: z.nullable(
    z.lazy(() => EntryRedemptionFullPaymentDate$outboundSchema),
  ).optional(),
  quantity: z.nullable(z.lazy(() => EntryRedemptionFullQuantity$outboundSchema))
    .optional(),
  subtype: EntryRedemptionFullSubtype$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    paymentDate: "payment_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RedemptionFull$ {
  /** @deprecated use `RedemptionFull$inboundSchema` instead. */
  export const inboundSchema = RedemptionFull$inboundSchema;
  /** @deprecated use `RedemptionFull$outboundSchema` instead. */
  export const outboundSchema = RedemptionFull$outboundSchema;
  /** @deprecated use `RedemptionFull$Outbound` instead. */
  export type Outbound = RedemptionFull$Outbound;
}

export function redemptionFullToJSON(redemptionFull: RedemptionFull): string {
  return JSON.stringify(RedemptionFull$outboundSchema.parse(redemptionFull));
}

export function redemptionFullFromJSON(
  jsonString: string,
): SafeParseResult<RedemptionFull, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedemptionFull$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedemptionFull' from JSON`,
  );
}

/** @internal */
export const EntryRedemptionPartialAction$inboundSchema: z.ZodType<
  EntryRedemptionPartialActionOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryRedemptionPartialAction),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryRedemptionPartialAction$outboundSchema: z.ZodType<
  EntryRedemptionPartialActionOpen,
  z.ZodTypeDef,
  EntryRedemptionPartialActionOpen
> = z.union([
  z.nativeEnum(EntryRedemptionPartialAction),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRedemptionPartialAction$ {
  /** @deprecated use `EntryRedemptionPartialAction$inboundSchema` instead. */
  export const inboundSchema = EntryRedemptionPartialAction$inboundSchema;
  /** @deprecated use `EntryRedemptionPartialAction$outboundSchema` instead. */
  export const outboundSchema = EntryRedemptionPartialAction$outboundSchema;
}

/** @internal */
export const EntryRedemptionPartialCashRate$inboundSchema: z.ZodType<
  EntryRedemptionPartialCashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryRedemptionPartialCashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryRedemptionPartialCashRate$outboundSchema: z.ZodType<
  EntryRedemptionPartialCashRate$Outbound,
  z.ZodTypeDef,
  EntryRedemptionPartialCashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRedemptionPartialCashRate$ {
  /** @deprecated use `EntryRedemptionPartialCashRate$inboundSchema` instead. */
  export const inboundSchema = EntryRedemptionPartialCashRate$inboundSchema;
  /** @deprecated use `EntryRedemptionPartialCashRate$outboundSchema` instead. */
  export const outboundSchema = EntryRedemptionPartialCashRate$outboundSchema;
  /** @deprecated use `EntryRedemptionPartialCashRate$Outbound` instead. */
  export type Outbound = EntryRedemptionPartialCashRate$Outbound;
}

export function entryRedemptionPartialCashRateToJSON(
  entryRedemptionPartialCashRate: EntryRedemptionPartialCashRate,
): string {
  return JSON.stringify(
    EntryRedemptionPartialCashRate$outboundSchema.parse(
      entryRedemptionPartialCashRate,
    ),
  );
}

export function entryRedemptionPartialCashRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryRedemptionPartialCashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryRedemptionPartialCashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryRedemptionPartialCashRate' from JSON`,
  );
}

/** @internal */
export const EntryRedemptionPartialCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryRedemptionPartialCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryRedemptionPartialCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryRedemptionPartialCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryRedemptionPartialCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryRedemptionPartialCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRedemptionPartialCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryRedemptionPartialCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryRedemptionPartialCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryRedemptionPartialCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryRedemptionPartialCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryRedemptionPartialCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryRedemptionPartialCorporateActionGeneralInformation$Outbound;
}

export function entryRedemptionPartialCorporateActionGeneralInformationToJSON(
  entryRedemptionPartialCorporateActionGeneralInformation:
    EntryRedemptionPartialCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryRedemptionPartialCorporateActionGeneralInformation$outboundSchema
      .parse(entryRedemptionPartialCorporateActionGeneralInformation),
  );
}

export function entryRedemptionPartialCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryRedemptionPartialCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryRedemptionPartialCorporateActionGeneralInformation$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'EntryRedemptionPartialCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryRedemptionPartialPaymentDate$inboundSchema: z.ZodType<
  EntryRedemptionPartialPaymentDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryRedemptionPartialPaymentDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryRedemptionPartialPaymentDate$outboundSchema: z.ZodType<
  EntryRedemptionPartialPaymentDate$Outbound,
  z.ZodTypeDef,
  EntryRedemptionPartialPaymentDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRedemptionPartialPaymentDate$ {
  /** @deprecated use `EntryRedemptionPartialPaymentDate$inboundSchema` instead. */
  export const inboundSchema = EntryRedemptionPartialPaymentDate$inboundSchema;
  /** @deprecated use `EntryRedemptionPartialPaymentDate$outboundSchema` instead. */
  export const outboundSchema =
    EntryRedemptionPartialPaymentDate$outboundSchema;
  /** @deprecated use `EntryRedemptionPartialPaymentDate$Outbound` instead. */
  export type Outbound = EntryRedemptionPartialPaymentDate$Outbound;
}

export function entryRedemptionPartialPaymentDateToJSON(
  entryRedemptionPartialPaymentDate: EntryRedemptionPartialPaymentDate,
): string {
  return JSON.stringify(
    EntryRedemptionPartialPaymentDate$outboundSchema.parse(
      entryRedemptionPartialPaymentDate,
    ),
  );
}

export function entryRedemptionPartialPaymentDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryRedemptionPartialPaymentDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryRedemptionPartialPaymentDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryRedemptionPartialPaymentDate' from JSON`,
  );
}

/** @internal */
export const EntryRedemptionPartialQuantity$inboundSchema: z.ZodType<
  EntryRedemptionPartialQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryRedemptionPartialQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryRedemptionPartialQuantity$outboundSchema: z.ZodType<
  EntryRedemptionPartialQuantity$Outbound,
  z.ZodTypeDef,
  EntryRedemptionPartialQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRedemptionPartialQuantity$ {
  /** @deprecated use `EntryRedemptionPartialQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryRedemptionPartialQuantity$inboundSchema;
  /** @deprecated use `EntryRedemptionPartialQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryRedemptionPartialQuantity$outboundSchema;
  /** @deprecated use `EntryRedemptionPartialQuantity$Outbound` instead. */
  export type Outbound = EntryRedemptionPartialQuantity$Outbound;
}

export function entryRedemptionPartialQuantityToJSON(
  entryRedemptionPartialQuantity: EntryRedemptionPartialQuantity,
): string {
  return JSON.stringify(
    EntryRedemptionPartialQuantity$outboundSchema.parse(
      entryRedemptionPartialQuantity,
    ),
  );
}

export function entryRedemptionPartialQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryRedemptionPartialQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryRedemptionPartialQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryRedemptionPartialQuantity' from JSON`,
  );
}

/** @internal */
export const RedemptionPartial$inboundSchema: z.ZodType<
  RedemptionPartial,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: EntryRedemptionPartialAction$inboundSchema.optional(),
  cash_rate: z.nullable(
    z.lazy(() => EntryRedemptionPartialCashRate$inboundSchema),
  ).optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryRedemptionPartialCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  payment_date: z.nullable(
    z.lazy(() => EntryRedemptionPartialPaymentDate$inboundSchema),
  ).optional(),
  quantity: z.nullable(
    z.lazy(() => EntryRedemptionPartialQuantity$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "cash_rate": "cashRate",
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "payment_date": "paymentDate",
  });
});

/** @internal */
export type RedemptionPartial$Outbound = {
  action?: string | undefined;
  cash_rate?: EntryRedemptionPartialCashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntryRedemptionPartialCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  payment_date?: EntryRedemptionPartialPaymentDate$Outbound | null | undefined;
  quantity?: EntryRedemptionPartialQuantity$Outbound | null | undefined;
};

/** @internal */
export const RedemptionPartial$outboundSchema: z.ZodType<
  RedemptionPartial$Outbound,
  z.ZodTypeDef,
  RedemptionPartial
> = z.object({
  action: EntryRedemptionPartialAction$outboundSchema.optional(),
  cashRate: z.nullable(
    z.lazy(() => EntryRedemptionPartialCashRate$outboundSchema),
  ).optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryRedemptionPartialCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  paymentDate: z.nullable(
    z.lazy(() => EntryRedemptionPartialPaymentDate$outboundSchema),
  ).optional(),
  quantity: z.nullable(
    z.lazy(() => EntryRedemptionPartialQuantity$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    paymentDate: "payment_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RedemptionPartial$ {
  /** @deprecated use `RedemptionPartial$inboundSchema` instead. */
  export const inboundSchema = RedemptionPartial$inboundSchema;
  /** @deprecated use `RedemptionPartial$outboundSchema` instead. */
  export const outboundSchema = RedemptionPartial$outboundSchema;
  /** @deprecated use `RedemptionPartial$Outbound` instead. */
  export type Outbound = RedemptionPartial$Outbound;
}

export function redemptionPartialToJSON(
  redemptionPartial: RedemptionPartial,
): string {
  return JSON.stringify(
    RedemptionPartial$outboundSchema.parse(redemptionPartial),
  );
}

export function redemptionPartialFromJSON(
  jsonString: string,
): SafeParseResult<RedemptionPartial, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedemptionPartial$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedemptionPartial' from JSON`,
  );
}

/** @internal */
export const EntryReverseStockSplitAction$inboundSchema: z.ZodType<
  EntryReverseStockSplitActionOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryReverseStockSplitAction),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryReverseStockSplitAction$outboundSchema: z.ZodType<
  EntryReverseStockSplitActionOpen,
  z.ZodTypeDef,
  EntryReverseStockSplitActionOpen
> = z.union([
  z.nativeEnum(EntryReverseStockSplitAction),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryReverseStockSplitAction$ {
  /** @deprecated use `EntryReverseStockSplitAction$inboundSchema` instead. */
  export const inboundSchema = EntryReverseStockSplitAction$inboundSchema;
  /** @deprecated use `EntryReverseStockSplitAction$outboundSchema` instead. */
  export const outboundSchema = EntryReverseStockSplitAction$outboundSchema;
}

/** @internal */
export const EntryReverseStockSplitCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryReverseStockSplitCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryReverseStockSplitCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryReverseStockSplitCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryReverseStockSplitCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryReverseStockSplitCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryReverseStockSplitCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryReverseStockSplitCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryReverseStockSplitCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryReverseStockSplitCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryReverseStockSplitCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryReverseStockSplitCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryReverseStockSplitCorporateActionGeneralInformation$Outbound;
}

export function entryReverseStockSplitCorporateActionGeneralInformationToJSON(
  entryReverseStockSplitCorporateActionGeneralInformation:
    EntryReverseStockSplitCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryReverseStockSplitCorporateActionGeneralInformation$outboundSchema
      .parse(entryReverseStockSplitCorporateActionGeneralInformation),
  );
}

export function entryReverseStockSplitCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryReverseStockSplitCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryReverseStockSplitCorporateActionGeneralInformation$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'EntryReverseStockSplitCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryReverseStockSplitEffectiveDate$inboundSchema: z.ZodType<
  EntryReverseStockSplitEffectiveDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryReverseStockSplitEffectiveDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryReverseStockSplitEffectiveDate$outboundSchema: z.ZodType<
  EntryReverseStockSplitEffectiveDate$Outbound,
  z.ZodTypeDef,
  EntryReverseStockSplitEffectiveDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryReverseStockSplitEffectiveDate$ {
  /** @deprecated use `EntryReverseStockSplitEffectiveDate$inboundSchema` instead. */
  export const inboundSchema =
    EntryReverseStockSplitEffectiveDate$inboundSchema;
  /** @deprecated use `EntryReverseStockSplitEffectiveDate$outboundSchema` instead. */
  export const outboundSchema =
    EntryReverseStockSplitEffectiveDate$outboundSchema;
  /** @deprecated use `EntryReverseStockSplitEffectiveDate$Outbound` instead. */
  export type Outbound = EntryReverseStockSplitEffectiveDate$Outbound;
}

export function entryReverseStockSplitEffectiveDateToJSON(
  entryReverseStockSplitEffectiveDate: EntryReverseStockSplitEffectiveDate,
): string {
  return JSON.stringify(
    EntryReverseStockSplitEffectiveDate$outboundSchema.parse(
      entryReverseStockSplitEffectiveDate,
    ),
  );
}

export function entryReverseStockSplitEffectiveDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryReverseStockSplitEffectiveDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      EntryReverseStockSplitEffectiveDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryReverseStockSplitEffectiveDate' from JSON`,
  );
}

/** @internal */
export const FactorDenominator$inboundSchema: z.ZodType<
  FactorDenominator,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type FactorDenominator$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const FactorDenominator$outboundSchema: z.ZodType<
  FactorDenominator$Outbound,
  z.ZodTypeDef,
  FactorDenominator
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FactorDenominator$ {
  /** @deprecated use `FactorDenominator$inboundSchema` instead. */
  export const inboundSchema = FactorDenominator$inboundSchema;
  /** @deprecated use `FactorDenominator$outboundSchema` instead. */
  export const outboundSchema = FactorDenominator$outboundSchema;
  /** @deprecated use `FactorDenominator$Outbound` instead. */
  export type Outbound = FactorDenominator$Outbound;
}

export function factorDenominatorToJSON(
  factorDenominator: FactorDenominator,
): string {
  return JSON.stringify(
    FactorDenominator$outboundSchema.parse(factorDenominator),
  );
}

export function factorDenominatorFromJSON(
  jsonString: string,
): SafeParseResult<FactorDenominator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FactorDenominator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FactorDenominator' from JSON`,
  );
}

/** @internal */
export const FactorNumerator$inboundSchema: z.ZodType<
  FactorNumerator,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type FactorNumerator$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const FactorNumerator$outboundSchema: z.ZodType<
  FactorNumerator$Outbound,
  z.ZodTypeDef,
  FactorNumerator
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FactorNumerator$ {
  /** @deprecated use `FactorNumerator$inboundSchema` instead. */
  export const inboundSchema = FactorNumerator$inboundSchema;
  /** @deprecated use `FactorNumerator$outboundSchema` instead. */
  export const outboundSchema = FactorNumerator$outboundSchema;
  /** @deprecated use `FactorNumerator$Outbound` instead. */
  export type Outbound = FactorNumerator$Outbound;
}

export function factorNumeratorToJSON(
  factorNumerator: FactorNumerator,
): string {
  return JSON.stringify(FactorNumerator$outboundSchema.parse(factorNumerator));
}

export function factorNumeratorFromJSON(
  jsonString: string,
): SafeParseResult<FactorNumerator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FactorNumerator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FactorNumerator' from JSON`,
  );
}

/** @internal */
export const EntryReverseStockSplitQuantity$inboundSchema: z.ZodType<
  EntryReverseStockSplitQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryReverseStockSplitQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryReverseStockSplitQuantity$outboundSchema: z.ZodType<
  EntryReverseStockSplitQuantity$Outbound,
  z.ZodTypeDef,
  EntryReverseStockSplitQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryReverseStockSplitQuantity$ {
  /** @deprecated use `EntryReverseStockSplitQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryReverseStockSplitQuantity$inboundSchema;
  /** @deprecated use `EntryReverseStockSplitQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryReverseStockSplitQuantity$outboundSchema;
  /** @deprecated use `EntryReverseStockSplitQuantity$Outbound` instead. */
  export type Outbound = EntryReverseStockSplitQuantity$Outbound;
}

export function entryReverseStockSplitQuantityToJSON(
  entryReverseStockSplitQuantity: EntryReverseStockSplitQuantity,
): string {
  return JSON.stringify(
    EntryReverseStockSplitQuantity$outboundSchema.parse(
      entryReverseStockSplitQuantity,
    ),
  );
}

export function entryReverseStockSplitQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryReverseStockSplitQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryReverseStockSplitQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryReverseStockSplitQuantity' from JSON`,
  );
}

/** @internal */
export const EntryReverseStockSplitStockRate$inboundSchema: z.ZodType<
  EntryReverseStockSplitStockRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryReverseStockSplitStockRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryReverseStockSplitStockRate$outboundSchema: z.ZodType<
  EntryReverseStockSplitStockRate$Outbound,
  z.ZodTypeDef,
  EntryReverseStockSplitStockRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryReverseStockSplitStockRate$ {
  /** @deprecated use `EntryReverseStockSplitStockRate$inboundSchema` instead. */
  export const inboundSchema = EntryReverseStockSplitStockRate$inboundSchema;
  /** @deprecated use `EntryReverseStockSplitStockRate$outboundSchema` instead. */
  export const outboundSchema = EntryReverseStockSplitStockRate$outboundSchema;
  /** @deprecated use `EntryReverseStockSplitStockRate$Outbound` instead. */
  export type Outbound = EntryReverseStockSplitStockRate$Outbound;
}

export function entryReverseStockSplitStockRateToJSON(
  entryReverseStockSplitStockRate: EntryReverseStockSplitStockRate,
): string {
  return JSON.stringify(
    EntryReverseStockSplitStockRate$outboundSchema.parse(
      entryReverseStockSplitStockRate,
    ),
  );
}

export function entryReverseStockSplitStockRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryReverseStockSplitStockRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryReverseStockSplitStockRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryReverseStockSplitStockRate' from JSON`,
  );
}

/** @internal */
export const ReverseStockSplit$inboundSchema: z.ZodType<
  ReverseStockSplit,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: EntryReverseStockSplitAction$inboundSchema.optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryReverseStockSplitCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  effective_date: z.nullable(
    z.lazy(() => EntryReverseStockSplitEffectiveDate$inboundSchema),
  ).optional(),
  factor_denominator: z.nullable(z.lazy(() => FactorDenominator$inboundSchema))
    .optional(),
  factor_numerator: z.nullable(z.lazy(() => FactorNumerator$inboundSchema))
    .optional(),
  quantity: z.nullable(
    z.lazy(() => EntryReverseStockSplitQuantity$inboundSchema),
  ).optional(),
  stock_rate: z.nullable(
    z.lazy(() => EntryReverseStockSplitStockRate$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "effective_date": "effectiveDate",
    "factor_denominator": "factorDenominator",
    "factor_numerator": "factorNumerator",
    "stock_rate": "stockRate",
  });
});

/** @internal */
export type ReverseStockSplit$Outbound = {
  action?: string | undefined;
  corporate_action_general_information?:
    | EntryReverseStockSplitCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  effective_date?:
    | EntryReverseStockSplitEffectiveDate$Outbound
    | null
    | undefined;
  factor_denominator?: FactorDenominator$Outbound | null | undefined;
  factor_numerator?: FactorNumerator$Outbound | null | undefined;
  quantity?: EntryReverseStockSplitQuantity$Outbound | null | undefined;
  stock_rate?: EntryReverseStockSplitStockRate$Outbound | null | undefined;
};

/** @internal */
export const ReverseStockSplit$outboundSchema: z.ZodType<
  ReverseStockSplit$Outbound,
  z.ZodTypeDef,
  ReverseStockSplit
> = z.object({
  action: EntryReverseStockSplitAction$outboundSchema.optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryReverseStockSplitCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  effectiveDate: z.nullable(
    z.lazy(() => EntryReverseStockSplitEffectiveDate$outboundSchema),
  ).optional(),
  factorDenominator: z.nullable(z.lazy(() => FactorDenominator$outboundSchema))
    .optional(),
  factorNumerator: z.nullable(z.lazy(() => FactorNumerator$outboundSchema))
    .optional(),
  quantity: z.nullable(
    z.lazy(() => EntryReverseStockSplitQuantity$outboundSchema),
  ).optional(),
  stockRate: z.nullable(
    z.lazy(() => EntryReverseStockSplitStockRate$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
    effectiveDate: "effective_date",
    factorDenominator: "factor_denominator",
    factorNumerator: "factor_numerator",
    stockRate: "stock_rate",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReverseStockSplit$ {
  /** @deprecated use `ReverseStockSplit$inboundSchema` instead. */
  export const inboundSchema = ReverseStockSplit$inboundSchema;
  /** @deprecated use `ReverseStockSplit$outboundSchema` instead. */
  export const outboundSchema = ReverseStockSplit$outboundSchema;
  /** @deprecated use `ReverseStockSplit$Outbound` instead. */
  export type Outbound = ReverseStockSplit$Outbound;
}

export function reverseStockSplitToJSON(
  reverseStockSplit: ReverseStockSplit,
): string {
  return JSON.stringify(
    ReverseStockSplit$outboundSchema.parse(reverseStockSplit),
  );
}

export function reverseStockSplitFromJSON(
  jsonString: string,
): SafeParseResult<ReverseStockSplit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReverseStockSplit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReverseStockSplit' from JSON`,
  );
}

/** @internal */
export const EntryRightsDistributionCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryRightsDistributionCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryRightsDistributionCorporateActionGeneralInformation$Outbound =
  {
    corporate_action_id?: string | undefined;
    disbursed_asset_id?: string | undefined;
    disbursed_cusip?: string | undefined;
    disbursed_symbol_description?: string | undefined;
    target_asset_id?: string | undefined;
    target_cusip?: string | undefined;
    target_symbol_description?: string | undefined;
  };

/** @internal */
export const EntryRightsDistributionCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryRightsDistributionCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryRightsDistributionCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRightsDistributionCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryRightsDistributionCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryRightsDistributionCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryRightsDistributionCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryRightsDistributionCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryRightsDistributionCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryRightsDistributionCorporateActionGeneralInformation$Outbound;
}

export function entryRightsDistributionCorporateActionGeneralInformationToJSON(
  entryRightsDistributionCorporateActionGeneralInformation:
    EntryRightsDistributionCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryRightsDistributionCorporateActionGeneralInformation$outboundSchema
      .parse(entryRightsDistributionCorporateActionGeneralInformation),
  );
}

export function entryRightsDistributionCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryRightsDistributionCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryRightsDistributionCorporateActionGeneralInformation$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'EntryRightsDistributionCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryRightsDistributionPaymentDate$inboundSchema: z.ZodType<
  EntryRightsDistributionPaymentDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryRightsDistributionPaymentDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryRightsDistributionPaymentDate$outboundSchema: z.ZodType<
  EntryRightsDistributionPaymentDate$Outbound,
  z.ZodTypeDef,
  EntryRightsDistributionPaymentDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRightsDistributionPaymentDate$ {
  /** @deprecated use `EntryRightsDistributionPaymentDate$inboundSchema` instead. */
  export const inboundSchema = EntryRightsDistributionPaymentDate$inboundSchema;
  /** @deprecated use `EntryRightsDistributionPaymentDate$outboundSchema` instead. */
  export const outboundSchema =
    EntryRightsDistributionPaymentDate$outboundSchema;
  /** @deprecated use `EntryRightsDistributionPaymentDate$Outbound` instead. */
  export type Outbound = EntryRightsDistributionPaymentDate$Outbound;
}

export function entryRightsDistributionPaymentDateToJSON(
  entryRightsDistributionPaymentDate: EntryRightsDistributionPaymentDate,
): string {
  return JSON.stringify(
    EntryRightsDistributionPaymentDate$outboundSchema.parse(
      entryRightsDistributionPaymentDate,
    ),
  );
}

export function entryRightsDistributionPaymentDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryRightsDistributionPaymentDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      EntryRightsDistributionPaymentDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryRightsDistributionPaymentDate' from JSON`,
  );
}

/** @internal */
export const EntryRightsDistributionRecordDate$inboundSchema: z.ZodType<
  EntryRightsDistributionRecordDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryRightsDistributionRecordDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryRightsDistributionRecordDate$outboundSchema: z.ZodType<
  EntryRightsDistributionRecordDate$Outbound,
  z.ZodTypeDef,
  EntryRightsDistributionRecordDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRightsDistributionRecordDate$ {
  /** @deprecated use `EntryRightsDistributionRecordDate$inboundSchema` instead. */
  export const inboundSchema = EntryRightsDistributionRecordDate$inboundSchema;
  /** @deprecated use `EntryRightsDistributionRecordDate$outboundSchema` instead. */
  export const outboundSchema =
    EntryRightsDistributionRecordDate$outboundSchema;
  /** @deprecated use `EntryRightsDistributionRecordDate$Outbound` instead. */
  export type Outbound = EntryRightsDistributionRecordDate$Outbound;
}

export function entryRightsDistributionRecordDateToJSON(
  entryRightsDistributionRecordDate: EntryRightsDistributionRecordDate,
): string {
  return JSON.stringify(
    EntryRightsDistributionRecordDate$outboundSchema.parse(
      entryRightsDistributionRecordDate,
    ),
  );
}

export function entryRightsDistributionRecordDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryRightsDistributionRecordDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryRightsDistributionRecordDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryRightsDistributionRecordDate' from JSON`,
  );
}

/** @internal */
export const EntryRightsDistributionSettled$inboundSchema: z.ZodType<
  EntryRightsDistributionSettled,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryRightsDistributionSettled$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryRightsDistributionSettled$outboundSchema: z.ZodType<
  EntryRightsDistributionSettled$Outbound,
  z.ZodTypeDef,
  EntryRightsDistributionSettled
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRightsDistributionSettled$ {
  /** @deprecated use `EntryRightsDistributionSettled$inboundSchema` instead. */
  export const inboundSchema = EntryRightsDistributionSettled$inboundSchema;
  /** @deprecated use `EntryRightsDistributionSettled$outboundSchema` instead. */
  export const outboundSchema = EntryRightsDistributionSettled$outboundSchema;
  /** @deprecated use `EntryRightsDistributionSettled$Outbound` instead. */
  export type Outbound = EntryRightsDistributionSettled$Outbound;
}

export function entryRightsDistributionSettledToJSON(
  entryRightsDistributionSettled: EntryRightsDistributionSettled,
): string {
  return JSON.stringify(
    EntryRightsDistributionSettled$outboundSchema.parse(
      entryRightsDistributionSettled,
    ),
  );
}

export function entryRightsDistributionSettledFromJSON(
  jsonString: string,
): SafeParseResult<EntryRightsDistributionSettled, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryRightsDistributionSettled$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryRightsDistributionSettled' from JSON`,
  );
}

/** @internal */
export const RightsDistribution$inboundSchema: z.ZodType<
  RightsDistribution,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryRightsDistributionCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  payment_date: z.nullable(
    z.lazy(() => EntryRightsDistributionPaymentDate$inboundSchema),
  ).optional(),
  record_date: z.nullable(
    z.lazy(() => EntryRightsDistributionRecordDate$inboundSchema),
  ).optional(),
  settled: z.nullable(
    z.lazy(() => EntryRightsDistributionSettled$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "payment_date": "paymentDate",
    "record_date": "recordDate",
  });
});

/** @internal */
export type RightsDistribution$Outbound = {
  corporate_action_general_information?:
    | EntryRightsDistributionCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  payment_date?: EntryRightsDistributionPaymentDate$Outbound | null | undefined;
  record_date?: EntryRightsDistributionRecordDate$Outbound | null | undefined;
  settled?: EntryRightsDistributionSettled$Outbound | null | undefined;
};

/** @internal */
export const RightsDistribution$outboundSchema: z.ZodType<
  RightsDistribution$Outbound,
  z.ZodTypeDef,
  RightsDistribution
> = z.object({
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryRightsDistributionCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  paymentDate: z.nullable(
    z.lazy(() => EntryRightsDistributionPaymentDate$outboundSchema),
  ).optional(),
  recordDate: z.nullable(
    z.lazy(() => EntryRightsDistributionRecordDate$outboundSchema),
  ).optional(),
  settled: z.nullable(
    z.lazy(() => EntryRightsDistributionSettled$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
    paymentDate: "payment_date",
    recordDate: "record_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RightsDistribution$ {
  /** @deprecated use `RightsDistribution$inboundSchema` instead. */
  export const inboundSchema = RightsDistribution$inboundSchema;
  /** @deprecated use `RightsDistribution$outboundSchema` instead. */
  export const outboundSchema = RightsDistribution$outboundSchema;
  /** @deprecated use `RightsDistribution$Outbound` instead. */
  export type Outbound = RightsDistribution$Outbound;
}

export function rightsDistributionToJSON(
  rightsDistribution: RightsDistribution,
): string {
  return JSON.stringify(
    RightsDistribution$outboundSchema.parse(rightsDistribution),
  );
}

export function rightsDistributionFromJSON(
  jsonString: string,
): SafeParseResult<RightsDistribution, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RightsDistribution$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RightsDistribution' from JSON`,
  );
}

/** @internal */
export const EntryRightsSubscriptionCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryRightsSubscriptionCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryRightsSubscriptionCorporateActionGeneralInformation$Outbound =
  {
    corporate_action_id?: string | undefined;
    disbursed_asset_id?: string | undefined;
    disbursed_cusip?: string | undefined;
    disbursed_symbol_description?: string | undefined;
    target_asset_id?: string | undefined;
    target_cusip?: string | undefined;
    target_symbol_description?: string | undefined;
  };

/** @internal */
export const EntryRightsSubscriptionCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryRightsSubscriptionCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryRightsSubscriptionCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRightsSubscriptionCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryRightsSubscriptionCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryRightsSubscriptionCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryRightsSubscriptionCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryRightsSubscriptionCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryRightsSubscriptionCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryRightsSubscriptionCorporateActionGeneralInformation$Outbound;
}

export function entryRightsSubscriptionCorporateActionGeneralInformationToJSON(
  entryRightsSubscriptionCorporateActionGeneralInformation:
    EntryRightsSubscriptionCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryRightsSubscriptionCorporateActionGeneralInformation$outboundSchema
      .parse(entryRightsSubscriptionCorporateActionGeneralInformation),
  );
}

export function entryRightsSubscriptionCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryRightsSubscriptionCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryRightsSubscriptionCorporateActionGeneralInformation$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'EntryRightsSubscriptionCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const RightsSubscription$inboundSchema: z.ZodType<
  RightsSubscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryRightsSubscriptionCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
  });
});

/** @internal */
export type RightsSubscription$Outbound = {
  corporate_action_general_information?:
    | EntryRightsSubscriptionCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
};

/** @internal */
export const RightsSubscription$outboundSchema: z.ZodType<
  RightsSubscription$Outbound,
  z.ZodTypeDef,
  RightsSubscription
> = z.object({
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryRightsSubscriptionCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RightsSubscription$ {
  /** @deprecated use `RightsSubscription$inboundSchema` instead. */
  export const inboundSchema = RightsSubscription$inboundSchema;
  /** @deprecated use `RightsSubscription$outboundSchema` instead. */
  export const outboundSchema = RightsSubscription$outboundSchema;
  /** @deprecated use `RightsSubscription$Outbound` instead. */
  export type Outbound = RightsSubscription$Outbound;
}

export function rightsSubscriptionToJSON(
  rightsSubscription: RightsSubscription,
): string {
  return JSON.stringify(
    RightsSubscription$outboundSchema.parse(rightsSubscription),
  );
}

export function rightsSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<RightsSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RightsSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RightsSubscription' from JSON`,
  );
}

/** @internal */
export const RoundingAdjustment$inboundSchema: z.ZodType<
  RoundingAdjustment,
  z.ZodTypeDef,
  unknown
> = z.object({
  rounding_reason: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "rounding_reason": "roundingReason",
  });
});

/** @internal */
export type RoundingAdjustment$Outbound = {
  rounding_reason?: string | undefined;
};

/** @internal */
export const RoundingAdjustment$outboundSchema: z.ZodType<
  RoundingAdjustment$Outbound,
  z.ZodTypeDef,
  RoundingAdjustment
> = z.object({
  roundingReason: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    roundingReason: "rounding_reason",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RoundingAdjustment$ {
  /** @deprecated use `RoundingAdjustment$inboundSchema` instead. */
  export const inboundSchema = RoundingAdjustment$inboundSchema;
  /** @deprecated use `RoundingAdjustment$outboundSchema` instead. */
  export const outboundSchema = RoundingAdjustment$outboundSchema;
  /** @deprecated use `RoundingAdjustment$Outbound` instead. */
  export type Outbound = RoundingAdjustment$Outbound;
}

export function roundingAdjustmentToJSON(
  roundingAdjustment: RoundingAdjustment,
): string {
  return JSON.stringify(
    RoundingAdjustment$outboundSchema.parse(roundingAdjustment),
  );
}

export function roundingAdjustmentFromJSON(
  jsonString: string,
): SafeParseResult<RoundingAdjustment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RoundingAdjustment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RoundingAdjustment' from JSON`,
  );
}

/** @internal */
export const EntrySaleOfRightsCashRate$inboundSchema: z.ZodType<
  EntrySaleOfRightsCashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntrySaleOfRightsCashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntrySaleOfRightsCashRate$outboundSchema: z.ZodType<
  EntrySaleOfRightsCashRate$Outbound,
  z.ZodTypeDef,
  EntrySaleOfRightsCashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySaleOfRightsCashRate$ {
  /** @deprecated use `EntrySaleOfRightsCashRate$inboundSchema` instead. */
  export const inboundSchema = EntrySaleOfRightsCashRate$inboundSchema;
  /** @deprecated use `EntrySaleOfRightsCashRate$outboundSchema` instead. */
  export const outboundSchema = EntrySaleOfRightsCashRate$outboundSchema;
  /** @deprecated use `EntrySaleOfRightsCashRate$Outbound` instead. */
  export type Outbound = EntrySaleOfRightsCashRate$Outbound;
}

export function entrySaleOfRightsCashRateToJSON(
  entrySaleOfRightsCashRate: EntrySaleOfRightsCashRate,
): string {
  return JSON.stringify(
    EntrySaleOfRightsCashRate$outboundSchema.parse(entrySaleOfRightsCashRate),
  );
}

export function entrySaleOfRightsCashRateFromJSON(
  jsonString: string,
): SafeParseResult<EntrySaleOfRightsCashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntrySaleOfRightsCashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntrySaleOfRightsCashRate' from JSON`,
  );
}

/** @internal */
export const EntrySaleOfRightsCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntrySaleOfRightsCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntrySaleOfRightsCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntrySaleOfRightsCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntrySaleOfRightsCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntrySaleOfRightsCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySaleOfRightsCorporateActionGeneralInformation$ {
  /** @deprecated use `EntrySaleOfRightsCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntrySaleOfRightsCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntrySaleOfRightsCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntrySaleOfRightsCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntrySaleOfRightsCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntrySaleOfRightsCorporateActionGeneralInformation$Outbound;
}

export function entrySaleOfRightsCorporateActionGeneralInformationToJSON(
  entrySaleOfRightsCorporateActionGeneralInformation:
    EntrySaleOfRightsCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntrySaleOfRightsCorporateActionGeneralInformation$outboundSchema.parse(
      entrySaleOfRightsCorporateActionGeneralInformation,
    ),
  );
}

export function entrySaleOfRightsCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntrySaleOfRightsCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntrySaleOfRightsCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntrySaleOfRightsCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntrySaleOfRightsPaymentDate$inboundSchema: z.ZodType<
  EntrySaleOfRightsPaymentDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntrySaleOfRightsPaymentDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntrySaleOfRightsPaymentDate$outboundSchema: z.ZodType<
  EntrySaleOfRightsPaymentDate$Outbound,
  z.ZodTypeDef,
  EntrySaleOfRightsPaymentDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySaleOfRightsPaymentDate$ {
  /** @deprecated use `EntrySaleOfRightsPaymentDate$inboundSchema` instead. */
  export const inboundSchema = EntrySaleOfRightsPaymentDate$inboundSchema;
  /** @deprecated use `EntrySaleOfRightsPaymentDate$outboundSchema` instead. */
  export const outboundSchema = EntrySaleOfRightsPaymentDate$outboundSchema;
  /** @deprecated use `EntrySaleOfRightsPaymentDate$Outbound` instead. */
  export type Outbound = EntrySaleOfRightsPaymentDate$Outbound;
}

export function entrySaleOfRightsPaymentDateToJSON(
  entrySaleOfRightsPaymentDate: EntrySaleOfRightsPaymentDate,
): string {
  return JSON.stringify(
    EntrySaleOfRightsPaymentDate$outboundSchema.parse(
      entrySaleOfRightsPaymentDate,
    ),
  );
}

export function entrySaleOfRightsPaymentDateFromJSON(
  jsonString: string,
): SafeParseResult<EntrySaleOfRightsPaymentDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntrySaleOfRightsPaymentDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntrySaleOfRightsPaymentDate' from JSON`,
  );
}

/** @internal */
export const EntrySaleOfRightsRecordDate$inboundSchema: z.ZodType<
  EntrySaleOfRightsRecordDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntrySaleOfRightsRecordDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntrySaleOfRightsRecordDate$outboundSchema: z.ZodType<
  EntrySaleOfRightsRecordDate$Outbound,
  z.ZodTypeDef,
  EntrySaleOfRightsRecordDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySaleOfRightsRecordDate$ {
  /** @deprecated use `EntrySaleOfRightsRecordDate$inboundSchema` instead. */
  export const inboundSchema = EntrySaleOfRightsRecordDate$inboundSchema;
  /** @deprecated use `EntrySaleOfRightsRecordDate$outboundSchema` instead. */
  export const outboundSchema = EntrySaleOfRightsRecordDate$outboundSchema;
  /** @deprecated use `EntrySaleOfRightsRecordDate$Outbound` instead. */
  export type Outbound = EntrySaleOfRightsRecordDate$Outbound;
}

export function entrySaleOfRightsRecordDateToJSON(
  entrySaleOfRightsRecordDate: EntrySaleOfRightsRecordDate,
): string {
  return JSON.stringify(
    EntrySaleOfRightsRecordDate$outboundSchema.parse(
      entrySaleOfRightsRecordDate,
    ),
  );
}

export function entrySaleOfRightsRecordDateFromJSON(
  jsonString: string,
): SafeParseResult<EntrySaleOfRightsRecordDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntrySaleOfRightsRecordDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntrySaleOfRightsRecordDate' from JSON`,
  );
}

/** @internal */
export const EntrySaleOfRightsSettled$inboundSchema: z.ZodType<
  EntrySaleOfRightsSettled,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntrySaleOfRightsSettled$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntrySaleOfRightsSettled$outboundSchema: z.ZodType<
  EntrySaleOfRightsSettled$Outbound,
  z.ZodTypeDef,
  EntrySaleOfRightsSettled
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySaleOfRightsSettled$ {
  /** @deprecated use `EntrySaleOfRightsSettled$inboundSchema` instead. */
  export const inboundSchema = EntrySaleOfRightsSettled$inboundSchema;
  /** @deprecated use `EntrySaleOfRightsSettled$outboundSchema` instead. */
  export const outboundSchema = EntrySaleOfRightsSettled$outboundSchema;
  /** @deprecated use `EntrySaleOfRightsSettled$Outbound` instead. */
  export type Outbound = EntrySaleOfRightsSettled$Outbound;
}

export function entrySaleOfRightsSettledToJSON(
  entrySaleOfRightsSettled: EntrySaleOfRightsSettled,
): string {
  return JSON.stringify(
    EntrySaleOfRightsSettled$outboundSchema.parse(entrySaleOfRightsSettled),
  );
}

export function entrySaleOfRightsSettledFromJSON(
  jsonString: string,
): SafeParseResult<EntrySaleOfRightsSettled, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntrySaleOfRightsSettled$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntrySaleOfRightsSettled' from JSON`,
  );
}

/** @internal */
export const SaleOfRights$inboundSchema: z.ZodType<
  SaleOfRights,
  z.ZodTypeDef,
  unknown
> = z.object({
  cash_rate: z.nullable(z.lazy(() => EntrySaleOfRightsCashRate$inboundSchema))
    .optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntrySaleOfRightsCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  payment_date: z.nullable(
    z.lazy(() => EntrySaleOfRightsPaymentDate$inboundSchema),
  ).optional(),
  record_date: z.nullable(
    z.lazy(() => EntrySaleOfRightsRecordDate$inboundSchema),
  ).optional(),
  settled: z.nullable(z.lazy(() => EntrySaleOfRightsSettled$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "cash_rate": "cashRate",
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "payment_date": "paymentDate",
    "record_date": "recordDate",
  });
});

/** @internal */
export type SaleOfRights$Outbound = {
  cash_rate?: EntrySaleOfRightsCashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntrySaleOfRightsCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  payment_date?: EntrySaleOfRightsPaymentDate$Outbound | null | undefined;
  record_date?: EntrySaleOfRightsRecordDate$Outbound | null | undefined;
  settled?: EntrySaleOfRightsSettled$Outbound | null | undefined;
};

/** @internal */
export const SaleOfRights$outboundSchema: z.ZodType<
  SaleOfRights$Outbound,
  z.ZodTypeDef,
  SaleOfRights
> = z.object({
  cashRate: z.nullable(z.lazy(() => EntrySaleOfRightsCashRate$outboundSchema))
    .optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntrySaleOfRightsCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  paymentDate: z.nullable(
    z.lazy(() => EntrySaleOfRightsPaymentDate$outboundSchema),
  ).optional(),
  recordDate: z.nullable(
    z.lazy(() => EntrySaleOfRightsRecordDate$outboundSchema),
  ).optional(),
  settled: z.nullable(z.lazy(() => EntrySaleOfRightsSettled$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    paymentDate: "payment_date",
    recordDate: "record_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SaleOfRights$ {
  /** @deprecated use `SaleOfRights$inboundSchema` instead. */
  export const inboundSchema = SaleOfRights$inboundSchema;
  /** @deprecated use `SaleOfRights$outboundSchema` instead. */
  export const outboundSchema = SaleOfRights$outboundSchema;
  /** @deprecated use `SaleOfRights$Outbound` instead. */
  export type Outbound = SaleOfRights$Outbound;
}

export function saleOfRightsToJSON(saleOfRights: SaleOfRights): string {
  return JSON.stringify(SaleOfRights$outboundSchema.parse(saleOfRights));
}

export function saleOfRightsFromJSON(
  jsonString: string,
): SafeParseResult<SaleOfRights, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SaleOfRights$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SaleOfRights' from JSON`,
  );
}

/** @internal */
export const SettleDate$inboundSchema: z.ZodType<
  SettleDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type SettleDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const SettleDate$outboundSchema: z.ZodType<
  SettleDate$Outbound,
  z.ZodTypeDef,
  SettleDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SettleDate$ {
  /** @deprecated use `SettleDate$inboundSchema` instead. */
  export const inboundSchema = SettleDate$inboundSchema;
  /** @deprecated use `SettleDate$outboundSchema` instead. */
  export const outboundSchema = SettleDate$outboundSchema;
  /** @deprecated use `SettleDate$Outbound` instead. */
  export type Outbound = SettleDate$Outbound;
}

export function settleDateToJSON(settleDate: SettleDate): string {
  return JSON.stringify(SettleDate$outboundSchema.parse(settleDate));
}

export function settleDateFromJSON(
  jsonString: string,
): SafeParseResult<SettleDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SettleDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SettleDate' from JSON`,
  );
}

/** @internal */
export const EntrySide$inboundSchema: z.ZodType<
  EntrySideOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntrySide),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntrySide$outboundSchema: z.ZodType<
  EntrySideOpen,
  z.ZodTypeDef,
  EntrySideOpen
> = z.union([
  z.nativeEnum(EntrySide),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySide$ {
  /** @deprecated use `EntrySide$inboundSchema` instead. */
  export const inboundSchema = EntrySide$inboundSchema;
  /** @deprecated use `EntrySide$outboundSchema` instead. */
  export const outboundSchema = EntrySide$outboundSchema;
}

/** @internal */
export const EntrySideModifier$inboundSchema: z.ZodType<
  EntrySideModifierOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntrySideModifier),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntrySideModifier$outboundSchema: z.ZodType<
  EntrySideModifierOpen,
  z.ZodTypeDef,
  EntrySideModifierOpen
> = z.union([
  z.nativeEnum(EntrySideModifier),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySideModifier$ {
  /** @deprecated use `EntrySideModifier$inboundSchema` instead. */
  export const inboundSchema = EntrySideModifier$inboundSchema;
  /** @deprecated use `EntrySideModifier$outboundSchema` instead. */
  export const outboundSchema = EntrySideModifier$outboundSchema;
}

/** @internal */
export const EntrySpinOffCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntrySpinOffCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntrySpinOffCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntrySpinOffCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntrySpinOffCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntrySpinOffCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySpinOffCorporateActionGeneralInformation$ {
  /** @deprecated use `EntrySpinOffCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntrySpinOffCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntrySpinOffCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntrySpinOffCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntrySpinOffCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound = EntrySpinOffCorporateActionGeneralInformation$Outbound;
}

export function entrySpinOffCorporateActionGeneralInformationToJSON(
  entrySpinOffCorporateActionGeneralInformation:
    EntrySpinOffCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntrySpinOffCorporateActionGeneralInformation$outboundSchema.parse(
      entrySpinOffCorporateActionGeneralInformation,
    ),
  );
}

export function entrySpinOffCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntrySpinOffCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntrySpinOffCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntrySpinOffCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const PayDate$inboundSchema: z.ZodType<PayDate, z.ZodTypeDef, unknown> =
  z.object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
  });

/** @internal */
export type PayDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const PayDate$outboundSchema: z.ZodType<
  PayDate$Outbound,
  z.ZodTypeDef,
  PayDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PayDate$ {
  /** @deprecated use `PayDate$inboundSchema` instead. */
  export const inboundSchema = PayDate$inboundSchema;
  /** @deprecated use `PayDate$outboundSchema` instead. */
  export const outboundSchema = PayDate$outboundSchema;
  /** @deprecated use `PayDate$Outbound` instead. */
  export type Outbound = PayDate$Outbound;
}

export function payDateToJSON(payDate: PayDate): string {
  return JSON.stringify(PayDate$outboundSchema.parse(payDate));
}

export function payDateFromJSON(
  jsonString: string,
): SafeParseResult<PayDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayDate' from JSON`,
  );
}

/** @internal */
export const EntrySpinOffQuantity$inboundSchema: z.ZodType<
  EntrySpinOffQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntrySpinOffQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntrySpinOffQuantity$outboundSchema: z.ZodType<
  EntrySpinOffQuantity$Outbound,
  z.ZodTypeDef,
  EntrySpinOffQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySpinOffQuantity$ {
  /** @deprecated use `EntrySpinOffQuantity$inboundSchema` instead. */
  export const inboundSchema = EntrySpinOffQuantity$inboundSchema;
  /** @deprecated use `EntrySpinOffQuantity$outboundSchema` instead. */
  export const outboundSchema = EntrySpinOffQuantity$outboundSchema;
  /** @deprecated use `EntrySpinOffQuantity$Outbound` instead. */
  export type Outbound = EntrySpinOffQuantity$Outbound;
}

export function entrySpinOffQuantityToJSON(
  entrySpinOffQuantity: EntrySpinOffQuantity,
): string {
  return JSON.stringify(
    EntrySpinOffQuantity$outboundSchema.parse(entrySpinOffQuantity),
  );
}

export function entrySpinOffQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntrySpinOffQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntrySpinOffQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntrySpinOffQuantity' from JSON`,
  );
}

/** @internal */
export const EntrySpinOffRate$inboundSchema: z.ZodType<
  EntrySpinOffRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntrySpinOffRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntrySpinOffRate$outboundSchema: z.ZodType<
  EntrySpinOffRate$Outbound,
  z.ZodTypeDef,
  EntrySpinOffRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySpinOffRate$ {
  /** @deprecated use `EntrySpinOffRate$inboundSchema` instead. */
  export const inboundSchema = EntrySpinOffRate$inboundSchema;
  /** @deprecated use `EntrySpinOffRate$outboundSchema` instead. */
  export const outboundSchema = EntrySpinOffRate$outboundSchema;
  /** @deprecated use `EntrySpinOffRate$Outbound` instead. */
  export type Outbound = EntrySpinOffRate$Outbound;
}

export function entrySpinOffRateToJSON(
  entrySpinOffRate: EntrySpinOffRate,
): string {
  return JSON.stringify(
    EntrySpinOffRate$outboundSchema.parse(entrySpinOffRate),
  );
}

export function entrySpinOffRateFromJSON(
  jsonString: string,
): SafeParseResult<EntrySpinOffRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntrySpinOffRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntrySpinOffRate' from JSON`,
  );
}

/** @internal */
export const EntrySpinOffRecordDate$inboundSchema: z.ZodType<
  EntrySpinOffRecordDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntrySpinOffRecordDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntrySpinOffRecordDate$outboundSchema: z.ZodType<
  EntrySpinOffRecordDate$Outbound,
  z.ZodTypeDef,
  EntrySpinOffRecordDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySpinOffRecordDate$ {
  /** @deprecated use `EntrySpinOffRecordDate$inboundSchema` instead. */
  export const inboundSchema = EntrySpinOffRecordDate$inboundSchema;
  /** @deprecated use `EntrySpinOffRecordDate$outboundSchema` instead. */
  export const outboundSchema = EntrySpinOffRecordDate$outboundSchema;
  /** @deprecated use `EntrySpinOffRecordDate$Outbound` instead. */
  export type Outbound = EntrySpinOffRecordDate$Outbound;
}

export function entrySpinOffRecordDateToJSON(
  entrySpinOffRecordDate: EntrySpinOffRecordDate,
): string {
  return JSON.stringify(
    EntrySpinOffRecordDate$outboundSchema.parse(entrySpinOffRecordDate),
  );
}

export function entrySpinOffRecordDateFromJSON(
  jsonString: string,
): SafeParseResult<EntrySpinOffRecordDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntrySpinOffRecordDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntrySpinOffRecordDate' from JSON`,
  );
}

/** @internal */
export const SpinOff$inboundSchema: z.ZodType<SpinOff, z.ZodTypeDef, unknown> =
  z.object({
    corporate_action_general_information: z.nullable(
      z.lazy(() => EntrySpinOffCorporateActionGeneralInformation$inboundSchema),
    ).optional(),
    pay_date: z.nullable(z.lazy(() => PayDate$inboundSchema)).optional(),
    quantity: z.nullable(z.lazy(() => EntrySpinOffQuantity$inboundSchema))
      .optional(),
    rate: z.nullable(z.lazy(() => EntrySpinOffRate$inboundSchema)).optional(),
    record_date: z.nullable(z.lazy(() => EntrySpinOffRecordDate$inboundSchema))
      .optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_general_information":
        "corporateActionGeneralInformation",
      "pay_date": "payDate",
      "record_date": "recordDate",
    });
  });

/** @internal */
export type SpinOff$Outbound = {
  corporate_action_general_information?:
    | EntrySpinOffCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  pay_date?: PayDate$Outbound | null | undefined;
  quantity?: EntrySpinOffQuantity$Outbound | null | undefined;
  rate?: EntrySpinOffRate$Outbound | null | undefined;
  record_date?: EntrySpinOffRecordDate$Outbound | null | undefined;
};

/** @internal */
export const SpinOff$outboundSchema: z.ZodType<
  SpinOff$Outbound,
  z.ZodTypeDef,
  SpinOff
> = z.object({
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() => EntrySpinOffCorporateActionGeneralInformation$outboundSchema),
  ).optional(),
  payDate: z.nullable(z.lazy(() => PayDate$outboundSchema)).optional(),
  quantity: z.nullable(z.lazy(() => EntrySpinOffQuantity$outboundSchema))
    .optional(),
  rate: z.nullable(z.lazy(() => EntrySpinOffRate$outboundSchema)).optional(),
  recordDate: z.nullable(z.lazy(() => EntrySpinOffRecordDate$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
    payDate: "pay_date",
    recordDate: "record_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SpinOff$ {
  /** @deprecated use `SpinOff$inboundSchema` instead. */
  export const inboundSchema = SpinOff$inboundSchema;
  /** @deprecated use `SpinOff$outboundSchema` instead. */
  export const outboundSchema = SpinOff$outboundSchema;
  /** @deprecated use `SpinOff$Outbound` instead. */
  export type Outbound = SpinOff$Outbound;
}

export function spinOffToJSON(spinOff: SpinOff): string {
  return JSON.stringify(SpinOff$outboundSchema.parse(spinOff));
}

export function spinOffFromJSON(
  jsonString: string,
): SafeParseResult<SpinOff, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SpinOff$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SpinOff' from JSON`,
  );
}

/** @internal */
export const EntryState$inboundSchema: z.ZodType<
  EntryStateOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryState),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryState$outboundSchema: z.ZodType<
  EntryStateOpen,
  z.ZodTypeDef,
  EntryStateOpen
> = z.union([
  z.nativeEnum(EntryState),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryState$ {
  /** @deprecated use `EntryState$inboundSchema` instead. */
  export const inboundSchema = EntryState$inboundSchema;
  /** @deprecated use `EntryState$outboundSchema` instead. */
  export const outboundSchema = EntryState$outboundSchema;
}

/** @internal */
export const EntryStockDividendCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryStockDividendCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryStockDividendCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryStockDividendCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryStockDividendCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryStockDividendCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryStockDividendCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryStockDividendCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryStockDividendCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryStockDividendCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryStockDividendCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryStockDividendCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryStockDividendCorporateActionGeneralInformation$Outbound;
}

export function entryStockDividendCorporateActionGeneralInformationToJSON(
  entryStockDividendCorporateActionGeneralInformation:
    EntryStockDividendCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryStockDividendCorporateActionGeneralInformation$outboundSchema.parse(
      entryStockDividendCorporateActionGeneralInformation,
    ),
  );
}

export function entryStockDividendCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryStockDividendCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryStockDividendCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryStockDividendCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryPayDate$inboundSchema: z.ZodType<
  EntryPayDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryPayDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryPayDate$outboundSchema: z.ZodType<
  EntryPayDate$Outbound,
  z.ZodTypeDef,
  EntryPayDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPayDate$ {
  /** @deprecated use `EntryPayDate$inboundSchema` instead. */
  export const inboundSchema = EntryPayDate$inboundSchema;
  /** @deprecated use `EntryPayDate$outboundSchema` instead. */
  export const outboundSchema = EntryPayDate$outboundSchema;
  /** @deprecated use `EntryPayDate$Outbound` instead. */
  export type Outbound = EntryPayDate$Outbound;
}

export function entryPayDateToJSON(entryPayDate: EntryPayDate): string {
  return JSON.stringify(EntryPayDate$outboundSchema.parse(entryPayDate));
}

export function entryPayDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryPayDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryPayDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryPayDate' from JSON`,
  );
}

/** @internal */
export const EntryStockDividendQuantity$inboundSchema: z.ZodType<
  EntryStockDividendQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryStockDividendQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryStockDividendQuantity$outboundSchema: z.ZodType<
  EntryStockDividendQuantity$Outbound,
  z.ZodTypeDef,
  EntryStockDividendQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryStockDividendQuantity$ {
  /** @deprecated use `EntryStockDividendQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryStockDividendQuantity$inboundSchema;
  /** @deprecated use `EntryStockDividendQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryStockDividendQuantity$outboundSchema;
  /** @deprecated use `EntryStockDividendQuantity$Outbound` instead. */
  export type Outbound = EntryStockDividendQuantity$Outbound;
}

export function entryStockDividendQuantityToJSON(
  entryStockDividendQuantity: EntryStockDividendQuantity,
): string {
  return JSON.stringify(
    EntryStockDividendQuantity$outboundSchema.parse(entryStockDividendQuantity),
  );
}

export function entryStockDividendQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryStockDividendQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryStockDividendQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryStockDividendQuantity' from JSON`,
  );
}

/** @internal */
export const EntryRate$inboundSchema: z.ZodType<
  EntryRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryRate$outboundSchema: z.ZodType<
  EntryRate$Outbound,
  z.ZodTypeDef,
  EntryRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryRate$ {
  /** @deprecated use `EntryRate$inboundSchema` instead. */
  export const inboundSchema = EntryRate$inboundSchema;
  /** @deprecated use `EntryRate$outboundSchema` instead. */
  export const outboundSchema = EntryRate$outboundSchema;
  /** @deprecated use `EntryRate$Outbound` instead. */
  export type Outbound = EntryRate$Outbound;
}

export function entryRateToJSON(entryRate: EntryRate): string {
  return JSON.stringify(EntryRate$outboundSchema.parse(entryRate));
}

export function entryRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryRate' from JSON`,
  );
}

/** @internal */
export const EntryStockDividendRecordDate$inboundSchema: z.ZodType<
  EntryStockDividendRecordDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryStockDividendRecordDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryStockDividendRecordDate$outboundSchema: z.ZodType<
  EntryStockDividendRecordDate$Outbound,
  z.ZodTypeDef,
  EntryStockDividendRecordDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryStockDividendRecordDate$ {
  /** @deprecated use `EntryStockDividendRecordDate$inboundSchema` instead. */
  export const inboundSchema = EntryStockDividendRecordDate$inboundSchema;
  /** @deprecated use `EntryStockDividendRecordDate$outboundSchema` instead. */
  export const outboundSchema = EntryStockDividendRecordDate$outboundSchema;
  /** @deprecated use `EntryStockDividendRecordDate$Outbound` instead. */
  export type Outbound = EntryStockDividendRecordDate$Outbound;
}

export function entryStockDividendRecordDateToJSON(
  entryStockDividendRecordDate: EntryStockDividendRecordDate,
): string {
  return JSON.stringify(
    EntryStockDividendRecordDate$outboundSchema.parse(
      entryStockDividendRecordDate,
    ),
  );
}

export function entryStockDividendRecordDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryStockDividendRecordDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryStockDividendRecordDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryStockDividendRecordDate' from JSON`,
  );
}

/** @internal */
export const StockDividend$inboundSchema: z.ZodType<
  StockDividend,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryStockDividendCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  pay_date: z.nullable(z.lazy(() => EntryPayDate$inboundSchema)).optional(),
  quantity: z.nullable(z.lazy(() => EntryStockDividendQuantity$inboundSchema))
    .optional(),
  rate: z.nullable(z.lazy(() => EntryRate$inboundSchema)).optional(),
  record_date: z.nullable(
    z.lazy(() => EntryStockDividendRecordDate$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "pay_date": "payDate",
    "record_date": "recordDate",
  });
});

/** @internal */
export type StockDividend$Outbound = {
  corporate_action_general_information?:
    | EntryStockDividendCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  pay_date?: EntryPayDate$Outbound | null | undefined;
  quantity?: EntryStockDividendQuantity$Outbound | null | undefined;
  rate?: EntryRate$Outbound | null | undefined;
  record_date?: EntryStockDividendRecordDate$Outbound | null | undefined;
};

/** @internal */
export const StockDividend$outboundSchema: z.ZodType<
  StockDividend$Outbound,
  z.ZodTypeDef,
  StockDividend
> = z.object({
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryStockDividendCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  payDate: z.nullable(z.lazy(() => EntryPayDate$outboundSchema)).optional(),
  quantity: z.nullable(z.lazy(() => EntryStockDividendQuantity$outboundSchema))
    .optional(),
  rate: z.nullable(z.lazy(() => EntryRate$outboundSchema)).optional(),
  recordDate: z.nullable(
    z.lazy(() => EntryStockDividendRecordDate$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
    payDate: "pay_date",
    recordDate: "record_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StockDividend$ {
  /** @deprecated use `StockDividend$inboundSchema` instead. */
  export const inboundSchema = StockDividend$inboundSchema;
  /** @deprecated use `StockDividend$outboundSchema` instead. */
  export const outboundSchema = StockDividend$outboundSchema;
  /** @deprecated use `StockDividend$Outbound` instead. */
  export type Outbound = StockDividend$Outbound;
}

export function stockDividendToJSON(stockDividend: StockDividend): string {
  return JSON.stringify(StockDividend$outboundSchema.parse(stockDividend));
}

export function stockDividendFromJSON(
  jsonString: string,
): SafeParseResult<StockDividend, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StockDividend$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StockDividend' from JSON`,
  );
}

/** @internal */
export const EntryStockSplitCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryStockSplitCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryStockSplitCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryStockSplitCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryStockSplitCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryStockSplitCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryStockSplitCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryStockSplitCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryStockSplitCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryStockSplitCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryStockSplitCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryStockSplitCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryStockSplitCorporateActionGeneralInformation$Outbound;
}

export function entryStockSplitCorporateActionGeneralInformationToJSON(
  entryStockSplitCorporateActionGeneralInformation:
    EntryStockSplitCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryStockSplitCorporateActionGeneralInformation$outboundSchema.parse(
      entryStockSplitCorporateActionGeneralInformation,
    ),
  );
}

export function entryStockSplitCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryStockSplitCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryStockSplitCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryStockSplitCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryFactorDenominator$inboundSchema: z.ZodType<
  EntryFactorDenominator,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryFactorDenominator$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryFactorDenominator$outboundSchema: z.ZodType<
  EntryFactorDenominator$Outbound,
  z.ZodTypeDef,
  EntryFactorDenominator
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFactorDenominator$ {
  /** @deprecated use `EntryFactorDenominator$inboundSchema` instead. */
  export const inboundSchema = EntryFactorDenominator$inboundSchema;
  /** @deprecated use `EntryFactorDenominator$outboundSchema` instead. */
  export const outboundSchema = EntryFactorDenominator$outboundSchema;
  /** @deprecated use `EntryFactorDenominator$Outbound` instead. */
  export type Outbound = EntryFactorDenominator$Outbound;
}

export function entryFactorDenominatorToJSON(
  entryFactorDenominator: EntryFactorDenominator,
): string {
  return JSON.stringify(
    EntryFactorDenominator$outboundSchema.parse(entryFactorDenominator),
  );
}

export function entryFactorDenominatorFromJSON(
  jsonString: string,
): SafeParseResult<EntryFactorDenominator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryFactorDenominator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryFactorDenominator' from JSON`,
  );
}

/** @internal */
export const EntryFactorNumerator$inboundSchema: z.ZodType<
  EntryFactorNumerator,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryFactorNumerator$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryFactorNumerator$outboundSchema: z.ZodType<
  EntryFactorNumerator$Outbound,
  z.ZodTypeDef,
  EntryFactorNumerator
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryFactorNumerator$ {
  /** @deprecated use `EntryFactorNumerator$inboundSchema` instead. */
  export const inboundSchema = EntryFactorNumerator$inboundSchema;
  /** @deprecated use `EntryFactorNumerator$outboundSchema` instead. */
  export const outboundSchema = EntryFactorNumerator$outboundSchema;
  /** @deprecated use `EntryFactorNumerator$Outbound` instead. */
  export type Outbound = EntryFactorNumerator$Outbound;
}

export function entryFactorNumeratorToJSON(
  entryFactorNumerator: EntryFactorNumerator,
): string {
  return JSON.stringify(
    EntryFactorNumerator$outboundSchema.parse(entryFactorNumerator),
  );
}

export function entryFactorNumeratorFromJSON(
  jsonString: string,
): SafeParseResult<EntryFactorNumerator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryFactorNumerator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryFactorNumerator' from JSON`,
  );
}

/** @internal */
export const EntryStockSplitPayDate$inboundSchema: z.ZodType<
  EntryStockSplitPayDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryStockSplitPayDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryStockSplitPayDate$outboundSchema: z.ZodType<
  EntryStockSplitPayDate$Outbound,
  z.ZodTypeDef,
  EntryStockSplitPayDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryStockSplitPayDate$ {
  /** @deprecated use `EntryStockSplitPayDate$inboundSchema` instead. */
  export const inboundSchema = EntryStockSplitPayDate$inboundSchema;
  /** @deprecated use `EntryStockSplitPayDate$outboundSchema` instead. */
  export const outboundSchema = EntryStockSplitPayDate$outboundSchema;
  /** @deprecated use `EntryStockSplitPayDate$Outbound` instead. */
  export type Outbound = EntryStockSplitPayDate$Outbound;
}

export function entryStockSplitPayDateToJSON(
  entryStockSplitPayDate: EntryStockSplitPayDate,
): string {
  return JSON.stringify(
    EntryStockSplitPayDate$outboundSchema.parse(entryStockSplitPayDate),
  );
}

export function entryStockSplitPayDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryStockSplitPayDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryStockSplitPayDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryStockSplitPayDate' from JSON`,
  );
}

/** @internal */
export const EntryStockSplitQuantity$inboundSchema: z.ZodType<
  EntryStockSplitQuantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryStockSplitQuantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryStockSplitQuantity$outboundSchema: z.ZodType<
  EntryStockSplitQuantity$Outbound,
  z.ZodTypeDef,
  EntryStockSplitQuantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryStockSplitQuantity$ {
  /** @deprecated use `EntryStockSplitQuantity$inboundSchema` instead. */
  export const inboundSchema = EntryStockSplitQuantity$inboundSchema;
  /** @deprecated use `EntryStockSplitQuantity$outboundSchema` instead. */
  export const outboundSchema = EntryStockSplitQuantity$outboundSchema;
  /** @deprecated use `EntryStockSplitQuantity$Outbound` instead. */
  export type Outbound = EntryStockSplitQuantity$Outbound;
}

export function entryStockSplitQuantityToJSON(
  entryStockSplitQuantity: EntryStockSplitQuantity,
): string {
  return JSON.stringify(
    EntryStockSplitQuantity$outboundSchema.parse(entryStockSplitQuantity),
  );
}

export function entryStockSplitQuantityFromJSON(
  jsonString: string,
): SafeParseResult<EntryStockSplitQuantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryStockSplitQuantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryStockSplitQuantity' from JSON`,
  );
}

/** @internal */
export const EntryStockSplitRecordDate$inboundSchema: z.ZodType<
  EntryStockSplitRecordDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryStockSplitRecordDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryStockSplitRecordDate$outboundSchema: z.ZodType<
  EntryStockSplitRecordDate$Outbound,
  z.ZodTypeDef,
  EntryStockSplitRecordDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryStockSplitRecordDate$ {
  /** @deprecated use `EntryStockSplitRecordDate$inboundSchema` instead. */
  export const inboundSchema = EntryStockSplitRecordDate$inboundSchema;
  /** @deprecated use `EntryStockSplitRecordDate$outboundSchema` instead. */
  export const outboundSchema = EntryStockSplitRecordDate$outboundSchema;
  /** @deprecated use `EntryStockSplitRecordDate$Outbound` instead. */
  export type Outbound = EntryStockSplitRecordDate$Outbound;
}

export function entryStockSplitRecordDateToJSON(
  entryStockSplitRecordDate: EntryStockSplitRecordDate,
): string {
  return JSON.stringify(
    EntryStockSplitRecordDate$outboundSchema.parse(entryStockSplitRecordDate),
  );
}

export function entryStockSplitRecordDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryStockSplitRecordDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryStockSplitRecordDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryStockSplitRecordDate' from JSON`,
  );
}

/** @internal */
export const StockSplit$inboundSchema: z.ZodType<
  StockSplit,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryStockSplitCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  factor_denominator: z.nullable(
    z.lazy(() => EntryFactorDenominator$inboundSchema),
  ).optional(),
  factor_numerator: z.nullable(z.lazy(() => EntryFactorNumerator$inboundSchema))
    .optional(),
  pay_date: z.nullable(z.lazy(() => EntryStockSplitPayDate$inboundSchema))
    .optional(),
  quantity: z.nullable(z.lazy(() => EntryStockSplitQuantity$inboundSchema))
    .optional(),
  record_date: z.nullable(z.lazy(() => EntryStockSplitRecordDate$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "factor_denominator": "factorDenominator",
    "factor_numerator": "factorNumerator",
    "pay_date": "payDate",
    "record_date": "recordDate",
  });
});

/** @internal */
export type StockSplit$Outbound = {
  corporate_action_general_information?:
    | EntryStockSplitCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  factor_denominator?: EntryFactorDenominator$Outbound | null | undefined;
  factor_numerator?: EntryFactorNumerator$Outbound | null | undefined;
  pay_date?: EntryStockSplitPayDate$Outbound | null | undefined;
  quantity?: EntryStockSplitQuantity$Outbound | null | undefined;
  record_date?: EntryStockSplitRecordDate$Outbound | null | undefined;
};

/** @internal */
export const StockSplit$outboundSchema: z.ZodType<
  StockSplit$Outbound,
  z.ZodTypeDef,
  StockSplit
> = z.object({
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryStockSplitCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  factorDenominator: z.nullable(
    z.lazy(() => EntryFactorDenominator$outboundSchema),
  ).optional(),
  factorNumerator: z.nullable(z.lazy(() => EntryFactorNumerator$outboundSchema))
    .optional(),
  payDate: z.nullable(z.lazy(() => EntryStockSplitPayDate$outboundSchema))
    .optional(),
  quantity: z.nullable(z.lazy(() => EntryStockSplitQuantity$outboundSchema))
    .optional(),
  recordDate: z.nullable(z.lazy(() => EntryStockSplitRecordDate$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
    factorDenominator: "factor_denominator",
    factorNumerator: "factor_numerator",
    payDate: "pay_date",
    recordDate: "record_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StockSplit$ {
  /** @deprecated use `StockSplit$inboundSchema` instead. */
  export const inboundSchema = StockSplit$inboundSchema;
  /** @deprecated use `StockSplit$outboundSchema` instead. */
  export const outboundSchema = StockSplit$outboundSchema;
  /** @deprecated use `StockSplit$Outbound` instead. */
  export type Outbound = StockSplit$Outbound;
}

export function stockSplitToJSON(stockSplit: StockSplit): string {
  return JSON.stringify(StockSplit$outboundSchema.parse(stockSplit));
}

export function stockSplitFromJSON(
  jsonString: string,
): SafeParseResult<StockSplit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StockSplit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StockSplit' from JSON`,
  );
}

/** @internal */
export const EntrySweepAction$inboundSchema: z.ZodType<
  EntrySweepActionOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntrySweepAction),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntrySweepAction$outboundSchema: z.ZodType<
  EntrySweepActionOpen,
  z.ZodTypeDef,
  EntrySweepActionOpen
> = z.union([
  z.nativeEnum(EntrySweepAction),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySweepAction$ {
  /** @deprecated use `EntrySweepAction$inboundSchema` instead. */
  export const inboundSchema = EntrySweepAction$inboundSchema;
  /** @deprecated use `EntrySweepAction$outboundSchema` instead. */
  export const outboundSchema = EntrySweepAction$outboundSchema;
}

/** @internal */
export const EntrySweepType$inboundSchema: z.ZodType<
  EntrySweepTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntrySweepType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntrySweepType$outboundSchema: z.ZodType<
  EntrySweepTypeOpen,
  z.ZodTypeDef,
  EntrySweepTypeOpen
> = z.union([
  z.nativeEnum(EntrySweepType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntrySweepType$ {
  /** @deprecated use `EntrySweepType$inboundSchema` instead. */
  export const inboundSchema = EntrySweepType$inboundSchema;
  /** @deprecated use `EntrySweepType$outboundSchema` instead. */
  export const outboundSchema = EntrySweepType$outboundSchema;
}

/** @internal */
export const Sweep$inboundSchema: z.ZodType<Sweep, z.ZodTypeDef, unknown> = z
  .object({
    action: EntrySweepAction$inboundSchema.optional(),
    eod_redemption: z.boolean().optional(),
    type: EntrySweepType$inboundSchema.optional(),
  }).transform((v) => {
    return remap$(v, {
      "eod_redemption": "eodRedemption",
    });
  });

/** @internal */
export type Sweep$Outbound = {
  action?: string | undefined;
  eod_redemption?: boolean | undefined;
  type?: string | undefined;
};

/** @internal */
export const Sweep$outboundSchema: z.ZodType<
  Sweep$Outbound,
  z.ZodTypeDef,
  Sweep
> = z.object({
  action: EntrySweepAction$outboundSchema.optional(),
  eodRedemption: z.boolean().optional(),
  type: EntrySweepType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    eodRedemption: "eod_redemption",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Sweep$ {
  /** @deprecated use `Sweep$inboundSchema` instead. */
  export const inboundSchema = Sweep$inboundSchema;
  /** @deprecated use `Sweep$outboundSchema` instead. */
  export const outboundSchema = Sweep$outboundSchema;
  /** @deprecated use `Sweep$Outbound` instead. */
  export type Outbound = Sweep$Outbound;
}

export function sweepToJSON(sweep: Sweep): string {
  return JSON.stringify(Sweep$outboundSchema.parse(sweep));
}

export function sweepFromJSON(
  jsonString: string,
): SafeParseResult<Sweep, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Sweep$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Sweep' from JSON`,
  );
}

/** @internal */
export const EntryTenderOfferCashRate$inboundSchema: z.ZodType<
  EntryTenderOfferCashRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryTenderOfferCashRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryTenderOfferCashRate$outboundSchema: z.ZodType<
  EntryTenderOfferCashRate$Outbound,
  z.ZodTypeDef,
  EntryTenderOfferCashRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryTenderOfferCashRate$ {
  /** @deprecated use `EntryTenderOfferCashRate$inboundSchema` instead. */
  export const inboundSchema = EntryTenderOfferCashRate$inboundSchema;
  /** @deprecated use `EntryTenderOfferCashRate$outboundSchema` instead. */
  export const outboundSchema = EntryTenderOfferCashRate$outboundSchema;
  /** @deprecated use `EntryTenderOfferCashRate$Outbound` instead. */
  export type Outbound = EntryTenderOfferCashRate$Outbound;
}

export function entryTenderOfferCashRateToJSON(
  entryTenderOfferCashRate: EntryTenderOfferCashRate,
): string {
  return JSON.stringify(
    EntryTenderOfferCashRate$outboundSchema.parse(entryTenderOfferCashRate),
  );
}

export function entryTenderOfferCashRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryTenderOfferCashRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryTenderOfferCashRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryTenderOfferCashRate' from JSON`,
  );
}

/** @internal */
export const EntryTenderOfferCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryTenderOfferCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryTenderOfferCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryTenderOfferCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryTenderOfferCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryTenderOfferCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryTenderOfferCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryTenderOfferCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryTenderOfferCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryTenderOfferCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryTenderOfferCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryTenderOfferCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryTenderOfferCorporateActionGeneralInformation$Outbound;
}

export function entryTenderOfferCorporateActionGeneralInformationToJSON(
  entryTenderOfferCorporateActionGeneralInformation:
    EntryTenderOfferCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryTenderOfferCorporateActionGeneralInformation$outboundSchema.parse(
      entryTenderOfferCorporateActionGeneralInformation,
    ),
  );
}

export function entryTenderOfferCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryTenderOfferCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryTenderOfferCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryTenderOfferCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const TenderOfferType$inboundSchema: z.ZodType<
  TenderOfferTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TenderOfferType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const TenderOfferType$outboundSchema: z.ZodType<
  TenderOfferTypeOpen,
  z.ZodTypeDef,
  TenderOfferTypeOpen
> = z.union([
  z.nativeEnum(TenderOfferType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TenderOfferType$ {
  /** @deprecated use `TenderOfferType$inboundSchema` instead. */
  export const inboundSchema = TenderOfferType$inboundSchema;
  /** @deprecated use `TenderOfferType$outboundSchema` instead. */
  export const outboundSchema = TenderOfferType$outboundSchema;
}

/** @internal */
export const TenderOffer$inboundSchema: z.ZodType<
  TenderOffer,
  z.ZodTypeDef,
  unknown
> = z.object({
  cash_rate: z.nullable(z.lazy(() => EntryTenderOfferCashRate$inboundSchema))
    .optional(),
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryTenderOfferCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
  tender_offer_type: TenderOfferType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "cash_rate": "cashRate",
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "tender_offer_type": "tenderOfferType",
  });
});

/** @internal */
export type TenderOffer$Outbound = {
  cash_rate?: EntryTenderOfferCashRate$Outbound | null | undefined;
  corporate_action_general_information?:
    | EntryTenderOfferCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  tender_offer_type?: string | undefined;
};

/** @internal */
export const TenderOffer$outboundSchema: z.ZodType<
  TenderOffer$Outbound,
  z.ZodTypeDef,
  TenderOffer
> = z.object({
  cashRate: z.nullable(z.lazy(() => EntryTenderOfferCashRate$outboundSchema))
    .optional(),
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryTenderOfferCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  tenderOfferType: TenderOfferType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    cashRate: "cash_rate",
    corporateActionGeneralInformation: "corporate_action_general_information",
    tenderOfferType: "tender_offer_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TenderOffer$ {
  /** @deprecated use `TenderOffer$inboundSchema` instead. */
  export const inboundSchema = TenderOffer$inboundSchema;
  /** @deprecated use `TenderOffer$outboundSchema` instead. */
  export const outboundSchema = TenderOffer$outboundSchema;
  /** @deprecated use `TenderOffer$Outbound` instead. */
  export type Outbound = TenderOffer$Outbound;
}

export function tenderOfferToJSON(tenderOffer: TenderOffer): string {
  return JSON.stringify(TenderOffer$outboundSchema.parse(tenderOffer));
}

export function tenderOfferFromJSON(
  jsonString: string,
): SafeParseResult<TenderOffer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TenderOffer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TenderOffer' from JSON`,
  );
}

/** @internal */
export const EntryTradeBrokerCapacity$inboundSchema: z.ZodType<
  EntryTradeBrokerCapacityOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryTradeBrokerCapacity),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryTradeBrokerCapacity$outboundSchema: z.ZodType<
  EntryTradeBrokerCapacityOpen,
  z.ZodTypeDef,
  EntryTradeBrokerCapacityOpen
> = z.union([
  z.nativeEnum(EntryTradeBrokerCapacity),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryTradeBrokerCapacity$ {
  /** @deprecated use `EntryTradeBrokerCapacity$inboundSchema` instead. */
  export const inboundSchema = EntryTradeBrokerCapacity$inboundSchema;
  /** @deprecated use `EntryTradeBrokerCapacity$outboundSchema` instead. */
  export const outboundSchema = EntryTradeBrokerCapacity$outboundSchema;
}

/** @internal */
export const EntryTradePrevailingMarketPrice$inboundSchema: z.ZodType<
  EntryTradePrevailingMarketPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryTradePrevailingMarketPrice$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryTradePrevailingMarketPrice$outboundSchema: z.ZodType<
  EntryTradePrevailingMarketPrice$Outbound,
  z.ZodTypeDef,
  EntryTradePrevailingMarketPrice
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryTradePrevailingMarketPrice$ {
  /** @deprecated use `EntryTradePrevailingMarketPrice$inboundSchema` instead. */
  export const inboundSchema = EntryTradePrevailingMarketPrice$inboundSchema;
  /** @deprecated use `EntryTradePrevailingMarketPrice$outboundSchema` instead. */
  export const outboundSchema = EntryTradePrevailingMarketPrice$outboundSchema;
  /** @deprecated use `EntryTradePrevailingMarketPrice$Outbound` instead. */
  export type Outbound = EntryTradePrevailingMarketPrice$Outbound;
}

export function entryTradePrevailingMarketPriceToJSON(
  entryTradePrevailingMarketPrice: EntryTradePrevailingMarketPrice,
): string {
  return JSON.stringify(
    EntryTradePrevailingMarketPrice$outboundSchema.parse(
      entryTradePrevailingMarketPrice,
    ),
  );
}

export function entryTradePrevailingMarketPriceFromJSON(
  jsonString: string,
): SafeParseResult<EntryTradePrevailingMarketPrice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryTradePrevailingMarketPrice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryTradePrevailingMarketPrice' from JSON`,
  );
}

/** @internal */
export const EntryTradePriceAdjustmentAmount$inboundSchema: z.ZodType<
  EntryTradePriceAdjustmentAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryTradePriceAdjustmentAmount$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryTradePriceAdjustmentAmount$outboundSchema: z.ZodType<
  EntryTradePriceAdjustmentAmount$Outbound,
  z.ZodTypeDef,
  EntryTradePriceAdjustmentAmount
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryTradePriceAdjustmentAmount$ {
  /** @deprecated use `EntryTradePriceAdjustmentAmount$inboundSchema` instead. */
  export const inboundSchema = EntryTradePriceAdjustmentAmount$inboundSchema;
  /** @deprecated use `EntryTradePriceAdjustmentAmount$outboundSchema` instead. */
  export const outboundSchema = EntryTradePriceAdjustmentAmount$outboundSchema;
  /** @deprecated use `EntryTradePriceAdjustmentAmount$Outbound` instead. */
  export type Outbound = EntryTradePriceAdjustmentAmount$Outbound;
}

export function entryTradePriceAdjustmentAmountToJSON(
  entryTradePriceAdjustmentAmount: EntryTradePriceAdjustmentAmount,
): string {
  return JSON.stringify(
    EntryTradePriceAdjustmentAmount$outboundSchema.parse(
      entryTradePriceAdjustmentAmount,
    ),
  );
}

export function entryTradePriceAdjustmentAmountFromJSON(
  jsonString: string,
): SafeParseResult<EntryTradePriceAdjustmentAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryTradePriceAdjustmentAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryTradePriceAdjustmentAmount' from JSON`,
  );
}

/** @internal */
export const EntryPriceAdjustmentPercent$inboundSchema: z.ZodType<
  EntryPriceAdjustmentPercent,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryPriceAdjustmentPercent$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryPriceAdjustmentPercent$outboundSchema: z.ZodType<
  EntryPriceAdjustmentPercent$Outbound,
  z.ZodTypeDef,
  EntryPriceAdjustmentPercent
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPriceAdjustmentPercent$ {
  /** @deprecated use `EntryPriceAdjustmentPercent$inboundSchema` instead. */
  export const inboundSchema = EntryPriceAdjustmentPercent$inboundSchema;
  /** @deprecated use `EntryPriceAdjustmentPercent$outboundSchema` instead. */
  export const outboundSchema = EntryPriceAdjustmentPercent$outboundSchema;
  /** @deprecated use `EntryPriceAdjustmentPercent$Outbound` instead. */
  export type Outbound = EntryPriceAdjustmentPercent$Outbound;
}

export function entryPriceAdjustmentPercentToJSON(
  entryPriceAdjustmentPercent: EntryPriceAdjustmentPercent,
): string {
  return JSON.stringify(
    EntryPriceAdjustmentPercent$outboundSchema.parse(
      entryPriceAdjustmentPercent,
    ),
  );
}

export function entryPriceAdjustmentPercentFromJSON(
  jsonString: string,
): SafeParseResult<EntryPriceAdjustmentPercent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryPriceAdjustmentPercent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryPriceAdjustmentPercent' from JSON`,
  );
}

/** @internal */
export const EntryTradePriceAdjustmentType$inboundSchema: z.ZodType<
  EntryTradePriceAdjustmentTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryTradePriceAdjustmentType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryTradePriceAdjustmentType$outboundSchema: z.ZodType<
  EntryTradePriceAdjustmentTypeOpen,
  z.ZodTypeDef,
  EntryTradePriceAdjustmentTypeOpen
> = z.union([
  z.nativeEnum(EntryTradePriceAdjustmentType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryTradePriceAdjustmentType$ {
  /** @deprecated use `EntryTradePriceAdjustmentType$inboundSchema` instead. */
  export const inboundSchema = EntryTradePriceAdjustmentType$inboundSchema;
  /** @deprecated use `EntryTradePriceAdjustmentType$outboundSchema` instead. */
  export const outboundSchema = EntryTradePriceAdjustmentType$outboundSchema;
}

/** @internal */
export const EntryPriceAdjustmentRecord$inboundSchema: z.ZodType<
  EntryPriceAdjustmentRecord,
  z.ZodTypeDef,
  unknown
> = z.object({
  price_adjustment_amount: z.nullable(
    z.lazy(() => EntryTradePriceAdjustmentAmount$inboundSchema),
  ).optional(),
  price_adjustment_percent: z.nullable(
    z.lazy(() => EntryPriceAdjustmentPercent$inboundSchema),
  ).optional(),
  price_adjustment_type: EntryTradePriceAdjustmentType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "price_adjustment_amount": "priceAdjustmentAmount",
    "price_adjustment_percent": "priceAdjustmentPercent",
    "price_adjustment_type": "priceAdjustmentType",
  });
});

/** @internal */
export type EntryPriceAdjustmentRecord$Outbound = {
  price_adjustment_amount?:
    | EntryTradePriceAdjustmentAmount$Outbound
    | null
    | undefined;
  price_adjustment_percent?:
    | EntryPriceAdjustmentPercent$Outbound
    | null
    | undefined;
  price_adjustment_type?: string | undefined;
};

/** @internal */
export const EntryPriceAdjustmentRecord$outboundSchema: z.ZodType<
  EntryPriceAdjustmentRecord$Outbound,
  z.ZodTypeDef,
  EntryPriceAdjustmentRecord
> = z.object({
  priceAdjustmentAmount: z.nullable(
    z.lazy(() => EntryTradePriceAdjustmentAmount$outboundSchema),
  ).optional(),
  priceAdjustmentPercent: z.nullable(
    z.lazy(() => EntryPriceAdjustmentPercent$outboundSchema),
  ).optional(),
  priceAdjustmentType: EntryTradePriceAdjustmentType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    priceAdjustmentAmount: "price_adjustment_amount",
    priceAdjustmentPercent: "price_adjustment_percent",
    priceAdjustmentType: "price_adjustment_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryPriceAdjustmentRecord$ {
  /** @deprecated use `EntryPriceAdjustmentRecord$inboundSchema` instead. */
  export const inboundSchema = EntryPriceAdjustmentRecord$inboundSchema;
  /** @deprecated use `EntryPriceAdjustmentRecord$outboundSchema` instead. */
  export const outboundSchema = EntryPriceAdjustmentRecord$outboundSchema;
  /** @deprecated use `EntryPriceAdjustmentRecord$Outbound` instead. */
  export type Outbound = EntryPriceAdjustmentRecord$Outbound;
}

export function entryPriceAdjustmentRecordToJSON(
  entryPriceAdjustmentRecord: EntryPriceAdjustmentRecord,
): string {
  return JSON.stringify(
    EntryPriceAdjustmentRecord$outboundSchema.parse(entryPriceAdjustmentRecord),
  );
}

export function entryPriceAdjustmentRecordFromJSON(
  jsonString: string,
): SafeParseResult<EntryPriceAdjustmentRecord, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryPriceAdjustmentRecord$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryPriceAdjustmentRecord' from JSON`,
  );
}

/** @internal */
export const EntryTrade$inboundSchema: z.ZodType<
  EntryTrade,
  z.ZodTypeDef,
  unknown
> = z.object({
  additional_instructions: z.array(z.string()).optional(),
  alternate_order_id: z.string().optional(),
  booking_api_booking_execution_id: z.string().optional(),
  booking_api_trade_allocation_id: z.string().optional(),
  booking_api_trade_id: z.string().optional(),
  broker: z.string().optional(),
  broker_capacity: EntryTradeBrokerCapacity$inboundSchema.optional(),
  client_memo: z.string().optional(),
  client_order_id: z.string().optional(),
  exchange: z.string().optional(),
  execution_id: z.string().optional(),
  execution_only: z.boolean().optional(),
  external_id: z.string().optional(),
  fund_confirmation_number: z.string().optional(),
  gateway_client_order_id: z.string().optional(),
  internal_error: z.boolean().optional(),
  is_writeoff: z.boolean().optional(),
  lots: z.array(Lot$inboundSchema).optional(),
  market: z.string().optional(),
  order_id: z.string().optional(),
  prevailing_market_price: z.nullable(
    z.lazy(() => EntryTradePrevailingMarketPrice$inboundSchema),
  ).optional(),
  price_adjustment_record: z.nullable(
    z.lazy(() => EntryPriceAdjustmentRecord$inboundSchema),
  ).optional(),
  route: z.string().optional(),
  special_instructions: z.array(z.string()).optional(),
  when_issued: z.boolean().optional(),
  yield_records: z.array(YieldRecord$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "additional_instructions": "additionalInstructions",
    "alternate_order_id": "alternateOrderId",
    "booking_api_booking_execution_id": "bookingApiBookingExecutionId",
    "booking_api_trade_allocation_id": "bookingApiTradeAllocationId",
    "booking_api_trade_id": "bookingApiTradeId",
    "broker_capacity": "brokerCapacity",
    "client_memo": "clientMemo",
    "client_order_id": "clientOrderId",
    "execution_id": "executionId",
    "execution_only": "executionOnly",
    "external_id": "externalId",
    "fund_confirmation_number": "fundConfirmationNumber",
    "gateway_client_order_id": "gatewayClientOrderId",
    "internal_error": "internalError",
    "is_writeoff": "isWriteoff",
    "order_id": "orderId",
    "prevailing_market_price": "prevailingMarketPrice",
    "price_adjustment_record": "priceAdjustmentRecord",
    "special_instructions": "specialInstructions",
    "when_issued": "whenIssued",
    "yield_records": "yieldRecords",
  });
});

/** @internal */
export type EntryTrade$Outbound = {
  additional_instructions?: Array<string> | undefined;
  alternate_order_id?: string | undefined;
  booking_api_booking_execution_id?: string | undefined;
  booking_api_trade_allocation_id?: string | undefined;
  booking_api_trade_id?: string | undefined;
  broker?: string | undefined;
  broker_capacity?: string | undefined;
  client_memo?: string | undefined;
  client_order_id?: string | undefined;
  exchange?: string | undefined;
  execution_id?: string | undefined;
  execution_only?: boolean | undefined;
  external_id?: string | undefined;
  fund_confirmation_number?: string | undefined;
  gateway_client_order_id?: string | undefined;
  internal_error?: boolean | undefined;
  is_writeoff?: boolean | undefined;
  lots?: Array<Lot$Outbound> | undefined;
  market?: string | undefined;
  order_id?: string | undefined;
  prevailing_market_price?:
    | EntryTradePrevailingMarketPrice$Outbound
    | null
    | undefined;
  price_adjustment_record?:
    | EntryPriceAdjustmentRecord$Outbound
    | null
    | undefined;
  route?: string | undefined;
  special_instructions?: Array<string> | undefined;
  when_issued?: boolean | undefined;
  yield_records?: Array<YieldRecord$Outbound> | undefined;
};

/** @internal */
export const EntryTrade$outboundSchema: z.ZodType<
  EntryTrade$Outbound,
  z.ZodTypeDef,
  EntryTrade
> = z.object({
  additionalInstructions: z.array(z.string()).optional(),
  alternateOrderId: z.string().optional(),
  bookingApiBookingExecutionId: z.string().optional(),
  bookingApiTradeAllocationId: z.string().optional(),
  bookingApiTradeId: z.string().optional(),
  broker: z.string().optional(),
  brokerCapacity: EntryTradeBrokerCapacity$outboundSchema.optional(),
  clientMemo: z.string().optional(),
  clientOrderId: z.string().optional(),
  exchange: z.string().optional(),
  executionId: z.string().optional(),
  executionOnly: z.boolean().optional(),
  externalId: z.string().optional(),
  fundConfirmationNumber: z.string().optional(),
  gatewayClientOrderId: z.string().optional(),
  internalError: z.boolean().optional(),
  isWriteoff: z.boolean().optional(),
  lots: z.array(Lot$outboundSchema).optional(),
  market: z.string().optional(),
  orderId: z.string().optional(),
  prevailingMarketPrice: z.nullable(
    z.lazy(() => EntryTradePrevailingMarketPrice$outboundSchema),
  ).optional(),
  priceAdjustmentRecord: z.nullable(
    z.lazy(() => EntryPriceAdjustmentRecord$outboundSchema),
  ).optional(),
  route: z.string().optional(),
  specialInstructions: z.array(z.string()).optional(),
  whenIssued: z.boolean().optional(),
  yieldRecords: z.array(YieldRecord$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    additionalInstructions: "additional_instructions",
    alternateOrderId: "alternate_order_id",
    bookingApiBookingExecutionId: "booking_api_booking_execution_id",
    bookingApiTradeAllocationId: "booking_api_trade_allocation_id",
    bookingApiTradeId: "booking_api_trade_id",
    brokerCapacity: "broker_capacity",
    clientMemo: "client_memo",
    clientOrderId: "client_order_id",
    executionId: "execution_id",
    executionOnly: "execution_only",
    externalId: "external_id",
    fundConfirmationNumber: "fund_confirmation_number",
    gatewayClientOrderId: "gateway_client_order_id",
    internalError: "internal_error",
    isWriteoff: "is_writeoff",
    orderId: "order_id",
    prevailingMarketPrice: "prevailing_market_price",
    priceAdjustmentRecord: "price_adjustment_record",
    specialInstructions: "special_instructions",
    whenIssued: "when_issued",
    yieldRecords: "yield_records",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryTrade$ {
  /** @deprecated use `EntryTrade$inboundSchema` instead. */
  export const inboundSchema = EntryTrade$inboundSchema;
  /** @deprecated use `EntryTrade$outboundSchema` instead. */
  export const outboundSchema = EntryTrade$outboundSchema;
  /** @deprecated use `EntryTrade$Outbound` instead. */
  export type Outbound = EntryTrade$Outbound;
}

export function entryTradeToJSON(entryTrade: EntryTrade): string {
  return JSON.stringify(EntryTrade$outboundSchema.parse(entryTrade));
}

export function entryTradeFromJSON(
  jsonString: string,
): SafeParseResult<EntryTrade, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryTrade$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryTrade' from JSON`,
  );
}

/** @internal */
export const EntryTransferType$inboundSchema: z.ZodType<
  EntryTransferTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryTransferType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryTransferType$outboundSchema: z.ZodType<
  EntryTransferTypeOpen,
  z.ZodTypeDef,
  EntryTransferTypeOpen
> = z.union([
  z.nativeEnum(EntryTransferType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryTransferType$ {
  /** @deprecated use `EntryTransferType$inboundSchema` instead. */
  export const inboundSchema = EntryTransferType$inboundSchema;
  /** @deprecated use `EntryTransferType$outboundSchema` instead. */
  export const outboundSchema = EntryTransferType$outboundSchema;
}

/** @internal */
export const EntryTransfer$inboundSchema: z.ZodType<
  EntryTransfer,
  z.ZodTypeDef,
  unknown
> = z.object({
  additional_instructions: z.string().optional(),
  client_brokerage: z.string().optional(),
  transfer_type: EntryTransferType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "additional_instructions": "additionalInstructions",
    "client_brokerage": "clientBrokerage",
    "transfer_type": "transferType",
  });
});

/** @internal */
export type EntryTransfer$Outbound = {
  additional_instructions?: string | undefined;
  client_brokerage?: string | undefined;
  transfer_type?: string | undefined;
};

/** @internal */
export const EntryTransfer$outboundSchema: z.ZodType<
  EntryTransfer$Outbound,
  z.ZodTypeDef,
  EntryTransfer
> = z.object({
  additionalInstructions: z.string().optional(),
  clientBrokerage: z.string().optional(),
  transferType: EntryTransferType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    additionalInstructions: "additional_instructions",
    clientBrokerage: "client_brokerage",
    transferType: "transfer_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryTransfer$ {
  /** @deprecated use `EntryTransfer$inboundSchema` instead. */
  export const inboundSchema = EntryTransfer$inboundSchema;
  /** @deprecated use `EntryTransfer$outboundSchema` instead. */
  export const outboundSchema = EntryTransfer$outboundSchema;
  /** @deprecated use `EntryTransfer$Outbound` instead. */
  export type Outbound = EntryTransfer$Outbound;
}

export function entryTransferToJSON(entryTransfer: EntryTransfer): string {
  return JSON.stringify(EntryTransfer$outboundSchema.parse(entryTransfer));
}

export function entryTransferFromJSON(
  jsonString: string,
): SafeParseResult<EntryTransfer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryTransfer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryTransfer' from JSON`,
  );
}

/** @internal */
export const EntryType$inboundSchema: z.ZodType<
  EntryTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryType$outboundSchema: z.ZodType<
  EntryTypeOpen,
  z.ZodTypeDef,
  EntryTypeOpen
> = z.union([
  z.nativeEnum(EntryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryType$ {
  /** @deprecated use `EntryType$inboundSchema` instead. */
  export const inboundSchema = EntryType$inboundSchema;
  /** @deprecated use `EntryType$outboundSchema` instead. */
  export const outboundSchema = EntryType$outboundSchema;
}

/** @internal */
export const EntryUnitSplitCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryUnitSplitCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryUnitSplitCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryUnitSplitCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryUnitSplitCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryUnitSplitCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryUnitSplitCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryUnitSplitCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryUnitSplitCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryUnitSplitCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryUnitSplitCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryUnitSplitCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryUnitSplitCorporateActionGeneralInformation$Outbound;
}

export function entryUnitSplitCorporateActionGeneralInformationToJSON(
  entryUnitSplitCorporateActionGeneralInformation:
    EntryUnitSplitCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryUnitSplitCorporateActionGeneralInformation$outboundSchema.parse(
      entryUnitSplitCorporateActionGeneralInformation,
    ),
  );
}

export function entryUnitSplitCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryUnitSplitCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryUnitSplitCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryUnitSplitCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryUnitSplitStockRate$inboundSchema: z.ZodType<
  EntryUnitSplitStockRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryUnitSplitStockRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryUnitSplitStockRate$outboundSchema: z.ZodType<
  EntryUnitSplitStockRate$Outbound,
  z.ZodTypeDef,
  EntryUnitSplitStockRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryUnitSplitStockRate$ {
  /** @deprecated use `EntryUnitSplitStockRate$inboundSchema` instead. */
  export const inboundSchema = EntryUnitSplitStockRate$inboundSchema;
  /** @deprecated use `EntryUnitSplitStockRate$outboundSchema` instead. */
  export const outboundSchema = EntryUnitSplitStockRate$outboundSchema;
  /** @deprecated use `EntryUnitSplitStockRate$Outbound` instead. */
  export type Outbound = EntryUnitSplitStockRate$Outbound;
}

export function entryUnitSplitStockRateToJSON(
  entryUnitSplitStockRate: EntryUnitSplitStockRate,
): string {
  return JSON.stringify(
    EntryUnitSplitStockRate$outboundSchema.parse(entryUnitSplitStockRate),
  );
}

export function entryUnitSplitStockRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryUnitSplitStockRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryUnitSplitStockRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryUnitSplitStockRate' from JSON`,
  );
}

/** @internal */
export const UnitSplit$inboundSchema: z.ZodType<
  UnitSplit,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_general_information: z.nullable(
    z.lazy(() => EntryUnitSplitCorporateActionGeneralInformation$inboundSchema),
  ).optional(),
  stock_rate: z.nullable(z.lazy(() => EntryUnitSplitStockRate$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "stock_rate": "stockRate",
  });
});

/** @internal */
export type UnitSplit$Outbound = {
  corporate_action_general_information?:
    | EntryUnitSplitCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  stock_rate?: EntryUnitSplitStockRate$Outbound | null | undefined;
};

/** @internal */
export const UnitSplit$outboundSchema: z.ZodType<
  UnitSplit$Outbound,
  z.ZodTypeDef,
  UnitSplit
> = z.object({
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryUnitSplitCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  stockRate: z.nullable(z.lazy(() => EntryUnitSplitStockRate$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
    stockRate: "stock_rate",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UnitSplit$ {
  /** @deprecated use `UnitSplit$inboundSchema` instead. */
  export const inboundSchema = UnitSplit$inboundSchema;
  /** @deprecated use `UnitSplit$outboundSchema` instead. */
  export const outboundSchema = UnitSplit$outboundSchema;
  /** @deprecated use `UnitSplit$Outbound` instead. */
  export type Outbound = UnitSplit$Outbound;
}

export function unitSplitToJSON(unitSplit: UnitSplit): string {
  return JSON.stringify(UnitSplit$outboundSchema.parse(unitSplit));
}

export function unitSplitFromJSON(
  jsonString: string,
): SafeParseResult<UnitSplit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UnitSplit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UnitSplit' from JSON`,
  );
}

/** @internal */
export const EntryWarrantExerciseCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryWarrantExerciseCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryWarrantExerciseCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryWarrantExerciseCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryWarrantExerciseCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryWarrantExerciseCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryWarrantExerciseCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryWarrantExerciseCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryWarrantExerciseCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryWarrantExerciseCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryWarrantExerciseCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryWarrantExerciseCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryWarrantExerciseCorporateActionGeneralInformation$Outbound;
}

export function entryWarrantExerciseCorporateActionGeneralInformationToJSON(
  entryWarrantExerciseCorporateActionGeneralInformation:
    EntryWarrantExerciseCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryWarrantExerciseCorporateActionGeneralInformation$outboundSchema.parse(
      entryWarrantExerciseCorporateActionGeneralInformation,
    ),
  );
}

export function entryWarrantExerciseCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryWarrantExerciseCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryWarrantExerciseCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryWarrantExerciseCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const WarrantExercise$inboundSchema: z.ZodType<
  WarrantExercise,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_general_information: z.nullable(
    z.lazy(() =>
      EntryWarrantExerciseCorporateActionGeneralInformation$inboundSchema
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
  });
});

/** @internal */
export type WarrantExercise$Outbound = {
  corporate_action_general_information?:
    | EntryWarrantExerciseCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
};

/** @internal */
export const WarrantExercise$outboundSchema: z.ZodType<
  WarrantExercise$Outbound,
  z.ZodTypeDef,
  WarrantExercise
> = z.object({
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryWarrantExerciseCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WarrantExercise$ {
  /** @deprecated use `WarrantExercise$inboundSchema` instead. */
  export const inboundSchema = WarrantExercise$inboundSchema;
  /** @deprecated use `WarrantExercise$outboundSchema` instead. */
  export const outboundSchema = WarrantExercise$outboundSchema;
  /** @deprecated use `WarrantExercise$Outbound` instead. */
  export type Outbound = WarrantExercise$Outbound;
}

export function warrantExerciseToJSON(
  warrantExercise: WarrantExercise,
): string {
  return JSON.stringify(WarrantExercise$outboundSchema.parse(warrantExercise));
}

export function warrantExerciseFromJSON(
  jsonString: string,
): SafeParseResult<WarrantExercise, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WarrantExercise$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WarrantExercise' from JSON`,
  );
}

/** @internal */
export const DistributionType$inboundSchema: z.ZodType<
  DistributionTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(DistributionType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const DistributionType$outboundSchema: z.ZodType<
  DistributionTypeOpen,
  z.ZodTypeDef,
  DistributionTypeOpen
> = z.union([
  z.nativeEnum(DistributionType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DistributionType$ {
  /** @deprecated use `DistributionType$inboundSchema` instead. */
  export const inboundSchema = DistributionType$inboundSchema;
  /** @deprecated use `DistributionType$outboundSchema` instead. */
  export const outboundSchema = DistributionType$outboundSchema;
}

/** @internal */
export const RetirementType$inboundSchema: z.ZodType<
  RetirementTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RetirementType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const RetirementType$outboundSchema: z.ZodType<
  RetirementTypeOpen,
  z.ZodTypeDef,
  RetirementTypeOpen
> = z.union([
  z.nativeEnum(RetirementType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetirementType$ {
  /** @deprecated use `RetirementType$inboundSchema` instead. */
  export const inboundSchema = RetirementType$inboundSchema;
  /** @deprecated use `RetirementType$outboundSchema` instead. */
  export const outboundSchema = RetirementType$outboundSchema;
}

/** @internal */
export const EntryWithdrawalType$inboundSchema: z.ZodType<
  EntryWithdrawalTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryWithdrawalType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryWithdrawalType$outboundSchema: z.ZodType<
  EntryWithdrawalTypeOpen,
  z.ZodTypeDef,
  EntryWithdrawalTypeOpen
> = z.union([
  z.nativeEnum(EntryWithdrawalType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryWithdrawalType$ {
  /** @deprecated use `EntryWithdrawalType$inboundSchema` instead. */
  export const inboundSchema = EntryWithdrawalType$inboundSchema;
  /** @deprecated use `EntryWithdrawalType$outboundSchema` instead. */
  export const outboundSchema = EntryWithdrawalType$outboundSchema;
}

/** @internal */
export const Withdrawal$inboundSchema: z.ZodType<
  Withdrawal,
  z.ZodTypeDef,
  unknown
> = z.object({
  additional_instructions: z.string().optional(),
  closing_account: z.boolean().optional(),
  destination_account_number: z.string().optional(),
  destination_institution: z.string().optional(),
  distribution_type: DistributionType$inboundSchema.optional(),
  distribution_year: z.number().int().optional(),
  fed_reference_number: z.string().optional(),
  originating_institution: z.string().optional(),
  periodic: z.boolean().optional(),
  retirement_type: RetirementType$inboundSchema.optional(),
  total_distribution: z.boolean().optional(),
  type: EntryWithdrawalType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "additional_instructions": "additionalInstructions",
    "closing_account": "closingAccount",
    "destination_account_number": "destinationAccountNumber",
    "destination_institution": "destinationInstitution",
    "distribution_type": "distributionType",
    "distribution_year": "distributionYear",
    "fed_reference_number": "fedReferenceNumber",
    "originating_institution": "originatingInstitution",
    "retirement_type": "retirementType",
    "total_distribution": "totalDistribution",
  });
});

/** @internal */
export type Withdrawal$Outbound = {
  additional_instructions?: string | undefined;
  closing_account?: boolean | undefined;
  destination_account_number?: string | undefined;
  destination_institution?: string | undefined;
  distribution_type?: string | undefined;
  distribution_year?: number | undefined;
  fed_reference_number?: string | undefined;
  originating_institution?: string | undefined;
  periodic?: boolean | undefined;
  retirement_type?: string | undefined;
  total_distribution?: boolean | undefined;
  type?: string | undefined;
};

/** @internal */
export const Withdrawal$outboundSchema: z.ZodType<
  Withdrawal$Outbound,
  z.ZodTypeDef,
  Withdrawal
> = z.object({
  additionalInstructions: z.string().optional(),
  closingAccount: z.boolean().optional(),
  destinationAccountNumber: z.string().optional(),
  destinationInstitution: z.string().optional(),
  distributionType: DistributionType$outboundSchema.optional(),
  distributionYear: z.number().int().optional(),
  fedReferenceNumber: z.string().optional(),
  originatingInstitution: z.string().optional(),
  periodic: z.boolean().optional(),
  retirementType: RetirementType$outboundSchema.optional(),
  totalDistribution: z.boolean().optional(),
  type: EntryWithdrawalType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    additionalInstructions: "additional_instructions",
    closingAccount: "closing_account",
    destinationAccountNumber: "destination_account_number",
    destinationInstitution: "destination_institution",
    distributionType: "distribution_type",
    distributionYear: "distribution_year",
    fedReferenceNumber: "fed_reference_number",
    originatingInstitution: "originating_institution",
    retirementType: "retirement_type",
    totalDistribution: "total_distribution",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Withdrawal$ {
  /** @deprecated use `Withdrawal$inboundSchema` instead. */
  export const inboundSchema = Withdrawal$inboundSchema;
  /** @deprecated use `Withdrawal$outboundSchema` instead. */
  export const outboundSchema = Withdrawal$outboundSchema;
  /** @deprecated use `Withdrawal$Outbound` instead. */
  export type Outbound = Withdrawal$Outbound;
}

export function withdrawalToJSON(withdrawal: Withdrawal): string {
  return JSON.stringify(Withdrawal$outboundSchema.parse(withdrawal));
}

export function withdrawalFromJSON(
  jsonString: string,
): SafeParseResult<Withdrawal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Withdrawal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Withdrawal' from JSON`,
  );
}

/** @internal */
export const Review$inboundSchema: z.ZodType<
  ReviewOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(Review),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Review$outboundSchema: z.ZodType<
  ReviewOpen,
  z.ZodTypeDef,
  ReviewOpen
> = z.union([
  z.nativeEnum(Review),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Review$ {
  /** @deprecated use `Review$inboundSchema` instead. */
  export const inboundSchema = Review$inboundSchema;
  /** @deprecated use `Review$outboundSchema` instead. */
  export const outboundSchema = Review$outboundSchema;
}

/** @internal */
export const WithdrawalPendingReview$inboundSchema: z.ZodType<
  WithdrawalPendingReview,
  z.ZodTypeDef,
  unknown
> = z.object({
  review: Review$inboundSchema.optional(),
});

/** @internal */
export type WithdrawalPendingReview$Outbound = {
  review?: string | undefined;
};

/** @internal */
export const WithdrawalPendingReview$outboundSchema: z.ZodType<
  WithdrawalPendingReview$Outbound,
  z.ZodTypeDef,
  WithdrawalPendingReview
> = z.object({
  review: Review$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WithdrawalPendingReview$ {
  /** @deprecated use `WithdrawalPendingReview$inboundSchema` instead. */
  export const inboundSchema = WithdrawalPendingReview$inboundSchema;
  /** @deprecated use `WithdrawalPendingReview$outboundSchema` instead. */
  export const outboundSchema = WithdrawalPendingReview$outboundSchema;
  /** @deprecated use `WithdrawalPendingReview$Outbound` instead. */
  export type Outbound = WithdrawalPendingReview$Outbound;
}

export function withdrawalPendingReviewToJSON(
  withdrawalPendingReview: WithdrawalPendingReview,
): string {
  return JSON.stringify(
    WithdrawalPendingReview$outboundSchema.parse(withdrawalPendingReview),
  );
}

export function withdrawalPendingReviewFromJSON(
  jsonString: string,
): SafeParseResult<WithdrawalPendingReview, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WithdrawalPendingReview$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WithdrawalPendingReview' from JSON`,
  );
}

/** @internal */
export const EntryWithholdingRate$inboundSchema: z.ZodType<
  EntryWithholdingRate,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type EntryWithholdingRate$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const EntryWithholdingRate$outboundSchema: z.ZodType<
  EntryWithholdingRate$Outbound,
  z.ZodTypeDef,
  EntryWithholdingRate
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryWithholdingRate$ {
  /** @deprecated use `EntryWithholdingRate$inboundSchema` instead. */
  export const inboundSchema = EntryWithholdingRate$inboundSchema;
  /** @deprecated use `EntryWithholdingRate$outboundSchema` instead. */
  export const outboundSchema = EntryWithholdingRate$outboundSchema;
  /** @deprecated use `EntryWithholdingRate$Outbound` instead. */
  export type Outbound = EntryWithholdingRate$Outbound;
}

export function entryWithholdingRateToJSON(
  entryWithholdingRate: EntryWithholdingRate,
): string {
  return JSON.stringify(
    EntryWithholdingRate$outboundSchema.parse(entryWithholdingRate),
  );
}

export function entryWithholdingRateFromJSON(
  jsonString: string,
): SafeParseResult<EntryWithholdingRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryWithholdingRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryWithholdingRate' from JSON`,
  );
}

/** @internal */
export const EntryWithholdingState$inboundSchema: z.ZodType<
  EntryWithholdingStateOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryWithholdingState),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryWithholdingState$outboundSchema: z.ZodType<
  EntryWithholdingStateOpen,
  z.ZodTypeDef,
  EntryWithholdingStateOpen
> = z.union([
  z.nativeEnum(EntryWithholdingState),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryWithholdingState$ {
  /** @deprecated use `EntryWithholdingState$inboundSchema` instead. */
  export const inboundSchema = EntryWithholdingState$inboundSchema;
  /** @deprecated use `EntryWithholdingState$outboundSchema` instead. */
  export const outboundSchema = EntryWithholdingState$outboundSchema;
}

/** @internal */
export const EntryWithholdingType$inboundSchema: z.ZodType<
  EntryWithholdingTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EntryWithholdingType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EntryWithholdingType$outboundSchema: z.ZodType<
  EntryWithholdingTypeOpen,
  z.ZodTypeDef,
  EntryWithholdingTypeOpen
> = z.union([
  z.nativeEnum(EntryWithholdingType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryWithholdingType$ {
  /** @deprecated use `EntryWithholdingType$inboundSchema` instead. */
  export const inboundSchema = EntryWithholdingType$inboundSchema;
  /** @deprecated use `EntryWithholdingType$outboundSchema` instead. */
  export const outboundSchema = EntryWithholdingType$outboundSchema;
}

/** @internal */
export const EntryWithholding$inboundSchema: z.ZodType<
  EntryWithholding,
  z.ZodTypeDef,
  unknown
> = z.object({
  rate: z.nullable(z.lazy(() => EntryWithholdingRate$inboundSchema)).optional(),
  region_code: z.string().optional(),
  state: EntryWithholdingState$inboundSchema.optional(),
  tax_year: z.number().int().optional(),
  type: EntryWithholdingType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "region_code": "regionCode",
    "tax_year": "taxYear",
  });
});

/** @internal */
export type EntryWithholding$Outbound = {
  rate?: EntryWithholdingRate$Outbound | null | undefined;
  region_code?: string | undefined;
  state?: string | undefined;
  tax_year?: number | undefined;
  type?: string | undefined;
};

/** @internal */
export const EntryWithholding$outboundSchema: z.ZodType<
  EntryWithholding$Outbound,
  z.ZodTypeDef,
  EntryWithholding
> = z.object({
  rate: z.nullable(z.lazy(() => EntryWithholdingRate$outboundSchema))
    .optional(),
  regionCode: z.string().optional(),
  state: EntryWithholdingState$outboundSchema.optional(),
  taxYear: z.number().int().optional(),
  type: EntryWithholdingType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    regionCode: "region_code",
    taxYear: "tax_year",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryWithholding$ {
  /** @deprecated use `EntryWithholding$inboundSchema` instead. */
  export const inboundSchema = EntryWithholding$inboundSchema;
  /** @deprecated use `EntryWithholding$outboundSchema` instead. */
  export const outboundSchema = EntryWithholding$outboundSchema;
  /** @deprecated use `EntryWithholding$Outbound` instead. */
  export type Outbound = EntryWithholding$Outbound;
}

export function entryWithholdingToJSON(
  entryWithholding: EntryWithholding,
): string {
  return JSON.stringify(
    EntryWithholding$outboundSchema.parse(entryWithholding),
  );
}

export function entryWithholdingFromJSON(
  jsonString: string,
): SafeParseResult<EntryWithholding, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryWithholding$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryWithholding' from JSON`,
  );
}

/** @internal */
export const EntryWorthlessCorporateActionGeneralInformation$inboundSchema:
  z.ZodType<
    EntryWorthlessCorporateActionGeneralInformation,
    z.ZodTypeDef,
    unknown
  > = z.object({
    corporate_action_id: z.string().optional(),
    disbursed_asset_id: z.string().optional(),
    disbursed_cusip: z.string().optional(),
    disbursed_symbol_description: z.string().optional(),
    target_asset_id: z.string().optional(),
    target_cusip: z.string().optional(),
    target_symbol_description: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "corporate_action_id": "corporateActionId",
      "disbursed_asset_id": "disbursedAssetId",
      "disbursed_cusip": "disbursedCusip",
      "disbursed_symbol_description": "disbursedSymbolDescription",
      "target_asset_id": "targetAssetId",
      "target_cusip": "targetCusip",
      "target_symbol_description": "targetSymbolDescription",
    });
  });

/** @internal */
export type EntryWorthlessCorporateActionGeneralInformation$Outbound = {
  corporate_action_id?: string | undefined;
  disbursed_asset_id?: string | undefined;
  disbursed_cusip?: string | undefined;
  disbursed_symbol_description?: string | undefined;
  target_asset_id?: string | undefined;
  target_cusip?: string | undefined;
  target_symbol_description?: string | undefined;
};

/** @internal */
export const EntryWorthlessCorporateActionGeneralInformation$outboundSchema:
  z.ZodType<
    EntryWorthlessCorporateActionGeneralInformation$Outbound,
    z.ZodTypeDef,
    EntryWorthlessCorporateActionGeneralInformation
  > = z.object({
    corporateActionId: z.string().optional(),
    disbursedAssetId: z.string().optional(),
    disbursedCusip: z.string().optional(),
    disbursedSymbolDescription: z.string().optional(),
    targetAssetId: z.string().optional(),
    targetCusip: z.string().optional(),
    targetSymbolDescription: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      corporateActionId: "corporate_action_id",
      disbursedAssetId: "disbursed_asset_id",
      disbursedCusip: "disbursed_cusip",
      disbursedSymbolDescription: "disbursed_symbol_description",
      targetAssetId: "target_asset_id",
      targetCusip: "target_cusip",
      targetSymbolDescription: "target_symbol_description",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryWorthlessCorporateActionGeneralInformation$ {
  /** @deprecated use `EntryWorthlessCorporateActionGeneralInformation$inboundSchema` instead. */
  export const inboundSchema =
    EntryWorthlessCorporateActionGeneralInformation$inboundSchema;
  /** @deprecated use `EntryWorthlessCorporateActionGeneralInformation$outboundSchema` instead. */
  export const outboundSchema =
    EntryWorthlessCorporateActionGeneralInformation$outboundSchema;
  /** @deprecated use `EntryWorthlessCorporateActionGeneralInformation$Outbound` instead. */
  export type Outbound =
    EntryWorthlessCorporateActionGeneralInformation$Outbound;
}

export function entryWorthlessCorporateActionGeneralInformationToJSON(
  entryWorthlessCorporateActionGeneralInformation:
    EntryWorthlessCorporateActionGeneralInformation,
): string {
  return JSON.stringify(
    EntryWorthlessCorporateActionGeneralInformation$outboundSchema.parse(
      entryWorthlessCorporateActionGeneralInformation,
    ),
  );
}

export function entryWorthlessCorporateActionGeneralInformationFromJSON(
  jsonString: string,
): SafeParseResult<
  EntryWorthlessCorporateActionGeneralInformation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EntryWorthlessCorporateActionGeneralInformation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EntryWorthlessCorporateActionGeneralInformation' from JSON`,
  );
}

/** @internal */
export const EntryWorthlessEffectiveDate$inboundSchema: z.ZodType<
  EntryWorthlessEffectiveDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryWorthlessEffectiveDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryWorthlessEffectiveDate$outboundSchema: z.ZodType<
  EntryWorthlessEffectiveDate$Outbound,
  z.ZodTypeDef,
  EntryWorthlessEffectiveDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryWorthlessEffectiveDate$ {
  /** @deprecated use `EntryWorthlessEffectiveDate$inboundSchema` instead. */
  export const inboundSchema = EntryWorthlessEffectiveDate$inboundSchema;
  /** @deprecated use `EntryWorthlessEffectiveDate$outboundSchema` instead. */
  export const outboundSchema = EntryWorthlessEffectiveDate$outboundSchema;
  /** @deprecated use `EntryWorthlessEffectiveDate$Outbound` instead. */
  export type Outbound = EntryWorthlessEffectiveDate$Outbound;
}

export function entryWorthlessEffectiveDateToJSON(
  entryWorthlessEffectiveDate: EntryWorthlessEffectiveDate,
): string {
  return JSON.stringify(
    EntryWorthlessEffectiveDate$outboundSchema.parse(
      entryWorthlessEffectiveDate,
    ),
  );
}

export function entryWorthlessEffectiveDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryWorthlessEffectiveDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryWorthlessEffectiveDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryWorthlessEffectiveDate' from JSON`,
  );
}

/** @internal */
export const EntryWorthlessPaymentDate$inboundSchema: z.ZodType<
  EntryWorthlessPaymentDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type EntryWorthlessPaymentDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const EntryWorthlessPaymentDate$outboundSchema: z.ZodType<
  EntryWorthlessPaymentDate$Outbound,
  z.ZodTypeDef,
  EntryWorthlessPaymentDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntryWorthlessPaymentDate$ {
  /** @deprecated use `EntryWorthlessPaymentDate$inboundSchema` instead. */
  export const inboundSchema = EntryWorthlessPaymentDate$inboundSchema;
  /** @deprecated use `EntryWorthlessPaymentDate$outboundSchema` instead. */
  export const outboundSchema = EntryWorthlessPaymentDate$outboundSchema;
  /** @deprecated use `EntryWorthlessPaymentDate$Outbound` instead. */
  export type Outbound = EntryWorthlessPaymentDate$Outbound;
}

export function entryWorthlessPaymentDateToJSON(
  entryWorthlessPaymentDate: EntryWorthlessPaymentDate,
): string {
  return JSON.stringify(
    EntryWorthlessPaymentDate$outboundSchema.parse(entryWorthlessPaymentDate),
  );
}

export function entryWorthlessPaymentDateFromJSON(
  jsonString: string,
): SafeParseResult<EntryWorthlessPaymentDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EntryWorthlessPaymentDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EntryWorthlessPaymentDate' from JSON`,
  );
}

/** @internal */
export const Worthless$inboundSchema: z.ZodType<
  Worthless,
  z.ZodTypeDef,
  unknown
> = z.object({
  corporate_action_general_information: z.nullable(
    z.lazy(() => EntryWorthlessCorporateActionGeneralInformation$inboundSchema),
  ).optional(),
  effective_date: z.nullable(
    z.lazy(() => EntryWorthlessEffectiveDate$inboundSchema),
  ).optional(),
  payment_date: z.nullable(
    z.lazy(() => EntryWorthlessPaymentDate$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "corporate_action_general_information": "corporateActionGeneralInformation",
    "effective_date": "effectiveDate",
    "payment_date": "paymentDate",
  });
});

/** @internal */
export type Worthless$Outbound = {
  corporate_action_general_information?:
    | EntryWorthlessCorporateActionGeneralInformation$Outbound
    | null
    | undefined;
  effective_date?: EntryWorthlessEffectiveDate$Outbound | null | undefined;
  payment_date?: EntryWorthlessPaymentDate$Outbound | null | undefined;
};

/** @internal */
export const Worthless$outboundSchema: z.ZodType<
  Worthless$Outbound,
  z.ZodTypeDef,
  Worthless
> = z.object({
  corporateActionGeneralInformation: z.nullable(
    z.lazy(() =>
      EntryWorthlessCorporateActionGeneralInformation$outboundSchema
    ),
  ).optional(),
  effectiveDate: z.nullable(
    z.lazy(() => EntryWorthlessEffectiveDate$outboundSchema),
  ).optional(),
  paymentDate: z.nullable(
    z.lazy(() => EntryWorthlessPaymentDate$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    corporateActionGeneralInformation: "corporate_action_general_information",
    effectiveDate: "effective_date",
    paymentDate: "payment_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Worthless$ {
  /** @deprecated use `Worthless$inboundSchema` instead. */
  export const inboundSchema = Worthless$inboundSchema;
  /** @deprecated use `Worthless$outboundSchema` instead. */
  export const outboundSchema = Worthless$outboundSchema;
  /** @deprecated use `Worthless$Outbound` instead. */
  export type Outbound = Worthless$Outbound;
}

export function worthlessToJSON(worthless: Worthless): string {
  return JSON.stringify(Worthless$outboundSchema.parse(worthless));
}

export function worthlessFromJSON(
  jsonString: string,
): SafeParseResult<Worthless, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Worthless$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Worthless' from JSON`,
  );
}

/** @internal */
export const Entry$inboundSchema: z.ZodType<Entry, z.ZodTypeDef, unknown> = z
  .object({
    acats_pending_out: z.nullable(z.lazy(() => AcatsPendingOut$inboundSchema))
      .optional(),
    account_id: z.string().optional(),
    account_memo: AccountMemo$inboundSchema.optional(),
    account_transfer: z.nullable(z.lazy(() => AccountTransfer$inboundSchema))
      .optional(),
    accrued_interest: z.nullable(
      z.lazy(() => EntryAccruedInterest$inboundSchema),
    ).optional(),
    acquisition: z.nullable(z.lazy(() => Acquisition$inboundSchema)).optional(),
    activity_date: z.nullable(z.lazy(() => ActivityDate$inboundSchema))
      .optional(),
    activity_id: z.string().optional(),
    activity_time: z.nullable(
      z.string().datetime({ offset: true }).transform(v => new Date(v)),
    ).optional(),
    allocation: z.nullable(z.lazy(() => Allocation$inboundSchema)).optional(),
    asset_id: z.string().optional(),
    bond_default: z.nullable(z.lazy(() => BondDefault$inboundSchema))
      .optional(),
    capital_gains: z.nullable(z.lazy(() => CapitalGains$inboundSchema))
      .optional(),
    cash_dividend: z.nullable(z.lazy(() => CashDividend$inboundSchema))
      .optional(),
    cash_in_lieu: z.nullable(z.lazy(() => CashInLieu$inboundSchema)).optional(),
    commission: z.nullable(z.lazy(() => EntryCommission$inboundSchema))
      .optional(),
    conversion: z.nullable(z.lazy(() => Conversion$inboundSchema)).optional(),
    corporate_action_memo_adjustment: z.nullable(
      z.lazy(() => CorporateActionMemoAdjustment$inboundSchema),
    ).optional(),
    credit: z.nullable(z.lazy(() => Credit$inboundSchema)).optional(),
    currency_asset_id: z.string().optional(),
    delivery: z.nullable(z.lazy(() => Delivery$inboundSchema)).optional(),
    deposit: z.nullable(z.lazy(() => Deposit$inboundSchema)).optional(),
    description: z.string().optional(),
    drip: z.nullable(z.lazy(() => Drip$inboundSchema)).optional(),
    entry_id: z.string().optional(),
    exchange: z.nullable(z.lazy(() => Exchange$inboundSchema)).optional(),
    fee: z.nullable(z.lazy(() => EntryFee$inboundSchema)).optional(),
    flip: z.nullable(z.lazy(() => Flip$inboundSchema)).optional(),
    fpsl: z.nullable(z.lazy(() => Fpsl$inboundSchema)).optional(),
    gross_amount: z.nullable(z.lazy(() => EntryGrossAmount$inboundSchema))
      .optional(),
    interest: z.nullable(z.lazy(() => Interest$inboundSchema)).optional(),
    interest_payment: z.nullable(z.lazy(() => InterestPayment$inboundSchema))
      .optional(),
    liquidation: z.nullable(z.lazy(() => Liquidation$inboundSchema)).optional(),
    maturity: z.nullable(z.lazy(() => Maturity$inboundSchema)).optional(),
    merger: z.nullable(z.lazy(() => Merger$inboundSchema)).optional(),
    name: z.string().optional(),
    name_change: z.nullable(z.lazy(() => NameChange$inboundSchema)).optional(),
    original_id: z.string().optional(),
    original_process_date: z.nullable(
      z.lazy(() => OriginalProcessDate$inboundSchema),
    ).optional(),
    payment_in_kind: z.nullable(z.lazy(() => PaymentInKind$inboundSchema))
      .optional(),
    price: z.nullable(z.lazy(() => EntryPrice$inboundSchema)).optional(),
    process_date: z.nullable(z.lazy(() => EntryProcessDate$inboundSchema))
      .optional(),
    quantity: z.nullable(z.lazy(() => EntryQuantity$inboundSchema)).optional(),
    receive: z.nullable(z.lazy(() => Receive$inboundSchema)).optional(),
    redemption_full: z.nullable(z.lazy(() => RedemptionFull$inboundSchema))
      .optional(),
    redemption_partial: z.nullable(
      z.lazy(() => RedemptionPartial$inboundSchema),
    ).optional(),
    reverse_stock_split: z.nullable(
      z.lazy(() => ReverseStockSplit$inboundSchema),
    ).optional(),
    reversed_entry_id: z.string().optional(),
    rights_distribution: z.nullable(
      z.lazy(() => RightsDistribution$inboundSchema),
    ).optional(),
    rights_subscription: z.nullable(
      z.lazy(() => RightsSubscription$inboundSchema),
    ).optional(),
    rounding_adjustment: z.nullable(
      z.lazy(() => RoundingAdjustment$inboundSchema),
    ).optional(),
    sale_of_rights: z.nullable(z.lazy(() => SaleOfRights$inboundSchema))
      .optional(),
    settle_date: z.nullable(z.lazy(() => SettleDate$inboundSchema)).optional(),
    side: EntrySide$inboundSchema.optional(),
    side_modifier: EntrySideModifier$inboundSchema.optional(),
    spin_off: z.nullable(z.lazy(() => SpinOff$inboundSchema)).optional(),
    state: EntryState$inboundSchema.optional(),
    stock_dividend: z.nullable(z.lazy(() => StockDividend$inboundSchema))
      .optional(),
    stock_split: z.nullable(z.lazy(() => StockSplit$inboundSchema)).optional(),
    subtype_category: z.string().optional(),
    sweep: z.nullable(z.lazy(() => Sweep$inboundSchema)).optional(),
    tender_offer: z.nullable(z.lazy(() => TenderOffer$inboundSchema))
      .optional(),
    trade: z.nullable(z.lazy(() => EntryTrade$inboundSchema)).optional(),
    transfer: z.nullable(z.lazy(() => EntryTransfer$inboundSchema)).optional(),
    type: EntryType$inboundSchema.optional(),
    unit_split: z.nullable(z.lazy(() => UnitSplit$inboundSchema)).optional(),
    warrant_exercise: z.nullable(z.lazy(() => WarrantExercise$inboundSchema))
      .optional(),
    withdrawal: z.nullable(z.lazy(() => Withdrawal$inboundSchema)).optional(),
    withdrawal_pending_review: z.nullable(
      z.lazy(() => WithdrawalPendingReview$inboundSchema),
    ).optional(),
    withholding: z.nullable(z.lazy(() => EntryWithholding$inboundSchema))
      .optional(),
    worthless: z.nullable(z.lazy(() => Worthless$inboundSchema)).optional(),
  }).transform((v) => {
    return remap$(v, {
      "acats_pending_out": "acatsPendingOut",
      "account_id": "accountId",
      "account_memo": "accountMemo",
      "account_transfer": "accountTransfer",
      "accrued_interest": "accruedInterest",
      "activity_date": "activityDate",
      "activity_id": "activityId",
      "activity_time": "activityTime",
      "asset_id": "assetId",
      "bond_default": "bondDefault",
      "capital_gains": "capitalGains",
      "cash_dividend": "cashDividend",
      "cash_in_lieu": "cashInLieu",
      "corporate_action_memo_adjustment": "corporateActionMemoAdjustment",
      "currency_asset_id": "currencyAssetId",
      "entry_id": "entryId",
      "gross_amount": "grossAmount",
      "interest_payment": "interestPayment",
      "name_change": "nameChange",
      "original_id": "originalId",
      "original_process_date": "originalProcessDate",
      "payment_in_kind": "paymentInKind",
      "process_date": "processDate",
      "redemption_full": "redemptionFull",
      "redemption_partial": "redemptionPartial",
      "reverse_stock_split": "reverseStockSplit",
      "reversed_entry_id": "reversedEntryId",
      "rights_distribution": "rightsDistribution",
      "rights_subscription": "rightsSubscription",
      "rounding_adjustment": "roundingAdjustment",
      "sale_of_rights": "saleOfRights",
      "settle_date": "settleDate",
      "side_modifier": "sideModifier",
      "spin_off": "spinOff",
      "stock_dividend": "stockDividend",
      "stock_split": "stockSplit",
      "subtype_category": "subtypeCategory",
      "tender_offer": "tenderOffer",
      "unit_split": "unitSplit",
      "warrant_exercise": "warrantExercise",
      "withdrawal_pending_review": "withdrawalPendingReview",
    });
  });

/** @internal */
export type Entry$Outbound = {
  acats_pending_out?: AcatsPendingOut$Outbound | null | undefined;
  account_id?: string | undefined;
  account_memo?: string | undefined;
  account_transfer?: AccountTransfer$Outbound | null | undefined;
  accrued_interest?: EntryAccruedInterest$Outbound | null | undefined;
  acquisition?: Acquisition$Outbound | null | undefined;
  activity_date?: ActivityDate$Outbound | null | undefined;
  activity_id?: string | undefined;
  activity_time?: string | null | undefined;
  allocation?: Allocation$Outbound | null | undefined;
  asset_id?: string | undefined;
  bond_default?: BondDefault$Outbound | null | undefined;
  capital_gains?: CapitalGains$Outbound | null | undefined;
  cash_dividend?: CashDividend$Outbound | null | undefined;
  cash_in_lieu?: CashInLieu$Outbound | null | undefined;
  commission?: EntryCommission$Outbound | null | undefined;
  conversion?: Conversion$Outbound | null | undefined;
  corporate_action_memo_adjustment?:
    | CorporateActionMemoAdjustment$Outbound
    | null
    | undefined;
  credit?: Credit$Outbound | null | undefined;
  currency_asset_id?: string | undefined;
  delivery?: Delivery$Outbound | null | undefined;
  deposit?: Deposit$Outbound | null | undefined;
  description?: string | undefined;
  drip?: Drip$Outbound | null | undefined;
  entry_id?: string | undefined;
  exchange?: Exchange$Outbound | null | undefined;
  fee?: EntryFee$Outbound | null | undefined;
  flip?: Flip$Outbound | null | undefined;
  fpsl?: Fpsl$Outbound | null | undefined;
  gross_amount?: EntryGrossAmount$Outbound | null | undefined;
  interest?: Interest$Outbound | null | undefined;
  interest_payment?: InterestPayment$Outbound | null | undefined;
  liquidation?: Liquidation$Outbound | null | undefined;
  maturity?: Maturity$Outbound | null | undefined;
  merger?: Merger$Outbound | null | undefined;
  name?: string | undefined;
  name_change?: NameChange$Outbound | null | undefined;
  original_id?: string | undefined;
  original_process_date?: OriginalProcessDate$Outbound | null | undefined;
  payment_in_kind?: PaymentInKind$Outbound | null | undefined;
  price?: EntryPrice$Outbound | null | undefined;
  process_date?: EntryProcessDate$Outbound | null | undefined;
  quantity?: EntryQuantity$Outbound | null | undefined;
  receive?: Receive$Outbound | null | undefined;
  redemption_full?: RedemptionFull$Outbound | null | undefined;
  redemption_partial?: RedemptionPartial$Outbound | null | undefined;
  reverse_stock_split?: ReverseStockSplit$Outbound | null | undefined;
  reversed_entry_id?: string | undefined;
  rights_distribution?: RightsDistribution$Outbound | null | undefined;
  rights_subscription?: RightsSubscription$Outbound | null | undefined;
  rounding_adjustment?: RoundingAdjustment$Outbound | null | undefined;
  sale_of_rights?: SaleOfRights$Outbound | null | undefined;
  settle_date?: SettleDate$Outbound | null | undefined;
  side?: string | undefined;
  side_modifier?: string | undefined;
  spin_off?: SpinOff$Outbound | null | undefined;
  state?: string | undefined;
  stock_dividend?: StockDividend$Outbound | null | undefined;
  stock_split?: StockSplit$Outbound | null | undefined;
  subtype_category?: string | undefined;
  sweep?: Sweep$Outbound | null | undefined;
  tender_offer?: TenderOffer$Outbound | null | undefined;
  trade?: EntryTrade$Outbound | null | undefined;
  transfer?: EntryTransfer$Outbound | null | undefined;
  type?: string | undefined;
  unit_split?: UnitSplit$Outbound | null | undefined;
  warrant_exercise?: WarrantExercise$Outbound | null | undefined;
  withdrawal?: Withdrawal$Outbound | null | undefined;
  withdrawal_pending_review?:
    | WithdrawalPendingReview$Outbound
    | null
    | undefined;
  withholding?: EntryWithholding$Outbound | null | undefined;
  worthless?: Worthless$Outbound | null | undefined;
};

/** @internal */
export const Entry$outboundSchema: z.ZodType<
  Entry$Outbound,
  z.ZodTypeDef,
  Entry
> = z.object({
  acatsPendingOut: z.nullable(z.lazy(() => AcatsPendingOut$outboundSchema))
    .optional(),
  accountId: z.string().optional(),
  accountMemo: AccountMemo$outboundSchema.optional(),
  accountTransfer: z.nullable(z.lazy(() => AccountTransfer$outboundSchema))
    .optional(),
  accruedInterest: z.nullable(z.lazy(() => EntryAccruedInterest$outboundSchema))
    .optional(),
  acquisition: z.nullable(z.lazy(() => Acquisition$outboundSchema)).optional(),
  activityDate: z.nullable(z.lazy(() => ActivityDate$outboundSchema))
    .optional(),
  activityId: z.string().optional(),
  activityTime: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  allocation: z.nullable(z.lazy(() => Allocation$outboundSchema)).optional(),
  assetId: z.string().optional(),
  bondDefault: z.nullable(z.lazy(() => BondDefault$outboundSchema)).optional(),
  capitalGains: z.nullable(z.lazy(() => CapitalGains$outboundSchema))
    .optional(),
  cashDividend: z.nullable(z.lazy(() => CashDividend$outboundSchema))
    .optional(),
  cashInLieu: z.nullable(z.lazy(() => CashInLieu$outboundSchema)).optional(),
  commission: z.nullable(z.lazy(() => EntryCommission$outboundSchema))
    .optional(),
  conversion: z.nullable(z.lazy(() => Conversion$outboundSchema)).optional(),
  corporateActionMemoAdjustment: z.nullable(
    z.lazy(() => CorporateActionMemoAdjustment$outboundSchema),
  ).optional(),
  credit: z.nullable(z.lazy(() => Credit$outboundSchema)).optional(),
  currencyAssetId: z.string().optional(),
  delivery: z.nullable(z.lazy(() => Delivery$outboundSchema)).optional(),
  deposit: z.nullable(z.lazy(() => Deposit$outboundSchema)).optional(),
  description: z.string().optional(),
  drip: z.nullable(z.lazy(() => Drip$outboundSchema)).optional(),
  entryId: z.string().optional(),
  exchange: z.nullable(z.lazy(() => Exchange$outboundSchema)).optional(),
  fee: z.nullable(z.lazy(() => EntryFee$outboundSchema)).optional(),
  flip: z.nullable(z.lazy(() => Flip$outboundSchema)).optional(),
  fpsl: z.nullable(z.lazy(() => Fpsl$outboundSchema)).optional(),
  grossAmount: z.nullable(z.lazy(() => EntryGrossAmount$outboundSchema))
    .optional(),
  interest: z.nullable(z.lazy(() => Interest$outboundSchema)).optional(),
  interestPayment: z.nullable(z.lazy(() => InterestPayment$outboundSchema))
    .optional(),
  liquidation: z.nullable(z.lazy(() => Liquidation$outboundSchema)).optional(),
  maturity: z.nullable(z.lazy(() => Maturity$outboundSchema)).optional(),
  merger: z.nullable(z.lazy(() => Merger$outboundSchema)).optional(),
  name: z.string().optional(),
  nameChange: z.nullable(z.lazy(() => NameChange$outboundSchema)).optional(),
  originalId: z.string().optional(),
  originalProcessDate: z.nullable(
    z.lazy(() => OriginalProcessDate$outboundSchema),
  ).optional(),
  paymentInKind: z.nullable(z.lazy(() => PaymentInKind$outboundSchema))
    .optional(),
  price: z.nullable(z.lazy(() => EntryPrice$outboundSchema)).optional(),
  processDate: z.nullable(z.lazy(() => EntryProcessDate$outboundSchema))
    .optional(),
  quantity: z.nullable(z.lazy(() => EntryQuantity$outboundSchema)).optional(),
  receive: z.nullable(z.lazy(() => Receive$outboundSchema)).optional(),
  redemptionFull: z.nullable(z.lazy(() => RedemptionFull$outboundSchema))
    .optional(),
  redemptionPartial: z.nullable(z.lazy(() => RedemptionPartial$outboundSchema))
    .optional(),
  reverseStockSplit: z.nullable(z.lazy(() => ReverseStockSplit$outboundSchema))
    .optional(),
  reversedEntryId: z.string().optional(),
  rightsDistribution: z.nullable(
    z.lazy(() => RightsDistribution$outboundSchema),
  ).optional(),
  rightsSubscription: z.nullable(
    z.lazy(() => RightsSubscription$outboundSchema),
  ).optional(),
  roundingAdjustment: z.nullable(
    z.lazy(() => RoundingAdjustment$outboundSchema),
  ).optional(),
  saleOfRights: z.nullable(z.lazy(() => SaleOfRights$outboundSchema))
    .optional(),
  settleDate: z.nullable(z.lazy(() => SettleDate$outboundSchema)).optional(),
  side: EntrySide$outboundSchema.optional(),
  sideModifier: EntrySideModifier$outboundSchema.optional(),
  spinOff: z.nullable(z.lazy(() => SpinOff$outboundSchema)).optional(),
  state: EntryState$outboundSchema.optional(),
  stockDividend: z.nullable(z.lazy(() => StockDividend$outboundSchema))
    .optional(),
  stockSplit: z.nullable(z.lazy(() => StockSplit$outboundSchema)).optional(),
  subtypeCategory: z.string().optional(),
  sweep: z.nullable(z.lazy(() => Sweep$outboundSchema)).optional(),
  tenderOffer: z.nullable(z.lazy(() => TenderOffer$outboundSchema)).optional(),
  trade: z.nullable(z.lazy(() => EntryTrade$outboundSchema)).optional(),
  transfer: z.nullable(z.lazy(() => EntryTransfer$outboundSchema)).optional(),
  type: EntryType$outboundSchema.optional(),
  unitSplit: z.nullable(z.lazy(() => UnitSplit$outboundSchema)).optional(),
  warrantExercise: z.nullable(z.lazy(() => WarrantExercise$outboundSchema))
    .optional(),
  withdrawal: z.nullable(z.lazy(() => Withdrawal$outboundSchema)).optional(),
  withdrawalPendingReview: z.nullable(
    z.lazy(() => WithdrawalPendingReview$outboundSchema),
  ).optional(),
  withholding: z.nullable(z.lazy(() => EntryWithholding$outboundSchema))
    .optional(),
  worthless: z.nullable(z.lazy(() => Worthless$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    acatsPendingOut: "acats_pending_out",
    accountId: "account_id",
    accountMemo: "account_memo",
    accountTransfer: "account_transfer",
    accruedInterest: "accrued_interest",
    activityDate: "activity_date",
    activityId: "activity_id",
    activityTime: "activity_time",
    assetId: "asset_id",
    bondDefault: "bond_default",
    capitalGains: "capital_gains",
    cashDividend: "cash_dividend",
    cashInLieu: "cash_in_lieu",
    corporateActionMemoAdjustment: "corporate_action_memo_adjustment",
    currencyAssetId: "currency_asset_id",
    entryId: "entry_id",
    grossAmount: "gross_amount",
    interestPayment: "interest_payment",
    nameChange: "name_change",
    originalId: "original_id",
    originalProcessDate: "original_process_date",
    paymentInKind: "payment_in_kind",
    processDate: "process_date",
    redemptionFull: "redemption_full",
    redemptionPartial: "redemption_partial",
    reverseStockSplit: "reverse_stock_split",
    reversedEntryId: "reversed_entry_id",
    rightsDistribution: "rights_distribution",
    rightsSubscription: "rights_subscription",
    roundingAdjustment: "rounding_adjustment",
    saleOfRights: "sale_of_rights",
    settleDate: "settle_date",
    sideModifier: "side_modifier",
    spinOff: "spin_off",
    stockDividend: "stock_dividend",
    stockSplit: "stock_split",
    subtypeCategory: "subtype_category",
    tenderOffer: "tender_offer",
    unitSplit: "unit_split",
    warrantExercise: "warrant_exercise",
    withdrawalPendingReview: "withdrawal_pending_review",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Entry$ {
  /** @deprecated use `Entry$inboundSchema` instead. */
  export const inboundSchema = Entry$inboundSchema;
  /** @deprecated use `Entry$outboundSchema` instead. */
  export const outboundSchema = Entry$outboundSchema;
  /** @deprecated use `Entry$Outbound` instead. */
  export type Outbound = Entry$Outbound;
}

export function entryToJSON(entry: Entry): string {
  return JSON.stringify(Entry$outboundSchema.parse(entry));
}

export function entryFromJSON(
  jsonString: string,
): SafeParseResult<Entry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Entry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Entry' from JSON`,
  );
}
