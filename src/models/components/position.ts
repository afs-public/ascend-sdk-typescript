/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * `settled` + any as of settled amounts for the date
 */
export type AdjustedSettled = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * `trade` + any as of trade amounts for the date
 */
export type AdjustedTrade = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The date for which the positions were calculated
 */
export type DateT = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Quantity of asset in use by the FPSL program. Should not be used by currency assets
 */
export type PositionFpsl = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Quantity of asset available for allocation for use by the FPSL program. Raw bucket values. These denote that a position is allocated to this purpose. Values may be negative
 */
export type Free = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The most recent date an adjustment occurred
 */
export type LastAdjustedDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Quantity of currency from a dividend being reserved for reinvestment. should not be used by non-currency assets
 */
export type PendingDrip = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Quantity/ amount of asset restricted due to an outgoing acat request
 */
export type PendingOutgoingAcat = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Quantity of currency being reserved for withdrawal. should not be used by non-currency assets
 */
export type PendingWithdrawal = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Computed fieldsOriginal Settled Position before and as-of changesComputed based on the bucket values to represet the total settled position in an account  Currently defined as `free` + `fpsl` + `pending_outgoing_acat` + `drip` + `pending_withdrawal`, but if/when new buckets are added this value will need to change to reflect them
 */
export type Settled = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * original trade position
 */
export type PositionTrade = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Computed based on the bucket values to represent the total unrestricted position in an account. Will always be less than or equal to `settled`  settled - (pending_outgoing_acat + pending_drip + pending_withdrawal) ; however, if/when the API adds new buckets, Apex may adjust this to either incorporate the new value or not
 */
export type Unrestricted = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Position
 */
export type Position = {
  /**
   * A globally unique identifier referencing a single account; this is the main identifier for an account used for machine-to-machine interactions
   */
  accountId?: string | undefined;
  /**
   * `settled` + any as of settled amounts for the date
   */
  adjustedSettled?: AdjustedSettled | null | undefined;
  /**
   * `trade` + any as of trade amounts for the date
   */
  adjustedTrade?: AdjustedTrade | null | undefined;
  /**
   * An Apex-provided, global identifier created on a per asset bases which provides connectivity across all areas
   */
  assetId?: string | undefined;
  /**
   * The correspondent id associated with the account for the position
   */
  correspondentId?: string | undefined;
  /**
   * The date for which the positions were calculated
   */
  date?: DateT | null | undefined;
  /**
   * Quantity of asset in use by the FPSL program. Should not be used by currency assets
   */
  fpsl?: PositionFpsl | null | undefined;
  /**
   * Quantity of asset available for allocation for use by the FPSL program. Raw bucket values. These denote that a position is allocated to this purpose. Values may be negative
   */
  free?: Free | null | undefined;
  /**
   * The most recent date an adjustment occurred
   */
  lastAdjustedDate?: LastAdjustedDate | null | undefined;
  /**
   * accounts/{account_id}/positions/{position_id}
   */
  name?: string | undefined;
  /**
   * Quantity of currency from a dividend being reserved for reinvestment. should not be used by non-currency assets
   */
  pendingDrip?: PendingDrip | null | undefined;
  /**
   * Quantity/ amount of asset restricted due to an outgoing acat request
   */
  pendingOutgoingAcat?: PendingOutgoingAcat | null | undefined;
  /**
   * Quantity of currency being reserved for withdrawal. should not be used by non-currency assets
   */
  pendingWithdrawal?: PendingWithdrawal | null | undefined;
  /**
   * The position version for an asset/account combo. This number only increases, such that larger `position_version`s are newer than lower ones.
   */
  positionVersion?: string | undefined;
  /**
   * Computed fieldsOriginal Settled Position before and as-of changesComputed based on the bucket values to represet the total settled position in an account  Currently defined as `free` + `fpsl` + `pending_outgoing_acat` + `drip` + `pending_withdrawal`, but if/when new buckets are added this value will need to change to reflect them
   */
  settled?: Settled | null | undefined;
  /**
   * original trade position
   */
  trade?: PositionTrade | null | undefined;
  /**
   * Computed based on the bucket values to represent the total unrestricted position in an account. Will always be less than or equal to `settled`  settled - (pending_outgoing_acat + pending_drip + pending_withdrawal) ; however, if/when the API adds new buckets, Apex may adjust this to either incorporate the new value or not
   */
  unrestricted?: Unrestricted | null | undefined;
};

/** @internal */
export const AdjustedSettled$inboundSchema: z.ZodType<
  AdjustedSettled,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type AdjustedSettled$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const AdjustedSettled$outboundSchema: z.ZodType<
  AdjustedSettled$Outbound,
  z.ZodTypeDef,
  AdjustedSettled
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AdjustedSettled$ {
  /** @deprecated use `AdjustedSettled$inboundSchema` instead. */
  export const inboundSchema = AdjustedSettled$inboundSchema;
  /** @deprecated use `AdjustedSettled$outboundSchema` instead. */
  export const outboundSchema = AdjustedSettled$outboundSchema;
  /** @deprecated use `AdjustedSettled$Outbound` instead. */
  export type Outbound = AdjustedSettled$Outbound;
}

export function adjustedSettledToJSON(
  adjustedSettled: AdjustedSettled,
): string {
  return JSON.stringify(AdjustedSettled$outboundSchema.parse(adjustedSettled));
}

export function adjustedSettledFromJSON(
  jsonString: string,
): SafeParseResult<AdjustedSettled, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AdjustedSettled$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AdjustedSettled' from JSON`,
  );
}

/** @internal */
export const AdjustedTrade$inboundSchema: z.ZodType<
  AdjustedTrade,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type AdjustedTrade$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const AdjustedTrade$outboundSchema: z.ZodType<
  AdjustedTrade$Outbound,
  z.ZodTypeDef,
  AdjustedTrade
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AdjustedTrade$ {
  /** @deprecated use `AdjustedTrade$inboundSchema` instead. */
  export const inboundSchema = AdjustedTrade$inboundSchema;
  /** @deprecated use `AdjustedTrade$outboundSchema` instead. */
  export const outboundSchema = AdjustedTrade$outboundSchema;
  /** @deprecated use `AdjustedTrade$Outbound` instead. */
  export type Outbound = AdjustedTrade$Outbound;
}

export function adjustedTradeToJSON(adjustedTrade: AdjustedTrade): string {
  return JSON.stringify(AdjustedTrade$outboundSchema.parse(adjustedTrade));
}

export function adjustedTradeFromJSON(
  jsonString: string,
): SafeParseResult<AdjustedTrade, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AdjustedTrade$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AdjustedTrade' from JSON`,
  );
}

/** @internal */
export const DateT$inboundSchema: z.ZodType<DateT, z.ZodTypeDef, unknown> = z
  .object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
  });

/** @internal */
export type DateT$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const DateT$outboundSchema: z.ZodType<
  DateT$Outbound,
  z.ZodTypeDef,
  DateT
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DateT$ {
  /** @deprecated use `DateT$inboundSchema` instead. */
  export const inboundSchema = DateT$inboundSchema;
  /** @deprecated use `DateT$outboundSchema` instead. */
  export const outboundSchema = DateT$outboundSchema;
  /** @deprecated use `DateT$Outbound` instead. */
  export type Outbound = DateT$Outbound;
}

export function dateToJSON(dateT: DateT): string {
  return JSON.stringify(DateT$outboundSchema.parse(dateT));
}

export function dateFromJSON(
  jsonString: string,
): SafeParseResult<DateT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DateT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DateT' from JSON`,
  );
}

/** @internal */
export const PositionFpsl$inboundSchema: z.ZodType<
  PositionFpsl,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PositionFpsl$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PositionFpsl$outboundSchema: z.ZodType<
  PositionFpsl$Outbound,
  z.ZodTypeDef,
  PositionFpsl
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PositionFpsl$ {
  /** @deprecated use `PositionFpsl$inboundSchema` instead. */
  export const inboundSchema = PositionFpsl$inboundSchema;
  /** @deprecated use `PositionFpsl$outboundSchema` instead. */
  export const outboundSchema = PositionFpsl$outboundSchema;
  /** @deprecated use `PositionFpsl$Outbound` instead. */
  export type Outbound = PositionFpsl$Outbound;
}

export function positionFpslToJSON(positionFpsl: PositionFpsl): string {
  return JSON.stringify(PositionFpsl$outboundSchema.parse(positionFpsl));
}

export function positionFpslFromJSON(
  jsonString: string,
): SafeParseResult<PositionFpsl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PositionFpsl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PositionFpsl' from JSON`,
  );
}

/** @internal */
export const Free$inboundSchema: z.ZodType<Free, z.ZodTypeDef, unknown> = z
  .object({
    value: z.string().optional(),
  });

/** @internal */
export type Free$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const Free$outboundSchema: z.ZodType<Free$Outbound, z.ZodTypeDef, Free> =
  z.object({
    value: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Free$ {
  /** @deprecated use `Free$inboundSchema` instead. */
  export const inboundSchema = Free$inboundSchema;
  /** @deprecated use `Free$outboundSchema` instead. */
  export const outboundSchema = Free$outboundSchema;
  /** @deprecated use `Free$Outbound` instead. */
  export type Outbound = Free$Outbound;
}

export function freeToJSON(free: Free): string {
  return JSON.stringify(Free$outboundSchema.parse(free));
}

export function freeFromJSON(
  jsonString: string,
): SafeParseResult<Free, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Free$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Free' from JSON`,
  );
}

/** @internal */
export const LastAdjustedDate$inboundSchema: z.ZodType<
  LastAdjustedDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type LastAdjustedDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const LastAdjustedDate$outboundSchema: z.ZodType<
  LastAdjustedDate$Outbound,
  z.ZodTypeDef,
  LastAdjustedDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LastAdjustedDate$ {
  /** @deprecated use `LastAdjustedDate$inboundSchema` instead. */
  export const inboundSchema = LastAdjustedDate$inboundSchema;
  /** @deprecated use `LastAdjustedDate$outboundSchema` instead. */
  export const outboundSchema = LastAdjustedDate$outboundSchema;
  /** @deprecated use `LastAdjustedDate$Outbound` instead. */
  export type Outbound = LastAdjustedDate$Outbound;
}

export function lastAdjustedDateToJSON(
  lastAdjustedDate: LastAdjustedDate,
): string {
  return JSON.stringify(
    LastAdjustedDate$outboundSchema.parse(lastAdjustedDate),
  );
}

export function lastAdjustedDateFromJSON(
  jsonString: string,
): SafeParseResult<LastAdjustedDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LastAdjustedDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LastAdjustedDate' from JSON`,
  );
}

/** @internal */
export const PendingDrip$inboundSchema: z.ZodType<
  PendingDrip,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PendingDrip$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PendingDrip$outboundSchema: z.ZodType<
  PendingDrip$Outbound,
  z.ZodTypeDef,
  PendingDrip
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingDrip$ {
  /** @deprecated use `PendingDrip$inboundSchema` instead. */
  export const inboundSchema = PendingDrip$inboundSchema;
  /** @deprecated use `PendingDrip$outboundSchema` instead. */
  export const outboundSchema = PendingDrip$outboundSchema;
  /** @deprecated use `PendingDrip$Outbound` instead. */
  export type Outbound = PendingDrip$Outbound;
}

export function pendingDripToJSON(pendingDrip: PendingDrip): string {
  return JSON.stringify(PendingDrip$outboundSchema.parse(pendingDrip));
}

export function pendingDripFromJSON(
  jsonString: string,
): SafeParseResult<PendingDrip, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingDrip$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingDrip' from JSON`,
  );
}

/** @internal */
export const PendingOutgoingAcat$inboundSchema: z.ZodType<
  PendingOutgoingAcat,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PendingOutgoingAcat$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PendingOutgoingAcat$outboundSchema: z.ZodType<
  PendingOutgoingAcat$Outbound,
  z.ZodTypeDef,
  PendingOutgoingAcat
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingOutgoingAcat$ {
  /** @deprecated use `PendingOutgoingAcat$inboundSchema` instead. */
  export const inboundSchema = PendingOutgoingAcat$inboundSchema;
  /** @deprecated use `PendingOutgoingAcat$outboundSchema` instead. */
  export const outboundSchema = PendingOutgoingAcat$outboundSchema;
  /** @deprecated use `PendingOutgoingAcat$Outbound` instead. */
  export type Outbound = PendingOutgoingAcat$Outbound;
}

export function pendingOutgoingAcatToJSON(
  pendingOutgoingAcat: PendingOutgoingAcat,
): string {
  return JSON.stringify(
    PendingOutgoingAcat$outboundSchema.parse(pendingOutgoingAcat),
  );
}

export function pendingOutgoingAcatFromJSON(
  jsonString: string,
): SafeParseResult<PendingOutgoingAcat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingOutgoingAcat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingOutgoingAcat' from JSON`,
  );
}

/** @internal */
export const PendingWithdrawal$inboundSchema: z.ZodType<
  PendingWithdrawal,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PendingWithdrawal$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PendingWithdrawal$outboundSchema: z.ZodType<
  PendingWithdrawal$Outbound,
  z.ZodTypeDef,
  PendingWithdrawal
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingWithdrawal$ {
  /** @deprecated use `PendingWithdrawal$inboundSchema` instead. */
  export const inboundSchema = PendingWithdrawal$inboundSchema;
  /** @deprecated use `PendingWithdrawal$outboundSchema` instead. */
  export const outboundSchema = PendingWithdrawal$outboundSchema;
  /** @deprecated use `PendingWithdrawal$Outbound` instead. */
  export type Outbound = PendingWithdrawal$Outbound;
}

export function pendingWithdrawalToJSON(
  pendingWithdrawal: PendingWithdrawal,
): string {
  return JSON.stringify(
    PendingWithdrawal$outboundSchema.parse(pendingWithdrawal),
  );
}

export function pendingWithdrawalFromJSON(
  jsonString: string,
): SafeParseResult<PendingWithdrawal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingWithdrawal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingWithdrawal' from JSON`,
  );
}

/** @internal */
export const Settled$inboundSchema: z.ZodType<Settled, z.ZodTypeDef, unknown> =
  z.object({
    value: z.string().optional(),
  });

/** @internal */
export type Settled$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const Settled$outboundSchema: z.ZodType<
  Settled$Outbound,
  z.ZodTypeDef,
  Settled
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Settled$ {
  /** @deprecated use `Settled$inboundSchema` instead. */
  export const inboundSchema = Settled$inboundSchema;
  /** @deprecated use `Settled$outboundSchema` instead. */
  export const outboundSchema = Settled$outboundSchema;
  /** @deprecated use `Settled$Outbound` instead. */
  export type Outbound = Settled$Outbound;
}

export function settledToJSON(settled: Settled): string {
  return JSON.stringify(Settled$outboundSchema.parse(settled));
}

export function settledFromJSON(
  jsonString: string,
): SafeParseResult<Settled, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Settled$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Settled' from JSON`,
  );
}

/** @internal */
export const PositionTrade$inboundSchema: z.ZodType<
  PositionTrade,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PositionTrade$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PositionTrade$outboundSchema: z.ZodType<
  PositionTrade$Outbound,
  z.ZodTypeDef,
  PositionTrade
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PositionTrade$ {
  /** @deprecated use `PositionTrade$inboundSchema` instead. */
  export const inboundSchema = PositionTrade$inboundSchema;
  /** @deprecated use `PositionTrade$outboundSchema` instead. */
  export const outboundSchema = PositionTrade$outboundSchema;
  /** @deprecated use `PositionTrade$Outbound` instead. */
  export type Outbound = PositionTrade$Outbound;
}

export function positionTradeToJSON(positionTrade: PositionTrade): string {
  return JSON.stringify(PositionTrade$outboundSchema.parse(positionTrade));
}

export function positionTradeFromJSON(
  jsonString: string,
): SafeParseResult<PositionTrade, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PositionTrade$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PositionTrade' from JSON`,
  );
}

/** @internal */
export const Unrestricted$inboundSchema: z.ZodType<
  Unrestricted,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type Unrestricted$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const Unrestricted$outboundSchema: z.ZodType<
  Unrestricted$Outbound,
  z.ZodTypeDef,
  Unrestricted
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Unrestricted$ {
  /** @deprecated use `Unrestricted$inboundSchema` instead. */
  export const inboundSchema = Unrestricted$inboundSchema;
  /** @deprecated use `Unrestricted$outboundSchema` instead. */
  export const outboundSchema = Unrestricted$outboundSchema;
  /** @deprecated use `Unrestricted$Outbound` instead. */
  export type Outbound = Unrestricted$Outbound;
}

export function unrestrictedToJSON(unrestricted: Unrestricted): string {
  return JSON.stringify(Unrestricted$outboundSchema.parse(unrestricted));
}

export function unrestrictedFromJSON(
  jsonString: string,
): SafeParseResult<Unrestricted, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Unrestricted$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Unrestricted' from JSON`,
  );
}

/** @internal */
export const Position$inboundSchema: z.ZodType<
  Position,
  z.ZodTypeDef,
  unknown
> = z.object({
  account_id: z.string().optional(),
  adjusted_settled: z.nullable(z.lazy(() => AdjustedSettled$inboundSchema))
    .optional(),
  adjusted_trade: z.nullable(z.lazy(() => AdjustedTrade$inboundSchema))
    .optional(),
  asset_id: z.string().optional(),
  correspondent_id: z.string().optional(),
  date: z.nullable(z.lazy(() => DateT$inboundSchema)).optional(),
  fpsl: z.nullable(z.lazy(() => PositionFpsl$inboundSchema)).optional(),
  free: z.nullable(z.lazy(() => Free$inboundSchema)).optional(),
  last_adjusted_date: z.nullable(z.lazy(() => LastAdjustedDate$inboundSchema))
    .optional(),
  name: z.string().optional(),
  pending_drip: z.nullable(z.lazy(() => PendingDrip$inboundSchema)).optional(),
  pending_outgoing_acat: z.nullable(
    z.lazy(() => PendingOutgoingAcat$inboundSchema),
  ).optional(),
  pending_withdrawal: z.nullable(z.lazy(() => PendingWithdrawal$inboundSchema))
    .optional(),
  position_version: z.string().optional(),
  settled: z.nullable(z.lazy(() => Settled$inboundSchema)).optional(),
  trade: z.nullable(z.lazy(() => PositionTrade$inboundSchema)).optional(),
  unrestricted: z.nullable(z.lazy(() => Unrestricted$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "account_id": "accountId",
    "adjusted_settled": "adjustedSettled",
    "adjusted_trade": "adjustedTrade",
    "asset_id": "assetId",
    "correspondent_id": "correspondentId",
    "last_adjusted_date": "lastAdjustedDate",
    "pending_drip": "pendingDrip",
    "pending_outgoing_acat": "pendingOutgoingAcat",
    "pending_withdrawal": "pendingWithdrawal",
    "position_version": "positionVersion",
  });
});

/** @internal */
export type Position$Outbound = {
  account_id?: string | undefined;
  adjusted_settled?: AdjustedSettled$Outbound | null | undefined;
  adjusted_trade?: AdjustedTrade$Outbound | null | undefined;
  asset_id?: string | undefined;
  correspondent_id?: string | undefined;
  date?: DateT$Outbound | null | undefined;
  fpsl?: PositionFpsl$Outbound | null | undefined;
  free?: Free$Outbound | null | undefined;
  last_adjusted_date?: LastAdjustedDate$Outbound | null | undefined;
  name?: string | undefined;
  pending_drip?: PendingDrip$Outbound | null | undefined;
  pending_outgoing_acat?: PendingOutgoingAcat$Outbound | null | undefined;
  pending_withdrawal?: PendingWithdrawal$Outbound | null | undefined;
  position_version?: string | undefined;
  settled?: Settled$Outbound | null | undefined;
  trade?: PositionTrade$Outbound | null | undefined;
  unrestricted?: Unrestricted$Outbound | null | undefined;
};

/** @internal */
export const Position$outboundSchema: z.ZodType<
  Position$Outbound,
  z.ZodTypeDef,
  Position
> = z.object({
  accountId: z.string().optional(),
  adjustedSettled: z.nullable(z.lazy(() => AdjustedSettled$outboundSchema))
    .optional(),
  adjustedTrade: z.nullable(z.lazy(() => AdjustedTrade$outboundSchema))
    .optional(),
  assetId: z.string().optional(),
  correspondentId: z.string().optional(),
  date: z.nullable(z.lazy(() => DateT$outboundSchema)).optional(),
  fpsl: z.nullable(z.lazy(() => PositionFpsl$outboundSchema)).optional(),
  free: z.nullable(z.lazy(() => Free$outboundSchema)).optional(),
  lastAdjustedDate: z.nullable(z.lazy(() => LastAdjustedDate$outboundSchema))
    .optional(),
  name: z.string().optional(),
  pendingDrip: z.nullable(z.lazy(() => PendingDrip$outboundSchema)).optional(),
  pendingOutgoingAcat: z.nullable(
    z.lazy(() => PendingOutgoingAcat$outboundSchema),
  ).optional(),
  pendingWithdrawal: z.nullable(z.lazy(() => PendingWithdrawal$outboundSchema))
    .optional(),
  positionVersion: z.string().optional(),
  settled: z.nullable(z.lazy(() => Settled$outboundSchema)).optional(),
  trade: z.nullable(z.lazy(() => PositionTrade$outboundSchema)).optional(),
  unrestricted: z.nullable(z.lazy(() => Unrestricted$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    accountId: "account_id",
    adjustedSettled: "adjusted_settled",
    adjustedTrade: "adjusted_trade",
    assetId: "asset_id",
    correspondentId: "correspondent_id",
    lastAdjustedDate: "last_adjusted_date",
    pendingDrip: "pending_drip",
    pendingOutgoingAcat: "pending_outgoing_acat",
    pendingWithdrawal: "pending_withdrawal",
    positionVersion: "position_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Position$ {
  /** @deprecated use `Position$inboundSchema` instead. */
  export const inboundSchema = Position$inboundSchema;
  /** @deprecated use `Position$outboundSchema` instead. */
  export const outboundSchema = Position$outboundSchema;
  /** @deprecated use `Position$Outbound` instead. */
  export type Outbound = Position$Outbound;
}

export function positionToJSON(position: Position): string {
  return JSON.stringify(Position$outboundSchema.parse(position));
}

export function positionFromJSON(
  jsonString: string,
): SafeParseResult<Position, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Position$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Position' from JSON`,
  );
}
