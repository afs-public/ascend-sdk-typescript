/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * This field shows settled positions that have been adjusted to account for as-of transactions (transactions recorded after their actual occurrence). Unlike the settled field, which remains unchanged for historical dates when as-of transactions are recorded, the adjusted_settled field updates to reflect what the position would have been if all transactions had been recorded on their actual dates of occurrence.
 */
export type AdjustedSettled = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * This value reflects trade positions that have been adjusted due to the recording of transactions after their actual occurrence (as-of transactions). The key difference between this field and the trade field is that when an as-of transaction is recorded to the Ledger, the trade field will not change for historical dates, but the adjusted_trade field will update to reflect what the position would have been if the as-of transaction had been recorded on the date of its occurrence
 */
export type AdjustedTrade = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The date for which positions were calculated
 */
export type DateT = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Represents the amount of an asset that has been loaned out via the fully paid securities lending program
 */
export type PositionFpsl = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Represents the amount of an asset that is available to loan by the fully paid securities lending program.
 */
export type Free = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The most recent date a position changed in any way
 */
export type LastAdjustedDate = {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   */
  day?: number | undefined;
  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   */
  month?: number | undefined;
  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   */
  year?: number | undefined;
};

/**
 * Represents the amount of cash that has been paid to an account due to a dividend or capital gain but is due to be reinvested in the security that paid the account holder
 */
export type PendingDrip = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Represents the amount of an asset that is subject to a pending outgoing account transfer, but has not completed the bookkeeping phase of that account transfer
 */
export type PendingOutgoingAcat = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Represents the amount of cash that has been requested for withdrawal but has not posted to the Ledger
 */
export type PendingWithdrawal = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * This field refers to the quantity of assets that have completed the entire clearing and settlement cycle, where ownership of the securities has been officially transferred and payment has been fully processed. The settled position includes all transactions that have been recorded in the Ledger with process_date, activity_date, and settle_date on or before the date specified in the response.
 */
export type Settled = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * This field represents the total amount of an asset owned by the account including transactions that have been executed but not yet settled, commonly known as the trade date position. It includes all transactions recorded in the Ledger with process_date and activity_date on or before the date in the response, even those with future settle_dates. Unlike the settled position, which only includes completed settlements, the trade position provides a forward-looking view of ownership that accounts for pending settlements
 */
export type PositionTrade = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * This field represents the portion of a settled position that is available for trading or withdrawal without restrictions. It is calculated by subtracting positions with pending restrictions from the total settled amount (currently: settled - (pending_outgoing_acat + pending_drip + pending_withdrawal)). As new memo location categories are added to the API, Apex may update this calculation to incorporate these values. Note that the Cash and Margin systems may place additional restrictions on cash/ assets according to their business logic.
 */
export type Unrestricted = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Position
 */
export type Position = {
  /**
   * A globally unique identifier referencing a single account; this is the main identifier for an account used for machine-to-machine interactions
   */
  accountId?: string | undefined;
  /**
   * This field shows settled positions that have been adjusted to account for as-of transactions (transactions recorded after their actual occurrence). Unlike the settled field, which remains unchanged for historical dates when as-of transactions are recorded, the adjusted_settled field updates to reflect what the position would have been if all transactions had been recorded on their actual dates of occurrence.
   */
  adjustedSettled?: AdjustedSettled | null | undefined;
  /**
   * This value reflects trade positions that have been adjusted due to the recording of transactions after their actual occurrence (as-of transactions). The key difference between this field and the trade field is that when an as-of transaction is recorded to the Ledger, the trade field will not change for historical dates, but the adjusted_trade field will update to reflect what the position would have been if the as-of transaction had been recorded on the date of its occurrence
   */
  adjustedTrade?: AdjustedTrade | null | undefined;
  /**
   * An Apex-provided, global identifier created on a per asset bases which provides connectivity across all areas
   */
  assetId?: string | undefined;
  /**
   * The correspondent id associated with the account for the position
   */
  correspondentId?: string | undefined;
  /**
   * The date for which positions were calculated
   */
  date?: DateT | null | undefined;
  /**
   * Represents the amount of an asset that has been loaned out via the fully paid securities lending program
   */
  fpsl?: PositionFpsl | null | undefined;
  /**
   * Represents the amount of an asset that is available to loan by the fully paid securities lending program.
   */
  free?: Free | null | undefined;
  /**
   * The most recent date a position changed in any way
   */
  lastAdjustedDate?: LastAdjustedDate | null | undefined;
  /**
   * accounts/{account_id}/positions/{position_id}
   */
  name?: string | undefined;
  /**
   * Represents the amount of cash that has been paid to an account due to a dividend or capital gain but is due to be reinvested in the security that paid the account holder
   */
  pendingDrip?: PendingDrip | null | undefined;
  /**
   * Represents the amount of an asset that is subject to a pending outgoing account transfer, but has not completed the bookkeeping phase of that account transfer
   */
  pendingOutgoingAcat?: PendingOutgoingAcat | null | undefined;
  /**
   * Represents the amount of cash that has been requested for withdrawal but has not posted to the Ledger
   */
  pendingWithdrawal?: PendingWithdrawal | null | undefined;
  /**
   * Represents a chronologically-ordered version identifier that enables efficient position state tracking and event ordering. The system guarantees that positions from earlier dates have smaller version numbers than those from later dates
   */
  positionVersion?: string | undefined;
  /**
   * This field refers to the quantity of assets that have completed the entire clearing and settlement cycle, where ownership of the securities has been officially transferred and payment has been fully processed. The settled position includes all transactions that have been recorded in the Ledger with process_date, activity_date, and settle_date on or before the date specified in the response.
   */
  settled?: Settled | null | undefined;
  /**
   * This field represents the total amount of an asset owned by the account including transactions that have been executed but not yet settled, commonly known as the trade date position. It includes all transactions recorded in the Ledger with process_date and activity_date on or before the date in the response, even those with future settle_dates. Unlike the settled position, which only includes completed settlements, the trade position provides a forward-looking view of ownership that accounts for pending settlements
   */
  trade?: PositionTrade | null | undefined;
  /**
   * This field represents the portion of a settled position that is available for trading or withdrawal without restrictions. It is calculated by subtracting positions with pending restrictions from the total settled amount (currently: settled - (pending_outgoing_acat + pending_drip + pending_withdrawal)). As new memo location categories are added to the API, Apex may update this calculation to incorporate these values. Note that the Cash and Margin systems may place additional restrictions on cash/ assets according to their business logic.
   */
  unrestricted?: Unrestricted | null | undefined;
};

/** @internal */
export const AdjustedSettled$inboundSchema: z.ZodType<
  AdjustedSettled,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type AdjustedSettled$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const AdjustedSettled$outboundSchema: z.ZodType<
  AdjustedSettled$Outbound,
  z.ZodTypeDef,
  AdjustedSettled
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AdjustedSettled$ {
  /** @deprecated use `AdjustedSettled$inboundSchema` instead. */
  export const inboundSchema = AdjustedSettled$inboundSchema;
  /** @deprecated use `AdjustedSettled$outboundSchema` instead. */
  export const outboundSchema = AdjustedSettled$outboundSchema;
  /** @deprecated use `AdjustedSettled$Outbound` instead. */
  export type Outbound = AdjustedSettled$Outbound;
}

export function adjustedSettledToJSON(
  adjustedSettled: AdjustedSettled,
): string {
  return JSON.stringify(AdjustedSettled$outboundSchema.parse(adjustedSettled));
}

export function adjustedSettledFromJSON(
  jsonString: string,
): SafeParseResult<AdjustedSettled, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AdjustedSettled$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AdjustedSettled' from JSON`,
  );
}

/** @internal */
export const AdjustedTrade$inboundSchema: z.ZodType<
  AdjustedTrade,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type AdjustedTrade$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const AdjustedTrade$outboundSchema: z.ZodType<
  AdjustedTrade$Outbound,
  z.ZodTypeDef,
  AdjustedTrade
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AdjustedTrade$ {
  /** @deprecated use `AdjustedTrade$inboundSchema` instead. */
  export const inboundSchema = AdjustedTrade$inboundSchema;
  /** @deprecated use `AdjustedTrade$outboundSchema` instead. */
  export const outboundSchema = AdjustedTrade$outboundSchema;
  /** @deprecated use `AdjustedTrade$Outbound` instead. */
  export type Outbound = AdjustedTrade$Outbound;
}

export function adjustedTradeToJSON(adjustedTrade: AdjustedTrade): string {
  return JSON.stringify(AdjustedTrade$outboundSchema.parse(adjustedTrade));
}

export function adjustedTradeFromJSON(
  jsonString: string,
): SafeParseResult<AdjustedTrade, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AdjustedTrade$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AdjustedTrade' from JSON`,
  );
}

/** @internal */
export const DateT$inboundSchema: z.ZodType<DateT, z.ZodTypeDef, unknown> = z
  .object({
    day: z.number().int().optional(),
    month: z.number().int().optional(),
    year: z.number().int().optional(),
  });

/** @internal */
export type DateT$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const DateT$outboundSchema: z.ZodType<
  DateT$Outbound,
  z.ZodTypeDef,
  DateT
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DateT$ {
  /** @deprecated use `DateT$inboundSchema` instead. */
  export const inboundSchema = DateT$inboundSchema;
  /** @deprecated use `DateT$outboundSchema` instead. */
  export const outboundSchema = DateT$outboundSchema;
  /** @deprecated use `DateT$Outbound` instead. */
  export type Outbound = DateT$Outbound;
}

export function dateToJSON(dateT: DateT): string {
  return JSON.stringify(DateT$outboundSchema.parse(dateT));
}

export function dateFromJSON(
  jsonString: string,
): SafeParseResult<DateT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DateT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DateT' from JSON`,
  );
}

/** @internal */
export const PositionFpsl$inboundSchema: z.ZodType<
  PositionFpsl,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PositionFpsl$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PositionFpsl$outboundSchema: z.ZodType<
  PositionFpsl$Outbound,
  z.ZodTypeDef,
  PositionFpsl
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PositionFpsl$ {
  /** @deprecated use `PositionFpsl$inboundSchema` instead. */
  export const inboundSchema = PositionFpsl$inboundSchema;
  /** @deprecated use `PositionFpsl$outboundSchema` instead. */
  export const outboundSchema = PositionFpsl$outboundSchema;
  /** @deprecated use `PositionFpsl$Outbound` instead. */
  export type Outbound = PositionFpsl$Outbound;
}

export function positionFpslToJSON(positionFpsl: PositionFpsl): string {
  return JSON.stringify(PositionFpsl$outboundSchema.parse(positionFpsl));
}

export function positionFpslFromJSON(
  jsonString: string,
): SafeParseResult<PositionFpsl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PositionFpsl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PositionFpsl' from JSON`,
  );
}

/** @internal */
export const Free$inboundSchema: z.ZodType<Free, z.ZodTypeDef, unknown> = z
  .object({
    value: z.string().optional(),
  });

/** @internal */
export type Free$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const Free$outboundSchema: z.ZodType<Free$Outbound, z.ZodTypeDef, Free> =
  z.object({
    value: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Free$ {
  /** @deprecated use `Free$inboundSchema` instead. */
  export const inboundSchema = Free$inboundSchema;
  /** @deprecated use `Free$outboundSchema` instead. */
  export const outboundSchema = Free$outboundSchema;
  /** @deprecated use `Free$Outbound` instead. */
  export type Outbound = Free$Outbound;
}

export function freeToJSON(free: Free): string {
  return JSON.stringify(Free$outboundSchema.parse(free));
}

export function freeFromJSON(
  jsonString: string,
): SafeParseResult<Free, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Free$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Free' from JSON`,
  );
}

/** @internal */
export const LastAdjustedDate$inboundSchema: z.ZodType<
  LastAdjustedDate,
  z.ZodTypeDef,
  unknown
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/** @internal */
export type LastAdjustedDate$Outbound = {
  day?: number | undefined;
  month?: number | undefined;
  year?: number | undefined;
};

/** @internal */
export const LastAdjustedDate$outboundSchema: z.ZodType<
  LastAdjustedDate$Outbound,
  z.ZodTypeDef,
  LastAdjustedDate
> = z.object({
  day: z.number().int().optional(),
  month: z.number().int().optional(),
  year: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LastAdjustedDate$ {
  /** @deprecated use `LastAdjustedDate$inboundSchema` instead. */
  export const inboundSchema = LastAdjustedDate$inboundSchema;
  /** @deprecated use `LastAdjustedDate$outboundSchema` instead. */
  export const outboundSchema = LastAdjustedDate$outboundSchema;
  /** @deprecated use `LastAdjustedDate$Outbound` instead. */
  export type Outbound = LastAdjustedDate$Outbound;
}

export function lastAdjustedDateToJSON(
  lastAdjustedDate: LastAdjustedDate,
): string {
  return JSON.stringify(
    LastAdjustedDate$outboundSchema.parse(lastAdjustedDate),
  );
}

export function lastAdjustedDateFromJSON(
  jsonString: string,
): SafeParseResult<LastAdjustedDate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LastAdjustedDate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LastAdjustedDate' from JSON`,
  );
}

/** @internal */
export const PendingDrip$inboundSchema: z.ZodType<
  PendingDrip,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PendingDrip$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PendingDrip$outboundSchema: z.ZodType<
  PendingDrip$Outbound,
  z.ZodTypeDef,
  PendingDrip
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingDrip$ {
  /** @deprecated use `PendingDrip$inboundSchema` instead. */
  export const inboundSchema = PendingDrip$inboundSchema;
  /** @deprecated use `PendingDrip$outboundSchema` instead. */
  export const outboundSchema = PendingDrip$outboundSchema;
  /** @deprecated use `PendingDrip$Outbound` instead. */
  export type Outbound = PendingDrip$Outbound;
}

export function pendingDripToJSON(pendingDrip: PendingDrip): string {
  return JSON.stringify(PendingDrip$outboundSchema.parse(pendingDrip));
}

export function pendingDripFromJSON(
  jsonString: string,
): SafeParseResult<PendingDrip, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingDrip$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingDrip' from JSON`,
  );
}

/** @internal */
export const PendingOutgoingAcat$inboundSchema: z.ZodType<
  PendingOutgoingAcat,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PendingOutgoingAcat$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PendingOutgoingAcat$outboundSchema: z.ZodType<
  PendingOutgoingAcat$Outbound,
  z.ZodTypeDef,
  PendingOutgoingAcat
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingOutgoingAcat$ {
  /** @deprecated use `PendingOutgoingAcat$inboundSchema` instead. */
  export const inboundSchema = PendingOutgoingAcat$inboundSchema;
  /** @deprecated use `PendingOutgoingAcat$outboundSchema` instead. */
  export const outboundSchema = PendingOutgoingAcat$outboundSchema;
  /** @deprecated use `PendingOutgoingAcat$Outbound` instead. */
  export type Outbound = PendingOutgoingAcat$Outbound;
}

export function pendingOutgoingAcatToJSON(
  pendingOutgoingAcat: PendingOutgoingAcat,
): string {
  return JSON.stringify(
    PendingOutgoingAcat$outboundSchema.parse(pendingOutgoingAcat),
  );
}

export function pendingOutgoingAcatFromJSON(
  jsonString: string,
): SafeParseResult<PendingOutgoingAcat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingOutgoingAcat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingOutgoingAcat' from JSON`,
  );
}

/** @internal */
export const PendingWithdrawal$inboundSchema: z.ZodType<
  PendingWithdrawal,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PendingWithdrawal$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PendingWithdrawal$outboundSchema: z.ZodType<
  PendingWithdrawal$Outbound,
  z.ZodTypeDef,
  PendingWithdrawal
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PendingWithdrawal$ {
  /** @deprecated use `PendingWithdrawal$inboundSchema` instead. */
  export const inboundSchema = PendingWithdrawal$inboundSchema;
  /** @deprecated use `PendingWithdrawal$outboundSchema` instead. */
  export const outboundSchema = PendingWithdrawal$outboundSchema;
  /** @deprecated use `PendingWithdrawal$Outbound` instead. */
  export type Outbound = PendingWithdrawal$Outbound;
}

export function pendingWithdrawalToJSON(
  pendingWithdrawal: PendingWithdrawal,
): string {
  return JSON.stringify(
    PendingWithdrawal$outboundSchema.parse(pendingWithdrawal),
  );
}

export function pendingWithdrawalFromJSON(
  jsonString: string,
): SafeParseResult<PendingWithdrawal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingWithdrawal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingWithdrawal' from JSON`,
  );
}

/** @internal */
export const Settled$inboundSchema: z.ZodType<Settled, z.ZodTypeDef, unknown> =
  z.object({
    value: z.string().optional(),
  });

/** @internal */
export type Settled$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const Settled$outboundSchema: z.ZodType<
  Settled$Outbound,
  z.ZodTypeDef,
  Settled
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Settled$ {
  /** @deprecated use `Settled$inboundSchema` instead. */
  export const inboundSchema = Settled$inboundSchema;
  /** @deprecated use `Settled$outboundSchema` instead. */
  export const outboundSchema = Settled$outboundSchema;
  /** @deprecated use `Settled$Outbound` instead. */
  export type Outbound = Settled$Outbound;
}

export function settledToJSON(settled: Settled): string {
  return JSON.stringify(Settled$outboundSchema.parse(settled));
}

export function settledFromJSON(
  jsonString: string,
): SafeParseResult<Settled, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Settled$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Settled' from JSON`,
  );
}

/** @internal */
export const PositionTrade$inboundSchema: z.ZodType<
  PositionTrade,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type PositionTrade$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const PositionTrade$outboundSchema: z.ZodType<
  PositionTrade$Outbound,
  z.ZodTypeDef,
  PositionTrade
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PositionTrade$ {
  /** @deprecated use `PositionTrade$inboundSchema` instead. */
  export const inboundSchema = PositionTrade$inboundSchema;
  /** @deprecated use `PositionTrade$outboundSchema` instead. */
  export const outboundSchema = PositionTrade$outboundSchema;
  /** @deprecated use `PositionTrade$Outbound` instead. */
  export type Outbound = PositionTrade$Outbound;
}

export function positionTradeToJSON(positionTrade: PositionTrade): string {
  return JSON.stringify(PositionTrade$outboundSchema.parse(positionTrade));
}

export function positionTradeFromJSON(
  jsonString: string,
): SafeParseResult<PositionTrade, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PositionTrade$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PositionTrade' from JSON`,
  );
}

/** @internal */
export const Unrestricted$inboundSchema: z.ZodType<
  Unrestricted,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type Unrestricted$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const Unrestricted$outboundSchema: z.ZodType<
  Unrestricted$Outbound,
  z.ZodTypeDef,
  Unrestricted
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Unrestricted$ {
  /** @deprecated use `Unrestricted$inboundSchema` instead. */
  export const inboundSchema = Unrestricted$inboundSchema;
  /** @deprecated use `Unrestricted$outboundSchema` instead. */
  export const outboundSchema = Unrestricted$outboundSchema;
  /** @deprecated use `Unrestricted$Outbound` instead. */
  export type Outbound = Unrestricted$Outbound;
}

export function unrestrictedToJSON(unrestricted: Unrestricted): string {
  return JSON.stringify(Unrestricted$outboundSchema.parse(unrestricted));
}

export function unrestrictedFromJSON(
  jsonString: string,
): SafeParseResult<Unrestricted, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Unrestricted$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Unrestricted' from JSON`,
  );
}

/** @internal */
export const Position$inboundSchema: z.ZodType<
  Position,
  z.ZodTypeDef,
  unknown
> = z.object({
  account_id: z.string().optional(),
  adjusted_settled: z.nullable(z.lazy(() => AdjustedSettled$inboundSchema))
    .optional(),
  adjusted_trade: z.nullable(z.lazy(() => AdjustedTrade$inboundSchema))
    .optional(),
  asset_id: z.string().optional(),
  correspondent_id: z.string().optional(),
  date: z.nullable(z.lazy(() => DateT$inboundSchema)).optional(),
  fpsl: z.nullable(z.lazy(() => PositionFpsl$inboundSchema)).optional(),
  free: z.nullable(z.lazy(() => Free$inboundSchema)).optional(),
  last_adjusted_date: z.nullable(z.lazy(() => LastAdjustedDate$inboundSchema))
    .optional(),
  name: z.string().optional(),
  pending_drip: z.nullable(z.lazy(() => PendingDrip$inboundSchema)).optional(),
  pending_outgoing_acat: z.nullable(
    z.lazy(() => PendingOutgoingAcat$inboundSchema),
  ).optional(),
  pending_withdrawal: z.nullable(z.lazy(() => PendingWithdrawal$inboundSchema))
    .optional(),
  position_version: z.string().optional(),
  settled: z.nullable(z.lazy(() => Settled$inboundSchema)).optional(),
  trade: z.nullable(z.lazy(() => PositionTrade$inboundSchema)).optional(),
  unrestricted: z.nullable(z.lazy(() => Unrestricted$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "account_id": "accountId",
    "adjusted_settled": "adjustedSettled",
    "adjusted_trade": "adjustedTrade",
    "asset_id": "assetId",
    "correspondent_id": "correspondentId",
    "last_adjusted_date": "lastAdjustedDate",
    "pending_drip": "pendingDrip",
    "pending_outgoing_acat": "pendingOutgoingAcat",
    "pending_withdrawal": "pendingWithdrawal",
    "position_version": "positionVersion",
  });
});

/** @internal */
export type Position$Outbound = {
  account_id?: string | undefined;
  adjusted_settled?: AdjustedSettled$Outbound | null | undefined;
  adjusted_trade?: AdjustedTrade$Outbound | null | undefined;
  asset_id?: string | undefined;
  correspondent_id?: string | undefined;
  date?: DateT$Outbound | null | undefined;
  fpsl?: PositionFpsl$Outbound | null | undefined;
  free?: Free$Outbound | null | undefined;
  last_adjusted_date?: LastAdjustedDate$Outbound | null | undefined;
  name?: string | undefined;
  pending_drip?: PendingDrip$Outbound | null | undefined;
  pending_outgoing_acat?: PendingOutgoingAcat$Outbound | null | undefined;
  pending_withdrawal?: PendingWithdrawal$Outbound | null | undefined;
  position_version?: string | undefined;
  settled?: Settled$Outbound | null | undefined;
  trade?: PositionTrade$Outbound | null | undefined;
  unrestricted?: Unrestricted$Outbound | null | undefined;
};

/** @internal */
export const Position$outboundSchema: z.ZodType<
  Position$Outbound,
  z.ZodTypeDef,
  Position
> = z.object({
  accountId: z.string().optional(),
  adjustedSettled: z.nullable(z.lazy(() => AdjustedSettled$outboundSchema))
    .optional(),
  adjustedTrade: z.nullable(z.lazy(() => AdjustedTrade$outboundSchema))
    .optional(),
  assetId: z.string().optional(),
  correspondentId: z.string().optional(),
  date: z.nullable(z.lazy(() => DateT$outboundSchema)).optional(),
  fpsl: z.nullable(z.lazy(() => PositionFpsl$outboundSchema)).optional(),
  free: z.nullable(z.lazy(() => Free$outboundSchema)).optional(),
  lastAdjustedDate: z.nullable(z.lazy(() => LastAdjustedDate$outboundSchema))
    .optional(),
  name: z.string().optional(),
  pendingDrip: z.nullable(z.lazy(() => PendingDrip$outboundSchema)).optional(),
  pendingOutgoingAcat: z.nullable(
    z.lazy(() => PendingOutgoingAcat$outboundSchema),
  ).optional(),
  pendingWithdrawal: z.nullable(z.lazy(() => PendingWithdrawal$outboundSchema))
    .optional(),
  positionVersion: z.string().optional(),
  settled: z.nullable(z.lazy(() => Settled$outboundSchema)).optional(),
  trade: z.nullable(z.lazy(() => PositionTrade$outboundSchema)).optional(),
  unrestricted: z.nullable(z.lazy(() => Unrestricted$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    accountId: "account_id",
    adjustedSettled: "adjusted_settled",
    adjustedTrade: "adjusted_trade",
    assetId: "asset_id",
    correspondentId: "correspondent_id",
    lastAdjustedDate: "last_adjusted_date",
    pendingDrip: "pending_drip",
    pendingOutgoingAcat: "pending_outgoing_acat",
    pendingWithdrawal: "pending_withdrawal",
    positionVersion: "position_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Position$ {
  /** @deprecated use `Position$inboundSchema` instead. */
  export const inboundSchema = Position$inboundSchema;
  /** @deprecated use `Position$outboundSchema` instead. */
  export const outboundSchema = Position$outboundSchema;
  /** @deprecated use `Position$Outbound` instead. */
  export type Outbound = Position$Outbound;
}

export function positionToJSON(position: Position): string {
  return JSON.stringify(Position$outboundSchema.parse(position));
}

export function positionFromJSON(
  jsonString: string,
): SafeParseResult<Position, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Position$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Position' from JSON`,
  );
}
