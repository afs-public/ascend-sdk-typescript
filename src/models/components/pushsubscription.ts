/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The information about an HTTP target callback
 */
export type HttpCallback = {
  /**
   * The maximum amount of time, in seconds, the service will wait for an acknowledgement of a delivery; If a value of 0 or no value is specified, the timeout will default to 10 seconds
   */
  timeoutSeconds?: number | undefined;
  /**
   * The URL address of the client HTTP server that will receive the events via POST; URLs must be in the form of https://{domain}[/{path}]
   */
  url?: string | undefined;
};

/**
 * The current status of the subscription
 */
export enum State {
  PushSubscriptionStateUnspecified = "PUSH_SUBSCRIPTION_STATE_UNSPECIFIED",
  Creating = "CREATING",
  Active = "ACTIVE",
  Updating = "UPDATING",
  Deleting = "DELETING",
}
/**
 * The current status of the subscription
 */
export type StateOpen = OpenEnum<typeof State>;

/**
 * Configuration information about a push subscription
 */
export type PushSubscription = {
  /**
   * The id of the account group to receive events for; The subscription will receive events related to any of the accounts in the specified account group; This can only be set at creation time and is mutually exclusive with client_id and correspondent_id
   */
  accountGroupId?: string | undefined;
  /**
   * The id of the client to receive events for; The subscription will receive events related to the specified client, and any of its correspondents and accounts; This can only be set at creation time and is mutually exclusive with correspondent_id and account_group_id
   */
  clientId?: string | undefined;
  /**
   * The id of the correspondent to receive events for; The subscription will receive events related to the specified correspondent and any of its accounts; This can only be set at creation time and is mutually exclusive with client_id and account_group_id
   */
  correspondentId?: string | undefined;
  /**
   * The user-defined name for the subscription
   */
  displayName?: string | undefined;
  /**
   * Filter for event types; ["\*"] matches all values; Suffix wildcards using "\*" (e.g. ["account.\*"]) are supported
   */
  eventTypes?: Array<string> | undefined;
  /**
   * The information about an HTTP target callback
   */
  httpCallback?: HttpCallback | null | undefined;
  /**
   * The resource name of the subscription; Format: subscriptions/{subscription}
   */
  name?: string | undefined;
  /**
   * The organization that owns the subscription; Format: {org_type}/{org_id} This field can only be set at creation time and if it is not specified, then it will default to the target organization, unless the target is an account group, in which case this field is required
   */
  owner?: string | undefined;
  /**
   * The current status of the subscription
   */
  state?: StateOpen | undefined;
  /**
   * The unique identifier for the subscription
   */
  subscriptionId?: string | undefined;
};

/** @internal */
export const HttpCallback$inboundSchema: z.ZodType<
  HttpCallback,
  z.ZodTypeDef,
  unknown
> = z.object({
  timeout_seconds: z.number().int().optional(),
  url: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "timeout_seconds": "timeoutSeconds",
  });
});

/** @internal */
export type HttpCallback$Outbound = {
  timeout_seconds?: number | undefined;
  url?: string | undefined;
};

/** @internal */
export const HttpCallback$outboundSchema: z.ZodType<
  HttpCallback$Outbound,
  z.ZodTypeDef,
  HttpCallback
> = z.object({
  timeoutSeconds: z.number().int().optional(),
  url: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    timeoutSeconds: "timeout_seconds",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace HttpCallback$ {
  /** @deprecated use `HttpCallback$inboundSchema` instead. */
  export const inboundSchema = HttpCallback$inboundSchema;
  /** @deprecated use `HttpCallback$outboundSchema` instead. */
  export const outboundSchema = HttpCallback$outboundSchema;
  /** @deprecated use `HttpCallback$Outbound` instead. */
  export type Outbound = HttpCallback$Outbound;
}

export function httpCallbackToJSON(httpCallback: HttpCallback): string {
  return JSON.stringify(HttpCallback$outboundSchema.parse(httpCallback));
}

export function httpCallbackFromJSON(
  jsonString: string,
): SafeParseResult<HttpCallback, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HttpCallback$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HttpCallback' from JSON`,
  );
}

/** @internal */
export const State$inboundSchema: z.ZodType<StateOpen, z.ZodTypeDef, unknown> =
  z
    .union([
      z.nativeEnum(State),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const State$outboundSchema: z.ZodType<
  StateOpen,
  z.ZodTypeDef,
  StateOpen
> = z.union([
  z.nativeEnum(State),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace State$ {
  /** @deprecated use `State$inboundSchema` instead. */
  export const inboundSchema = State$inboundSchema;
  /** @deprecated use `State$outboundSchema` instead. */
  export const outboundSchema = State$outboundSchema;
}

/** @internal */
export const PushSubscription$inboundSchema: z.ZodType<
  PushSubscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  account_group_id: z.string().optional(),
  client_id: z.string().optional(),
  correspondent_id: z.string().optional(),
  display_name: z.string().optional(),
  event_types: z.array(z.string()).optional(),
  http_callback: z.nullable(z.lazy(() => HttpCallback$inboundSchema))
    .optional(),
  name: z.string().optional(),
  owner: z.string().optional(),
  state: State$inboundSchema.optional(),
  subscription_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "account_group_id": "accountGroupId",
    "client_id": "clientId",
    "correspondent_id": "correspondentId",
    "display_name": "displayName",
    "event_types": "eventTypes",
    "http_callback": "httpCallback",
    "subscription_id": "subscriptionId",
  });
});

/** @internal */
export type PushSubscription$Outbound = {
  account_group_id?: string | undefined;
  client_id?: string | undefined;
  correspondent_id?: string | undefined;
  display_name?: string | undefined;
  event_types?: Array<string> | undefined;
  http_callback?: HttpCallback$Outbound | null | undefined;
  name?: string | undefined;
  owner?: string | undefined;
  state?: string | undefined;
  subscription_id?: string | undefined;
};

/** @internal */
export const PushSubscription$outboundSchema: z.ZodType<
  PushSubscription$Outbound,
  z.ZodTypeDef,
  PushSubscription
> = z.object({
  accountGroupId: z.string().optional(),
  clientId: z.string().optional(),
  correspondentId: z.string().optional(),
  displayName: z.string().optional(),
  eventTypes: z.array(z.string()).optional(),
  httpCallback: z.nullable(z.lazy(() => HttpCallback$outboundSchema))
    .optional(),
  name: z.string().optional(),
  owner: z.string().optional(),
  state: State$outboundSchema.optional(),
  subscriptionId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    accountGroupId: "account_group_id",
    clientId: "client_id",
    correspondentId: "correspondent_id",
    displayName: "display_name",
    eventTypes: "event_types",
    httpCallback: "http_callback",
    subscriptionId: "subscription_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushSubscription$ {
  /** @deprecated use `PushSubscription$inboundSchema` instead. */
  export const inboundSchema = PushSubscription$inboundSchema;
  /** @deprecated use `PushSubscription$outboundSchema` instead. */
  export const outboundSchema = PushSubscription$outboundSchema;
  /** @deprecated use `PushSubscription$Outbound` instead. */
  export type Outbound = PushSubscription$Outbound;
}

export function pushSubscriptionToJSON(
  pushSubscription: PushSubscription,
): string {
  return JSON.stringify(
    PushSubscription$outboundSchema.parse(pushSubscription),
  );
}

export function pushSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<PushSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushSubscription' from JSON`,
  );
}
