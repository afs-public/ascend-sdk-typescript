/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  LatLngCreate,
  LatLngCreate$inboundSchema,
  LatLngCreate$Outbound,
  LatLngCreate$outboundSchema,
} from "./latlngcreate.js";

/**
 * The type of device (e.g., mobile, desktop, tablet)
 */
export enum DeviceType {
  DeviceTypeUnspecified = "DEVICE_TYPE_UNSPECIFIED",
  Desktop = "DESKTOP",
  Mobile = "MOBILE",
  Tablet = "TABLET",
}
/**
 * The type of device (e.g., mobile, desktop, tablet)
 */
export type DeviceTypeOpen = OpenEnum<typeof DeviceType>;

/**
 * Method used to determine the end-user's device geolocation
 */
export enum GeolocationMechanism {
  GeolocationMechanismUnspecified = "GEOLOCATION_MECHANISM_UNSPECIFIED",
  DeviceGps = "DEVICE_GPS",
  IpLookup = "IP_LOOKUP",
}
/**
 * Method used to determine the end-user's device geolocation
 */
export type GeolocationMechanismOpen = OpenEnum<typeof GeolocationMechanism>;

/**
 * End-user device metadata for fraud detection and compliance All fields must represent the actual end-user's device, not any intermediate proxy or client server through which requests may be routed
 */
export type DeviceMetadataCreate = {
  /**
   * Unique identifier for the device
   */
  deviceId?: string | undefined;
  /**
   * The type of device (e.g., mobile, desktop, tablet)
   */
  deviceType?: DeviceTypeOpen | undefined;
  /**
   * An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84 standard</a>. Values must be within normalized ranges.
   */
  geolocation?: LatLngCreate | undefined;
  /**
   * Method used to determine the end-user's device geolocation
   */
  geolocationMechanism?: GeolocationMechanismOpen | undefined;
  /**
   * The IP address of the end-user's device This must be the actual end-user's IP address, not the IP of any proxy or client server Must be a valid IPv4 or IPv6 address format IPv4 examples: "203.0.113.42", "198.51.100.1", "8.8.8.8" IPv6 examples: "2001:0db8:85a3::8a2e:0370:7334", "2606:4700:4700::1111"
   */
  ipAddress: string;
  /**
   * The user agent string from the end-user's device browser or application
   */
  userAgent?: string | undefined;
};

/** @internal */
export const DeviceType$inboundSchema: z.ZodType<
  DeviceTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(DeviceType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const DeviceType$outboundSchema: z.ZodType<
  DeviceTypeOpen,
  z.ZodTypeDef,
  DeviceTypeOpen
> = z.union([
  z.nativeEnum(DeviceType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeviceType$ {
  /** @deprecated use `DeviceType$inboundSchema` instead. */
  export const inboundSchema = DeviceType$inboundSchema;
  /** @deprecated use `DeviceType$outboundSchema` instead. */
  export const outboundSchema = DeviceType$outboundSchema;
}

/** @internal */
export const GeolocationMechanism$inboundSchema: z.ZodType<
  GeolocationMechanismOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GeolocationMechanism),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GeolocationMechanism$outboundSchema: z.ZodType<
  GeolocationMechanismOpen,
  z.ZodTypeDef,
  GeolocationMechanismOpen
> = z.union([
  z.nativeEnum(GeolocationMechanism),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeolocationMechanism$ {
  /** @deprecated use `GeolocationMechanism$inboundSchema` instead. */
  export const inboundSchema = GeolocationMechanism$inboundSchema;
  /** @deprecated use `GeolocationMechanism$outboundSchema` instead. */
  export const outboundSchema = GeolocationMechanism$outboundSchema;
}

/** @internal */
export const DeviceMetadataCreate$inboundSchema: z.ZodType<
  DeviceMetadataCreate,
  z.ZodTypeDef,
  unknown
> = z.object({
  device_id: z.string().optional(),
  device_type: DeviceType$inboundSchema.optional(),
  geolocation: LatLngCreate$inboundSchema.optional(),
  geolocation_mechanism: GeolocationMechanism$inboundSchema.optional(),
  ip_address: z.string(),
  user_agent: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "device_id": "deviceId",
    "device_type": "deviceType",
    "geolocation_mechanism": "geolocationMechanism",
    "ip_address": "ipAddress",
    "user_agent": "userAgent",
  });
});

/** @internal */
export type DeviceMetadataCreate$Outbound = {
  device_id?: string | undefined;
  device_type?: string | undefined;
  geolocation?: LatLngCreate$Outbound | undefined;
  geolocation_mechanism?: string | undefined;
  ip_address: string;
  user_agent?: string | undefined;
};

/** @internal */
export const DeviceMetadataCreate$outboundSchema: z.ZodType<
  DeviceMetadataCreate$Outbound,
  z.ZodTypeDef,
  DeviceMetadataCreate
> = z.object({
  deviceId: z.string().optional(),
  deviceType: DeviceType$outboundSchema.optional(),
  geolocation: LatLngCreate$outboundSchema.optional(),
  geolocationMechanism: GeolocationMechanism$outboundSchema.optional(),
  ipAddress: z.string(),
  userAgent: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    deviceId: "device_id",
    deviceType: "device_type",
    geolocationMechanism: "geolocation_mechanism",
    ipAddress: "ip_address",
    userAgent: "user_agent",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeviceMetadataCreate$ {
  /** @deprecated use `DeviceMetadataCreate$inboundSchema` instead. */
  export const inboundSchema = DeviceMetadataCreate$inboundSchema;
  /** @deprecated use `DeviceMetadataCreate$outboundSchema` instead. */
  export const outboundSchema = DeviceMetadataCreate$outboundSchema;
  /** @deprecated use `DeviceMetadataCreate$Outbound` instead. */
  export type Outbound = DeviceMetadataCreate$Outbound;
}

export function deviceMetadataCreateToJSON(
  deviceMetadataCreate: DeviceMetadataCreate,
): string {
  return JSON.stringify(
    DeviceMetadataCreate$outboundSchema.parse(deviceMetadataCreate),
  );
}

export function deviceMetadataCreateFromJSON(
  jsonString: string,
): SafeParseResult<DeviceMetadataCreate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeviceMetadataCreate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeviceMetadataCreate' from JSON`,
  );
}
