/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * **Field Dependencies:**
 *
 * @remarks
 *
 * Required if `type` is `REWARD`.
 */
export type FairMarketValue = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * Identifier type for the asset being moved
 */
export enum PositionJournalIdentifierType {
  IdentifierTypeUnspecified = "IDENTIFIER_TYPE_UNSPECIFIED",
  Cusip = "CUSIP",
  Symbol = "SYMBOL",
  AssetId = "ASSET_ID",
}
/**
 * Identifier type for the asset being moved
 */
export type PositionJournalIdentifierTypeOpen = OpenEnum<
  typeof PositionJournalIdentifierType
>;

/**
 * Numeric quantity of securities being transferred. For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places.
 */
export type Quantity = {
  /**
   * The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
   */
  value?: string | undefined;
};

/**
 * The high level state of a transfer, one of:
 *
 * @remarks
 * - `PROCESSING` - The transfer is being processed and will be posted if successful.
 * - `PENDING_REVIEW` - The transfer is pending review and will continue processing if approved.
 * - `POSTED` - The transfer has been posted to the ledger and will be completed at the end of the processing window if not canceled first.
 * - `COMPLETED` - The transfer has been batched and completed.
 * - `REJECTED` - The transfer was rejected.
 * - `CANCELED` - The transfer was canceled.
 * - `RETURNED` - The transfer was returned.
 * - `POSTPONED` - The transfer is postponed and will resume processing during the next processing window.
 */
export enum PositionJournalStateState {
  StateUnspecified = "STATE_UNSPECIFIED",
  Processing = "PROCESSING",
  PendingReview = "PENDING_REVIEW",
  Posted = "POSTED",
  Completed = "COMPLETED",
  Rejected = "REJECTED",
  Canceled = "CANCELED",
  Returned = "RETURNED",
  Postponed = "POSTPONED",
}
/**
 * The high level state of a transfer, one of:
 *
 * @remarks
 * - `PROCESSING` - The transfer is being processed and will be posted if successful.
 * - `PENDING_REVIEW` - The transfer is pending review and will continue processing if approved.
 * - `POSTED` - The transfer has been posted to the ledger and will be completed at the end of the processing window if not canceled first.
 * - `COMPLETED` - The transfer has been batched and completed.
 * - `REJECTED` - The transfer was rejected.
 * - `CANCELED` - The transfer was canceled.
 * - `RETURNED` - The transfer was returned.
 * - `POSTPONED` - The transfer is postponed and will resume processing during the next processing window.
 */
export type PositionJournalStateStateOpen = OpenEnum<
  typeof PositionJournalStateState
>;

/**
 * The current state of the position journal
 */
export type PositionJournalState = {
  /**
   * The user or service that triggered the state update.
   */
  actor?: string | undefined;
  /**
   * Additional description of the transfer state.
   */
  message?: string | undefined;
  /**
   * Additional metadata relating to the transfer state. Included data depends on the state, e.g.:
   *
   * @remarks
   *  - Rejection reasons are included when the `state` is `REJECTED`
   *  - Reason and comment are included when `state` is `CANCELED`
   */
  metadata?: { [k: string]: any } | null | undefined;
  /**
   * The high level state of a transfer, one of:
   *
   * @remarks
   * - `PROCESSING` - The transfer is being processed and will be posted if successful.
   * - `PENDING_REVIEW` - The transfer is pending review and will continue processing if approved.
   * - `POSTED` - The transfer has been posted to the ledger and will be completed at the end of the processing window if not canceled first.
   * - `COMPLETED` - The transfer has been batched and completed.
   * - `REJECTED` - The transfer was rejected.
   * - `CANCELED` - The transfer was canceled.
   * - `RETURNED` - The transfer was returned.
   * - `POSTPONED` - The transfer is postponed and will resume processing during the next processing window.
   */
  state?: PositionJournalStateStateOpen | undefined;
  /**
   * The time of the state update.
   */
  updateTime?: Date | null | undefined;
};

/**
 * The type of position journal
 */
export enum PositionJournalType {
  TypeUnspecified = "TYPE_UNSPECIFIED",
  Reward = "REWARD",
}
/**
 * The type of position journal
 */
export type PositionJournalTypeOpen = OpenEnum<typeof PositionJournalType>;

/**
 * A position journal transfer. Securities are moved from a source account to a destination account
 */
export type PositionJournal = {
  /**
   * The external identifier supplied by the API caller Each request must have a unique pairing of `client_transfer_id` and `source_account`
   */
  clientTransferId?: string | undefined;
  /**
   * Optional description information that will attach to the transaction
   */
  description?: string | undefined;
  /**
   * The account that securities will be moved to
   */
  destinationAccount?: string | undefined;
  /**
   * **Field Dependencies:**
   *
   * @remarks
   *
   * Required if `type` is `REWARD`.
   */
  fairMarketValue?: FairMarketValue | null | undefined;
  /**
   * Identifier (of the type specified in `identifier_type`). All identifiers are assumed to represent "US" issued securities. Responses will supply the originally requested identifier.
   */
  identifier?: string | undefined;
  /**
   * Identifier type for the asset being moved
   */
  identifierType?: PositionJournalIdentifierTypeOpen | undefined;
  /**
   * The resource name of the position journal
   */
  name?: string | undefined;
  /**
   * Numeric quantity of securities being transferred. For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places.
   */
  quantity?: Quantity | null | undefined;
  /**
   * The account that securities will be moved from
   */
  sourceAccount?: string | undefined;
  /**
   * The current state of the position journal
   */
  state?: PositionJournalState | null | undefined;
  /**
   * The type of position journal
   */
  type?: PositionJournalTypeOpen | undefined;
};

/** @internal */
export const FairMarketValue$inboundSchema: z.ZodType<
  FairMarketValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type FairMarketValue$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const FairMarketValue$outboundSchema: z.ZodType<
  FairMarketValue$Outbound,
  z.ZodTypeDef,
  FairMarketValue
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FairMarketValue$ {
  /** @deprecated use `FairMarketValue$inboundSchema` instead. */
  export const inboundSchema = FairMarketValue$inboundSchema;
  /** @deprecated use `FairMarketValue$outboundSchema` instead. */
  export const outboundSchema = FairMarketValue$outboundSchema;
  /** @deprecated use `FairMarketValue$Outbound` instead. */
  export type Outbound = FairMarketValue$Outbound;
}

export function fairMarketValueToJSON(
  fairMarketValue: FairMarketValue,
): string {
  return JSON.stringify(FairMarketValue$outboundSchema.parse(fairMarketValue));
}

export function fairMarketValueFromJSON(
  jsonString: string,
): SafeParseResult<FairMarketValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FairMarketValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FairMarketValue' from JSON`,
  );
}

/** @internal */
export const PositionJournalIdentifierType$inboundSchema: z.ZodType<
  PositionJournalIdentifierTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(PositionJournalIdentifierType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const PositionJournalIdentifierType$outboundSchema: z.ZodType<
  PositionJournalIdentifierTypeOpen,
  z.ZodTypeDef,
  PositionJournalIdentifierTypeOpen
> = z.union([
  z.nativeEnum(PositionJournalIdentifierType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PositionJournalIdentifierType$ {
  /** @deprecated use `PositionJournalIdentifierType$inboundSchema` instead. */
  export const inboundSchema = PositionJournalIdentifierType$inboundSchema;
  /** @deprecated use `PositionJournalIdentifierType$outboundSchema` instead. */
  export const outboundSchema = PositionJournalIdentifierType$outboundSchema;
}

/** @internal */
export const Quantity$inboundSchema: z.ZodType<
  Quantity,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
});

/** @internal */
export type Quantity$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const Quantity$outboundSchema: z.ZodType<
  Quantity$Outbound,
  z.ZodTypeDef,
  Quantity
> = z.object({
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Quantity$ {
  /** @deprecated use `Quantity$inboundSchema` instead. */
  export const inboundSchema = Quantity$inboundSchema;
  /** @deprecated use `Quantity$outboundSchema` instead. */
  export const outboundSchema = Quantity$outboundSchema;
  /** @deprecated use `Quantity$Outbound` instead. */
  export type Outbound = Quantity$Outbound;
}

export function quantityToJSON(quantity: Quantity): string {
  return JSON.stringify(Quantity$outboundSchema.parse(quantity));
}

export function quantityFromJSON(
  jsonString: string,
): SafeParseResult<Quantity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Quantity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Quantity' from JSON`,
  );
}

/** @internal */
export const PositionJournalStateState$inboundSchema: z.ZodType<
  PositionJournalStateStateOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(PositionJournalStateState),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const PositionJournalStateState$outboundSchema: z.ZodType<
  PositionJournalStateStateOpen,
  z.ZodTypeDef,
  PositionJournalStateStateOpen
> = z.union([
  z.nativeEnum(PositionJournalStateState),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PositionJournalStateState$ {
  /** @deprecated use `PositionJournalStateState$inboundSchema` instead. */
  export const inboundSchema = PositionJournalStateState$inboundSchema;
  /** @deprecated use `PositionJournalStateState$outboundSchema` instead. */
  export const outboundSchema = PositionJournalStateState$outboundSchema;
}

/** @internal */
export const PositionJournalState$inboundSchema: z.ZodType<
  PositionJournalState,
  z.ZodTypeDef,
  unknown
> = z.object({
  actor: z.string().optional(),
  message: z.string().optional(),
  metadata: z.nullable(z.record(z.any())).optional(),
  state: PositionJournalStateState$inboundSchema.optional(),
  update_time: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "update_time": "updateTime",
  });
});

/** @internal */
export type PositionJournalState$Outbound = {
  actor?: string | undefined;
  message?: string | undefined;
  metadata?: { [k: string]: any } | null | undefined;
  state?: string | undefined;
  update_time?: string | null | undefined;
};

/** @internal */
export const PositionJournalState$outboundSchema: z.ZodType<
  PositionJournalState$Outbound,
  z.ZodTypeDef,
  PositionJournalState
> = z.object({
  actor: z.string().optional(),
  message: z.string().optional(),
  metadata: z.nullable(z.record(z.any())).optional(),
  state: PositionJournalStateState$outboundSchema.optional(),
  updateTime: z.nullable(z.date().transform(v => v.toISOString())).optional(),
}).transform((v) => {
  return remap$(v, {
    updateTime: "update_time",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PositionJournalState$ {
  /** @deprecated use `PositionJournalState$inboundSchema` instead. */
  export const inboundSchema = PositionJournalState$inboundSchema;
  /** @deprecated use `PositionJournalState$outboundSchema` instead. */
  export const outboundSchema = PositionJournalState$outboundSchema;
  /** @deprecated use `PositionJournalState$Outbound` instead. */
  export type Outbound = PositionJournalState$Outbound;
}

export function positionJournalStateToJSON(
  positionJournalState: PositionJournalState,
): string {
  return JSON.stringify(
    PositionJournalState$outboundSchema.parse(positionJournalState),
  );
}

export function positionJournalStateFromJSON(
  jsonString: string,
): SafeParseResult<PositionJournalState, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PositionJournalState$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PositionJournalState' from JSON`,
  );
}

/** @internal */
export const PositionJournalType$inboundSchema: z.ZodType<
  PositionJournalTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(PositionJournalType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const PositionJournalType$outboundSchema: z.ZodType<
  PositionJournalTypeOpen,
  z.ZodTypeDef,
  PositionJournalTypeOpen
> = z.union([
  z.nativeEnum(PositionJournalType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PositionJournalType$ {
  /** @deprecated use `PositionJournalType$inboundSchema` instead. */
  export const inboundSchema = PositionJournalType$inboundSchema;
  /** @deprecated use `PositionJournalType$outboundSchema` instead. */
  export const outboundSchema = PositionJournalType$outboundSchema;
}

/** @internal */
export const PositionJournal$inboundSchema: z.ZodType<
  PositionJournal,
  z.ZodTypeDef,
  unknown
> = z.object({
  client_transfer_id: z.string().optional(),
  description: z.string().optional(),
  destination_account: z.string().optional(),
  fair_market_value: z.nullable(z.lazy(() => FairMarketValue$inboundSchema))
    .optional(),
  identifier: z.string().optional(),
  identifier_type: PositionJournalIdentifierType$inboundSchema.optional(),
  name: z.string().optional(),
  quantity: z.nullable(z.lazy(() => Quantity$inboundSchema)).optional(),
  source_account: z.string().optional(),
  state: z.nullable(z.lazy(() => PositionJournalState$inboundSchema))
    .optional(),
  type: PositionJournalType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "client_transfer_id": "clientTransferId",
    "destination_account": "destinationAccount",
    "fair_market_value": "fairMarketValue",
    "identifier_type": "identifierType",
    "source_account": "sourceAccount",
  });
});

/** @internal */
export type PositionJournal$Outbound = {
  client_transfer_id?: string | undefined;
  description?: string | undefined;
  destination_account?: string | undefined;
  fair_market_value?: FairMarketValue$Outbound | null | undefined;
  identifier?: string | undefined;
  identifier_type?: string | undefined;
  name?: string | undefined;
  quantity?: Quantity$Outbound | null | undefined;
  source_account?: string | undefined;
  state?: PositionJournalState$Outbound | null | undefined;
  type?: string | undefined;
};

/** @internal */
export const PositionJournal$outboundSchema: z.ZodType<
  PositionJournal$Outbound,
  z.ZodTypeDef,
  PositionJournal
> = z.object({
  clientTransferId: z.string().optional(),
  description: z.string().optional(),
  destinationAccount: z.string().optional(),
  fairMarketValue: z.nullable(z.lazy(() => FairMarketValue$outboundSchema))
    .optional(),
  identifier: z.string().optional(),
  identifierType: PositionJournalIdentifierType$outboundSchema.optional(),
  name: z.string().optional(),
  quantity: z.nullable(z.lazy(() => Quantity$outboundSchema)).optional(),
  sourceAccount: z.string().optional(),
  state: z.nullable(z.lazy(() => PositionJournalState$outboundSchema))
    .optional(),
  type: PositionJournalType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    clientTransferId: "client_transfer_id",
    destinationAccount: "destination_account",
    fairMarketValue: "fair_market_value",
    identifierType: "identifier_type",
    sourceAccount: "source_account",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PositionJournal$ {
  /** @deprecated use `PositionJournal$inboundSchema` instead. */
  export const inboundSchema = PositionJournal$inboundSchema;
  /** @deprecated use `PositionJournal$outboundSchema` instead. */
  export const outboundSchema = PositionJournal$outboundSchema;
  /** @deprecated use `PositionJournal$Outbound` instead. */
  export type Outbound = PositionJournal$Outbound;
}

export function positionJournalToJSON(
  positionJournal: PositionJournal,
): string {
  return JSON.stringify(PositionJournal$outboundSchema.parse(positionJournal));
}

export function positionJournalFromJSON(
  jsonString: string,
): SafeParseResult<PositionJournal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PositionJournal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PositionJournal' from JSON`,
  );
}
